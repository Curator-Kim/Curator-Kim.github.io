<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Curator-Kim的小站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Curator-Kim的小站"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Curator-Kim的小站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="AFL源码阅读"><meta property="og:type" content="blog"><meta property="og:title" content="Curator-Kim"><meta property="og:url" content="https://curator-kim.github.io/"><meta property="og:site_name" content="Curator-Kim"><meta property="og:description" content="AFL源码阅读"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://curator-kim.github.io/img/icon.jpg"><meta property="article:published_time" content="2024-01-21T13:32:58.788Z"><meta property="article:modified_time" content="2024-09-18T07:03:33.466Z"><meta property="article:author" content="Curator-Kim"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/icon.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://curator-kim.github.io/2024/01/21/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},"headline":"Curator-Kim的小站","image":["http://curator-kim.github.io/2024/01/21/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/image-20230120180716165.png"],"datePublished":"2024-01-21T13:32:58.788Z","dateModified":"2024-09-18T07:03:33.466Z","author":{"@type":"Person","name":"Curator-Kim"},"description":"AFL源码阅读"}</script><link rel="canonical" href="http://curator-kim.github.io/2024/01/21/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/logo.png?raw=true" alt="Curator-Kim的小站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/album">Album</a><a class="navbar-item" href="/friend">Friend</a><a class="navbar-item" href="/message">Message</a><a class="navbar-item" href="/self-talking">Self-talking</a><a class="navbar-item" href="/music">Music</a><a class="navbar-item" href="/media">Media</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2024-01-21  <a class="commentCountImg" href="/2024/01/21/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>an hour  <i class="fas fa-pencil-alt"> </i>11.9 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile"> </h1><div class="content"><h1 id="AFL源码阅读"><a href="#AFL源码阅读" class="headerlink" title="AFL源码阅读"></a>AFL源码阅读</h1><span id="more"></span>
<h3 id="afl-gcc"><a href="#afl-gcc" class="headerlink" title="afl-gcc"></a>afl-gcc</h3><p>AFL中用于获取AFL-as变异器的部分，并指定变异参数</p>
<p>看Main函数部分，即可了解大致的执行流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"></span><br><span class="line">  if (isatty(2) &amp;&amp; !getenv(&quot;AFL_QUIET&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(cCYA &quot;afl-cc &quot; cBRI VERSION cRST &quot; by &lt;lcamtuf@google.com&gt;\n&quot;);</span><br><span class="line"></span><br><span class="line">  &#125; else be_quiet = 1;</span><br><span class="line"></span><br><span class="line">  if (argc &lt; 2) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(&quot;\n&quot;</span><br><span class="line">         &quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span><br><span class="line">         &quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span><br><span class="line">         &quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span><br><span class="line"></span><br><span class="line">         &quot;  CC=%s/afl-gcc ./configure\n&quot;</span><br><span class="line">         &quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span><br><span class="line"></span><br><span class="line">         &quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span><br><span class="line">         &quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    exit(1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find_as(argv[0]);</span><br><span class="line"></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">  execvp(cc_params[0], (char**)cc_params);</span><br><span class="line"></span><br><span class="line">  FATAL(&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;, cc_params[0]);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致流程就是</p>
<ul>
<li>find_as(): 找到AFL路径下的as编译器</li>
<li>edit_params()指定调用编译器的相关参数</li>
<li>execvp执行编译</li>
</ul>
<p>简单讲下两个主要函数的流程</p>
<ul>
<li><p>find_as(u8* argv0) </p>
<p>首先获取AFL_PATH的环境变量，然后尝试访问AFL_PATH/as这个文件，如果访问失败，获取路径中最后一个文件夹，访问该文件夹下afl-as文件。如果两种都没找到则报错</p>
</li>
<li><p>edit_params(u32 argc, char** argv)</p>
<p>传递给编译器的参数，并根据编译器类型如GCC、Clang和操作系统类型做调整，并会将所要编译的软件添加一些需要的参数</p>
<img src="/2024/01/21/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/image-20230120180716165.png" class title="image-20230120180716165">    
</li>
</ul>
<h3 id="afl-as-h"><a href="#afl-as-h" class="headerlink" title="afl-as.h"></a>afl-as.h</h3><p>存储编译级别的插桩数据，插桩存储异或后的数据对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shm_trace_map[cur_loc ^ prev_loc]++</span><br></pre></td></tr></table></figure>
<p>注意插桩在X86结构的系统上实现，而苹果系统不支持</p>
<p>作者的performances notes也很有意思</p>
<blockquote>
<ul>
<li><p>只有 trampoline_fmt 和non-setup的 __afl_maybe_log代码路径真正值得优化；setup / forkserver不那么重要，主要应保持可读性。</p>
</li>
<li><p>我们的目标是采用无序执行和大型流水线的现代 CPU；代码主要遵循直观的、人类可读的指令排序，因为 “教科书式 “的手动重排序没有实质性的区别。</p>
</li>
<li><p>有趣的是，如果我们存储一个指向设置、日志或返回例程的变量指针，然后在 trampoline_fmt 中进行 reg 调用，插桩执行的速度并不会快很多。不过，非插桩执行速度确实快了不少，因为路径变成了 push-call-ret-pop。</p>
</li>
<li><p>在固定地址执行 SHM attach 而不是检索 __afl_area_ptr，也没有太多好处。虽然这样可以缩短插入条件跳转和跳转标签的日志例程（提高约 10% 的性能），但也有可能撞上程序或 ASAN 等工具创建的其他分配。</p>
</li>
<li><p>popf 的速度非常慢，这就是我们使用 lahf / sahf + 溢出测试技巧的原因。不幸的是，这迫使我们对 eax / rax 产生污点，但这种对常用寄存器的依赖性仍然胜过使用 pushf / popf。</p>
<p>一种可能的优化方法是使用循环缓冲区，只存储当前位置的序列，离线进行 XOR 处理，从而避免接触标志。唉，这样做似乎影响不大：</p>
</li>
<li><p>提前预叉一个子节点，然后在子节点中等待 “go “命令，并不会带来很大的性能提升；如今，fork()的成本似乎相对较低。预分叉多个子代确实有帮助，但会严重破坏 “每个模糊器~1 个内核 “的设计，使其更难扩展。也许还有一些中间方案。</p>
</li>
</ul>
<p>也许值得注意的是：在除 Apple 之外的所有平台的 64 位版本中，插桩的方式与 32 位版本略有不同，<strong>afl_prev_loc 和 </strong>afl_area_ptr 是对象文件的本地文件 (.lcomm) 而不是全局文件 (.comm) 。这样做是为了避免在关键代码路径中查找 GOTRELPC，而如果我们想让 gcc -shared 正常工作，查找 GOTRELPC 是不可避免的；在这种情况下，.bss 和 .text 之间的简单重定位在大多数 64 位平台上都无法正常工作。</p>
<p>(Fun fact: on Apple systems, .lcomm can segfault the linker.)</p>
<p>这样做的副作用是，状态转换的测量方式有些不同，每个 .c 文件的范围内都会单独记录前一个元组。这应该不会产生任何实际影响。</p>
<p>这种设计的另一个副作用是，在非工具模式下运行时，每个 .o 文件都会调用一次 getenv()；由于 getenv() 往往会以有趣的方式进行优化，因此我们需要非常小心地保存它可能会接触到的每个奇怪寄存器。</p>
</blockquote>
<p>尝试分析其中一段用于插桩的汇编代码，可以看到只是开辟了一段栈空间，并保存了寄存器的值，然后调用__afl_maybe_log函数用于记录，然后从栈空间中还原寄存器的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi,  0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx,  4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx,  8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl  8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl  4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl  0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>payload解析：</p>
<h3 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="afl-as.c"></a>afl-as.c</h3><p>as为汇编器assembler的缩写，可以看出来afl-as其实就是GCC/Clang的一个封装，在GCC/Clang生成的汇编文件中注入插桩代码</p>
<p>在开始代码分析前，关注一些关键变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> u8** as_params;          <span class="comment">/* Parameters passed to the real &#x27;as&#x27;，传递给as的参数   */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> u8*  input_file;         <span class="comment">/* Originally specified input file ，输入文件     */</span></span><br><span class="line"><span class="keyword">static</span> u8*  modified_file;      <span class="comment">/* Instrumented file for the real &#x27;as&#x27;，as进行插桩处理的文件  */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> u8   be_quiet,           <span class="comment">/* Quiet mode (no stderr output) ，静默模式，没有标准输出       */</span></span><br><span class="line">            clang_mode,         <span class="comment">/* Running in clang mode?    是否运行在clang模式           */</span></span><br><span class="line">            pass_thru,          <span class="comment">/* Just pass data through?   只通过数据           */</span></span><br><span class="line">            just_version,       <span class="comment">/* Just show version?        只显示版本   */</span></span><br><span class="line">            sanitizer;          <span class="comment">/* Using ASAN / MSAN         是否使用ASAN/MSAN           */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> u32  inst_ratio = <span class="number">100</span>,   <span class="comment">/* Instrumentation probability (%)  插桩覆盖率    */</span></span><br><span class="line">            as_par_cnt = <span class="number">1</span>;     <span class="comment">/* Number of params to &#x27;as&#x27;    传递给as的参数数量初始值         */</span></span><br></pre></td></tr></table></figure>
<p>看一看main函数，首先程序会获取一些环境变量，如AFL_INST_RATIO等，然后初始化随机数种子，通过edit_params()检查并编辑所传入的参数，最后通过add_instrumentation()函数执行代码插桩，那么重点即是关注这两个函数</p>
<h3 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>首先关注其中所定义的变量</p>
<p>AFL中定义了上百个变量，此处仅摘出部分</p>
<p>第一部分主要是文件指针，指向输入文件、文件夹等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lots of globals, but mostly for the status UI and other things where it</span></span><br><span class="line"><span class="comment">   really makes no sense to haul them around as function parameters. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXP_ST u8 *in_dir,                    <span class="comment">/* Input directory with test cases  */</span></span><br><span class="line">          *out_file,                  <span class="comment">/* File to fuzz, if any             */</span></span><br><span class="line">          *out_dir,                   <span class="comment">/* Working &amp; output directory       */</span></span><br><span class="line">          *sync_dir,                  <span class="comment">/* Synchronization directory        */</span></span><br><span class="line">          *sync_id,                   <span class="comment">/* Fuzzer ID                        */</span></span><br><span class="line">          *use_banner,                <span class="comment">/* Display banner                   */</span></span><br><span class="line">          *in_bitmap,                 <span class="comment">/* Input bitmap                     */</span></span><br><span class="line">          *doc_path,                  <span class="comment">/* Path to documentation dir        */</span></span><br><span class="line">          *target_path,               <span class="comment">/* Path to target binary            */</span></span><br><span class="line">          *orig_cmdline;              <span class="comment">/* Original command line            */</span></span><br></pre></td></tr></table></figure>
<p>第二部分则是config类型的变量，包括执行限制时间、内存限制等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXP_ST u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */</span><br><span class="line">static u32 hang_tmout = EXEC_TIMEOUT; /* Timeout used for hang det (ms)   */</span><br><span class="line"></span><br><span class="line">EXP_ST u64 mem_limit  = MEM_LIMIT;    /* Memory cap for child (MB)        */</span><br><span class="line"></span><br><span class="line">EXP_ST u32 cpu_to_bind = 0;           /* id of free CPU core to bind      */</span><br><span class="line"></span><br><span class="line">static u32 stats_update_freq = 1;     /* Stats update frequency (execs)   */</span><br></pre></td></tr></table></figure>
<h4 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h4><p>部分定义的函数及作用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get_cur_time() 				<span class="comment">//获取unix时间(millisecond)</span></span><br><span class="line">get_cur_time_us()			<span class="comment">//获取unix时间(microseconds)</span></span><br><span class="line">UR()						<span class="comment">//产生一个随机数(0——limit-1)</span></span><br><span class="line">shuffle_ptrs()				<span class="comment">//打乱数组内的指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>bind_to_free_cpu(void)函数：该函数主要功能是利用多个CPU核心并行化执行测试任务。该函数首先会检查linux下的proc文件夹，检查有进程都使用了哪些CPU，然后挑选出其中未使用的CPU，将进程自身绑定到对应的CPU核上。</li>
<li>locate_diffs(u8<em> ptr1, u8</em> ptr2, u32 len, s32<em> first, s32</em> last)：用于定位两个缓冲区中第一个和最后一个不同的地方。用它找到拼接两个文件的合理位置</li>
<li>DI(u64 val)：用于将大整数转换为人可读的形式，例如将 1000000 转换为 “1.00M”，使用静态缓冲区来避免频繁分配内存，提高性能。</li>
<li>DF(double val)：作用与DI类似，用于形容浮点数</li>
<li>DMS(u64 val)：作用与DI类似，用于形容空间大小，及Kb，除数也使用了1024的幂次形式</li>
<li>DTD(u64 cur_ms, u64 event_ms)：计算时间差，并转换为x天x小时x分x秒的形式</li>
<li>mark_as_det_done(struct queue_entry* q)：用于避免在恢复中断的扫描时重复进行确定性模糊测试，通过在queue/.state/deterministic_done/创建文件实现</li>
<li>mark_as_variable(struct queue_entry* q)：用于将给定的队列条目标记为具有可变行为。在 <code>.state/variable_behavior</code> 目录下创建一个指向队列条目文件的符号链接，如果无法创建符号链接，函数会退回到创建一个常规文件。</li>
<li>mark_as_redundant(struct queue_entry* q, u8 state)：用于将给定的队列条目标记为冗余（仅限边缘）或取消标记。</li>
<li>compare_extras_len(const void<em> p1, const void</em> p2)：获取额外的长度</li>
<li>compare_extras_use_d(const void<em> p1, const void</em> p2)：获取额外的击中次数</li>
<li>memcmp_nocase(u8<em> m1, u8</em> m2, u32 len)：不区分大小写去比较两个字符串</li>
<li>save_cmdline(u32 argc, char** argv)：复制当前命令行参数</li>
<li>check_if_tty(void)：检查是否在tty</li>
<li>get_core_count(void)：获得CPU核心数目</li>
<li>write_stats_file(double bitmap_cvg, double stability, double eps)：写入fuzzer_stat信息</li>
</ul>
<h4 id="较主要的函数"><a href="#较主要的函数" class="headerlink" title="较主要的函数"></a>较主要的函数</h4><ul>
<li><p>add_to_queue(u8* fname, u32 len, u8 passed_det)：将新的测试样例添加到队列中。函数中会设置next_100指针，允许更快的迭代</p>
</li>
<li><p>destroy_queue(void)：释放掉整条队列</p>
</li>
<li><p>write_bitmap(void)：将位图写入文件fuzz_bitmap中</p>
</li>
<li><p>read_bitmap(u8* fname)：读取位图</p>
</li>
<li><p><strong>has_new_bits</strong>(u8* virgin_map)：用于检查当前执行路径是否引入了任何新的位组合。如果唯一的变化是特定位组合的命中计数，则返回 1；如果发现了新的位组合，则返回 2。函数会更新位图，因此后续调用总是返回 0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u8 <span class="title">has_new_bits</span><span class="params">(u8* virgin_map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">  u64* current = (u64*)trace_bits;</span><br><span class="line">  u64* virgin  = (u64*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  u32* current = (u32*)trace_bits;</span><br><span class="line">  u32* virgin  = (u32*)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32  i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  u8   ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for (*current &amp; *virgin) == 0 - i.e., no bits in current bitmap</span></span><br><span class="line"><span class="comment">       that have not been already cleared from the virgin map - since this will</span></span><br><span class="line"><span class="comment">       almost always be the case. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*current) &amp;&amp; unlikely(*current &amp; *virgin)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (likely(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        u8* cur = (u8*)current;</span><br><span class="line">        u8* vir = (u8*)virgin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;<span class="comment">//vir[i]=[0xff]表示未击中，cur[i]=0xff表示击中</span></span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>)) ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      *virgin &amp;= ~*current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret &amp;&amp; virgin_map == virgin_bits) bitmap_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>count_bits</strong>(u8* mem)：用于计算提供的位图中设置为 1 的位的数量。</p>
<p>这里用到Hamming weight的算法，还挺有意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v -= ((v &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">v = (v &amp; <span class="number">0x33333333</span>) + ((v &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">ret += (((v + (v &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0xF0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line"><span class="comment">// ret为最后的结果</span></span><br></pre></td></tr></table></figure>
<p>经典Hamming weight的算法如下：</p>
<blockquote>
<p>第一步：</p>
<p>计算出来的值i的二进制可以按每2个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</p>
<p>第二步：</p>
<p>计算出来的值i的二进制可以按每4个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</p>
<p>第三步：</p>
<p>计算出来的值i的二进制可以按每8个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。</p>
<p>第四步：</p>
<p>i * (0x01010101)计算出汉明重量并记录在二进制的高八位，&gt;&gt;24语句则通过右移运算，将汉明重量移到最低八位，最后二进制对应的十进制数就是汉明重量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hamming_weight</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">    i = (i * (<span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>count_bytes(u8* mem)：用于计数有多少个位图中有字节被击中</p>
</li>
<li><p>count_non_255_bytes(u8* mem)：用于计数非255的字节个数，用于状态屏幕</p>
</li>
<li><p>simplify_trace(u64* mem)：简化位图跟踪，仅用0x80或0x01表示元组是否被命中，仅在发生崩溃或超时时调用</p>
</li>
<li><p>classify_counts(u64* mem)：对跟踪中的执行次数进行分类，但没看懂</p>
</li>
<li><p>static void remove_shm(void)：通过系统调用shmctl删除共享内存，在代码中通过atexit(remove_shm)调用，使得程序退出时能够清楚共享内存</p>
</li>
<li><p><strong>minimize_bits</strong>(u8<em> dst, u8</em> src)：将追踪字节压缩到位图中，丢弃计数信息</p>
<p>（猜测一开始用字节来追踪程序执行路径，然后通过该函数压缩为比特并反映在位图中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minimize_bits</span><span class="params">(u8* dst, u8* src)</span> </span>&#123;</span><br><span class="line">  u32 i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; MAP_SIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(src++)) dst[i &gt;&gt; <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>);<span class="comment">//得到i在字节中的位置</span></span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>update_bitmap_score</strong>(struct queue_entry* q)：用于优化模糊测试过程。当发现新路径时，会调用该方法，维护能够触发位图上所有位的最小集合。</p>
<p>函数定义了fav_factor来作为评判依据，由测试样例的执行时间与大小相乘所得，若新样例的fav_factor更小，则更新top_rated</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update_bitmap_score</span><span class="params">(struct queue_entry* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">            previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;</span><br><span class="line">           ck_free(top_rated[i]-&gt;trace_mini);</span><br><span class="line">           top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"></span><br><span class="line">       top_rated[i] = q;</span><br><span class="line">       q-&gt;tc_ref++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">         q-&gt;trace_mini = ck_alloc(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         minimize_bits(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       score_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cull_queue(void)</strong>：用于优化和筛选测试用例队列。函数中会遍历top_rated，将其中的测试样例标记为favored，使其获得更多的测试时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cull_queue</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span>;</span></span><br><span class="line">  <span class="keyword">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>; <span class="comment">//处于dumb模式(无插桩)或top_rated数组没有改变，则直接退出</span></span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>); <span class="comment">//临时位图，全1表示还未被覆盖，0则是被覆盖</span></span><br><span class="line"></span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line"></span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];  <span class="comment">//注意trace_mini中被覆盖则是1，未覆盖是0，而temp_v中被覆盖是0，未覆盖是1</span></span><br><span class="line"></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  q = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123; <span class="comment">//// 遍历队列，不是favored的case（冗余的测试用例）被标记成redundant_edges</span></span><br><span class="line">    mark_as_redundant(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setup_shm(void)：配置共享内存和位图，将在开始时被调用。该函数会初始化三个位图，还有一段共享内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br></pre></td></tr></table></figure>
<p>然后会设置环境变量，使得被测程序可以访问该段共享内存，并将该段共享内存附加到自己的内存空间中</p>
</li>
<li><p>setup_post(void)：设置后处理器？不太清楚其作用</p>
</li>
<li><p>read_testcases(void)：从输入文件夹中读取所以测试样例，然后将他们加入队列，在开始时调用。使用scandir() + alphasort()，若使用readdir()则测试样例的顺序可能会混乱。该函数会检查路径/.state/deterministic_done/，确认是否完成deterministic fuzzing</p>
</li>
<li><p>load_extras_file(u8<em> fname, u32</em> min_len, u32* max_len, u32 dict_level)：暂时省略</p>
</li>
<li><p>load_extras(u8* dir)：在指定 -x 参数（）字典模式时，加载对应的字典到全局变量中。暂时省略</p>
</li>
<li><p>maybe_add_auto(u8* mem, u32 len)：用于将token加进词典中，加入过程中会检查是否与已有的token或interesting重复，加入后进行排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maybe_add_auto</span><span class="params">(u8* mem, u32 len)</span> </span>&#123; <span class="comment">//将mem加进词典</span></span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allow users to specify that they don&#x27;t want auto dictionaries. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Skip runs of identical bytes. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    <span class="keyword">if</span> (mem[<span class="number">0</span>] ^ mem[i]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i == len) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reject builtin interesting values. */</span></span><br><span class="line"><span class="comment">// 如果与内置的 interesting 表重复，则放弃。这里考虑了大小端</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    i = <span class="keyword">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i--) </span><br><span class="line">      <span class="keyword">if</span> (*((u16*)mem) == interesting_16[i] ||</span><br><span class="line">          *((u16*)mem) == SWAP16(interesting_16[i])) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">    i = <span class="keyword">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i--) </span><br><span class="line">      <span class="keyword">if</span> (*((u32*)mem) == interesting_32[i] ||</span><br><span class="line">          *((u32*)mem) == SWAP32(interesting_32[i])) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reject anything that matches existing extras. Do a case-insensitive</span></span><br><span class="line"><span class="comment">     match. We optimize by exploiting the fact that extras[] are sorted</span></span><br><span class="line"><span class="comment">     by size. */</span></span><br><span class="line"><span class="comment">// 如果 token 已经存在于用户所提供的词典（即 extras 数组），则放弃。比较时忽略大小写</span></span><br><span class="line"><span class="comment">// extras[]按照大小排序好了</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; extras_cnt; i++)</span><br><span class="line">    <span class="keyword">if</span> (extras[i].len &gt;= len) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; extras_cnt &amp;&amp; extras[i].len == len; i++)</span><br><span class="line">    <span class="keyword">if</span> (!memcmp_nocase(extras[i].data, mem, len)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Last but not least, check a_extras[] for matches. There are no</span></span><br><span class="line"><span class="comment">     guarantees of a particular sort order. */</span></span><br><span class="line"></span><br><span class="line">  auto_changed = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 与自动发现的 extra（即 a_extras 数组）对比，去重，有重复的就增加hit_cnt</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a_extras_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a_extras[i].len == len &amp;&amp; !memcmp_nocase(a_extras[i].data, mem, len)) &#123;</span><br><span class="line"></span><br><span class="line">      a_extras[i].hit_cnt++;</span><br><span class="line">      <span class="keyword">goto</span> sort_a_extras;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* At this point, looks like we&#x27;re dealing with a new entry. So, let&#x27;s</span></span><br><span class="line"><span class="comment">     append it if we have room. Otherwise, let&#x27;s randomly evict some other</span></span><br><span class="line"><span class="comment">     entry from the bottom half of the list. */</span></span><br><span class="line"><span class="comment">// 将新发现的token加入词典中</span></span><br><span class="line">  <span class="keyword">if</span> (a_extras_cnt &lt; MAX_AUTO_EXTRAS) &#123;</span><br><span class="line"></span><br><span class="line">    a_extras = ck_realloc_block(a_extras, (a_extras_cnt + <span class="number">1</span>) *</span><br><span class="line">                                <span class="keyword">sizeof</span>(struct extra_data));</span><br><span class="line"></span><br><span class="line">    a_extras[a_extras_cnt].data = ck_memdup(mem, len);</span><br><span class="line">    a_extras[a_extras_cnt].len  = len;</span><br><span class="line">    a_extras_cnt++;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果词典大小已经达到上线，则随机扔掉后半部分的一个元素，并将新的token写入</span></span><br><span class="line">    i = MAX_AUTO_EXTRAS / <span class="number">2</span> +</span><br><span class="line">        UR((MAX_AUTO_EXTRAS + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ck_free(a_extras[i].data);</span><br><span class="line"></span><br><span class="line">    a_extras[i].data    = ck_memdup(mem, len);</span><br><span class="line">    a_extras[i].len     = len;</span><br><span class="line">    a_extras[i].hit_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">sort_a_extras:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First, sort all auto extras by use count, descending order. */</span></span><br><span class="line"><span class="comment">// 按照hit_cnt排序</span></span><br><span class="line">  qsort(a_extras, a_extras_cnt, <span class="keyword">sizeof</span>(struct extra_data),</span><br><span class="line">        compare_extras_use_d);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then, sort the top USE_AUTO_EXTRAS entries by size. */</span></span><br><span class="line"><span class="comment">// 将前50按照size排序</span></span><br><span class="line">  qsort(a_extras, MIN(USE_AUTO_EXTRAS, a_extras_cnt),</span><br><span class="line">        <span class="keyword">sizeof</span>(struct extra_data), compare_extras_len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>save_auto(void)：暂时省略</p>
</li>
<li><p>load_auto(void)：暂时省略</p>
</li>
<li><p>destroy_extras(void)：暂时省略</p>
</li>
<li><p><strong>calibrate_case(char** argv, struct queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue)</strong></p>
<p>：用于检查测试用例。一般在两个时候调用：程序开始运行时，和发现新路径将interesting testcase加入队列时。函数中会多次执行样例，并检查具有可变行为的样例（通过位图的变化）</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">calibrate_case</span><span class="params">(<span class="keyword">char</span>** argv, struct queue_entry* q, u8* use_mem,</span></span></span><br><span class="line"><span class="params"><span class="function">                         u32 handicap, u8 from_queue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>, hnb = <span class="number">0</span>,</span><br><span class="line">      first_run = (q-&gt;exec_cksum == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8* old_sn = stage_name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span></span><br><span class="line"><span class="comment">     trying to calibrate already-added finds. This helps avoid trouble due</span></span><br><span class="line"><span class="comment">     to intermittent latency. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>); <span class="comment">//设置更宽松的执行超时限制</span></span><br><span class="line"></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;calibration&quot;</span>;</span><br><span class="line">  stage_max  = fast_cal ? <span class="number">3</span> : CAL_CYCLES; <span class="comment">//设置执行次数，如果想要calibration更快，则只执行3次</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the forkserver is up before we do anything, and let&#x27;s not</span></span><br><span class="line"><span class="comment">     count its spin-up time toward binary calibration. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    init_forkserver(argv); <span class="comment">// 启动forkserver</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE); <span class="comment">// 若已经有过 checksum，则将 trace_bits 备份到局部静态变量 first_trace（因为 trace_bits 马上就要被改掉了）</span></span><br><span class="line">    hnb = has_new_bits(virgin_bits);  <span class="comment">// 更新 virgin_bits。返回值：1 = 仅 hit count 更新；2 = 出现了新的边</span></span><br><span class="line">    <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats(); <span class="comment">//刷新ui</span></span><br><span class="line"></span><br><span class="line">    write_to_testcase(use_mem, q-&gt;len); <span class="comment">//写入testcase</span></span><br><span class="line"></span><br><span class="line">    fault = run_target(argv, use_tmout); <span class="comment">//运行样例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span></span><br><span class="line"><span class="comment">       we want to bail out quickly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || fault != crash_mode) <span class="keyword">goto</span> abort_calibration; <span class="comment">//退出处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123; <span class="comment">//没有命中纪录，说明没有插桩</span></span><br><span class="line">      fault = FAULT_NOINST;</span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;<span class="comment">// 此时，要么这个用例从未执行过，要么这个用例多次执行的表现不一致</span></span><br><span class="line"></span><br><span class="line">      hnb = has_new_bits(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;<span class="comment">//与此前执行表现不一致</span></span><br><span class="line"></span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123; <span class="comment">// 记录不一致的 hit count 位置，并把本用例的执行次数提升到 40 次</span></span><br><span class="line"></span><br><span class="line">            var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">            stage_max    = CAL_CYCLES_LONG; </span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_detected = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        q-&gt;exec_cksum = cksum;</span><br><span class="line">        <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  total_cal_us     += stop_us - start_us; <span class="comment">//计算总执行时间和轮次</span></span><br><span class="line">  total_cal_cycles += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OK, let&#x27;s collect some stats about the performance of this test case.</span></span><br><span class="line"><span class="comment">     This is used for fuzzing air time calculations in calculate_score(). */</span></span><br><span class="line"></span><br><span class="line">  q-&gt;exec_us     = (stop_us - start_us) / stage_max; <span class="comment">//收集执行信息</span></span><br><span class="line">  q-&gt;bitmap_size = count_bytes(trace_bits);</span><br><span class="line">  q-&gt;handicap    = handicap;</span><br><span class="line">  q-&gt;cal_failed  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  update_bitmap_score(q); <span class="comment">//给这个用例打分，并更新 top_rated 指针数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If this case didn&#x27;t result in new output from the instrumentation, tell</span></span><br><span class="line"><span class="comment">     parent. This is a non-critical problem, but something to warn the user</span></span><br><span class="line"><span class="comment">     about. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault = FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;<span class="comment">//发现新路径</span></span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>; </span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark variable paths. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_detected) &#123; <span class="comment">//观察到可变行为的样例</span></span><br><span class="line"></span><br><span class="line">    var_byte_count = count_bytes(var_bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior) &#123;</span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 退出 calibration 模式，恢复现场</span></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur  = old_sc;</span><br><span class="line">  stage_max  = old_sm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_run) show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>save_if_interesting(char\</strong> argv, void<em> mem, u32 len, u8 fault)：*</em>检查测试样例是否interesting，如果是则加入队列中或保留下来。</p>
<blockquote>
<ol>
<li><p>检查 <code>fault</code> 是否等于 <code>crash_mode</code>（表示是否遇到了崩溃）。如果是，则执行以下操作：</p>
<ul>
<li>调用 <code>has_new_bits()</code> 函数检查位图中是否有新位（即是否有新的覆盖路径）。如果没有，则返回 0。</li>
<li>如果当前模式是 <code>crash_mode</code>，则增加 <code>total_crashes</code> 计数器。</li>
<li>为保存测试案例的文件名分配内存，其中包含当前计数器和描述操作的字符串。</li>
<li>将测试案例添加到队列中以供将来使用。</li>
<li>如果有新的覆盖路径，则设置标志 <code>queue_top-&gt;has_new_cov</code>。</li>
<li>对测试案例执行校准以获得执行时间和覆盖信息。</li>
<li>打开文件并将测试案例写入其中。</li>
<li>设置 <code>keeping</code> 标志为 1。</li>
</ul>
</li>
<li><p>根据 <code>fault</code> 的不同值，执行以下操作：</p>
<ul>
<li><p>如果是超时FAULT_TMOUT</p>
<ul>
<li>如果超时数量已经超过了限制（<code>KEEP_UNIQUE_HANG</code>），则返回 <code>keeping</code>。</li>
<li>如果不是 <code>dumb_mode</code> 模式，则简化跟踪位图并检查是否有新的超时路径。如果没有，则返回 <code>keeping</code>。</li>
<li>增加超时数量计数器 <code>total_tmouts</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>如果默认超时时间不够长，则使用更长的超时时间重新运行目标程序，以验证是否真正出现了超时。</p>
<ul>
<li><p>为保存测试案例的文件名分配内存，其中包含当前计数器和描述操作的字符串。</p>
<ul>
<li>如果是崩溃FAULT_CRASH</li>
</ul>
</li>
<li><p>如果崩溃数量已经超过了限制（<code>KEEP_UNIQUE_CRASH</code>），则返回 <code>keeping</code>。</p>
</li>
<li>如果不是 <code>dumb_mode</code> 模式，则简化跟踪位图并检查是否有新的崩溃路径。如果没有，则返回 <code>keeping</code>。</li>
<li>输出一个关于保存崩溃的 readme 文件的消息（仅在第一次遇到崩溃时输出）。</li>
</ul>
</li>
<li><p>为保存测试案例的文件名分配内存，其中包含当前计数器、信号类型和描述操作的字符串。</p>
</li>
<li><p>如果是错误（<code>FAULT_ERROR</code>），则报告无法执行目标应用程序的错误。</p>
<ul>
<li>如果是其他情况，则返回 <code>keeping</code>。</li>
</ul>
</li>
</ul>
<ol>
<li>如果需要保存测试案例，则打开文件并将测试案例写入其中。然后释放用于保存文件名的内存并返回 <code>keeping</code>。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the result of an execve() during routine fuzzing is interesting,</span></span><br><span class="line"><span class="comment">   save or queue the input test case for further analysis if so. Returns 1 if</span></span><br><span class="line"><span class="comment">   entry is saved, 0 otherwise. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">save_if_interesting</span><span class="params">(<span class="keyword">char</span>** argv, <span class="keyword">void</span>* mem, u32 len, u8 fault)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8  *fn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  u8  hnb;</span><br><span class="line">  s32 fd;</span><br><span class="line">  u8  keeping = <span class="number">0</span>, res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == crash_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep only if there are new bits in the map, add to queue for</span></span><br><span class="line"><span class="comment">       future fuzzing, etc. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(hnb = has_new_bits(virgin_bits))) &#123;<span class="comment">//如果没有新的路径，则说明not interesting，退出</span></span><br><span class="line">      <span class="keyword">if</span> (crash_mode) total_crashes++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/queue/id:%06u,%s&quot;</span>, out_dir, queued_paths,</span><br><span class="line">                      describe_op(hnb));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    fn = alloc_printf(<span class="string">&quot;%s/queue/id_%06u&quot;</span>, out_dir, queued_paths);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">    add_to_queue(fn, len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hnb == <span class="number">2</span>) &#123;</span><br><span class="line">      queue_top-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">      queued_with_cov++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue_top-&gt;exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to calibrate inline; this also calls update_bitmap_score() when</span></span><br><span class="line"><span class="comment">       successful. */</span></span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, queue_top, mem, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">      FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">    ck_write(fd, mem, len, fn);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    keeping = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (fault) &#123;<span class="comment">//根据错误进行选择</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_TMOUT:</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Timeouts are not very interesting, but we&#x27;re still obliged to keep</span></span><br><span class="line"><span class="comment">         a handful of samples. We use the presence of new bits in the</span></span><br><span class="line"><span class="comment">         hang-specific bitmap as a signal of uniqueness. In &quot;dumb&quot; mode, we</span></span><br><span class="line"><span class="comment">         just keep everything. */</span></span><br><span class="line"></span><br><span class="line">      total_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_hangs &gt;= KEEP_UNIQUE_HANG) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        simplify_trace((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        simplify_trace((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!has_new_bits(virgin_tmout)) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      unique_tmouts++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Before saving, we make sure that it&#x27;s a genuine hang by re-running</span></span><br><span class="line"><span class="comment">         the target with a more generous timeout (unless the default timeout</span></span><br><span class="line"><span class="comment">         is already generous). */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (exec_tmout &lt; hang_tmout) &#123;</span><br><span class="line"></span><br><span class="line">        u8 new_fault;</span><br><span class="line">        write_to_testcase(mem, len);</span><br><span class="line">        new_fault = run_target(argv, hang_tmout); <span class="comment">//重新运行一次，确保是真正的挂起</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A corner case that one user reported bumping into: increasing the</span></span><br><span class="line"><span class="comment">           timeout actually uncovers a crash. Make sure we don&#x27;t discard it if</span></span><br><span class="line"><span class="comment">           so. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!stop_soon &amp;&amp; new_fault == FAULT_CRASH) <span class="keyword">goto</span> keep_as_crash; <span class="comment">//提升运行时间时可能会发现崩溃</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stop_soon || new_fault != FAULT_TMOUT) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      fn = alloc_printf(<span class="string">&quot;%s/hangs/id:%06llu,%s&quot;</span>, out_dir,</span><br><span class="line">                        unique_hangs, describe_op(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      fn = alloc_printf(<span class="string">&quot;%s/hangs/id_%06llu&quot;</span>, out_dir,</span><br><span class="line">                        unique_hangs);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_hangs++;</span><br><span class="line"></span><br><span class="line">      last_hang_time = get_cur_time();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_CRASH:</span><br><span class="line"></span><br><span class="line">keep_as_crash: </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This is handled in a manner roughly similar to timeouts,</span></span><br><span class="line"><span class="comment">         except for slightly different limits and no need to re-run test</span></span><br><span class="line"><span class="comment">         cases. */</span></span><br><span class="line"></span><br><span class="line">      total_crashes++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique_crashes &gt;= KEEP_UNIQUE_CRASH) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">        simplify_trace((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        simplify_trace((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!has_new_bits(virgin_crash)) <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!unique_crashes) write_crash_readme();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIMPLE_FILES</span></span><br><span class="line"></span><br><span class="line">      fn = alloc_printf(<span class="string">&quot;%s/crashes/id:%06llu,sig:%02u,%s&quot;</span>, out_dir,</span><br><span class="line">                        unique_crashes, kill_signal, describe_op(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      fn = alloc_printf(<span class="string">&quot;%s/crashes/id_%06llu_%02u&quot;</span>, out_dir, unique_crashes,</span><br><span class="line">                        kill_signal);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^!SIMPLE_FILES */</span></span></span><br><span class="line"></span><br><span class="line">      unique_crashes++;</span><br><span class="line"></span><br><span class="line">      last_crash_time = get_cur_time();</span><br><span class="line">      last_crash_execs = total_execs;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FAULT_ERROR: FATAL(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re here, we apparently want to save the crash or hang</span></span><br><span class="line"><span class="comment">     test case, too. */</span></span><br><span class="line"></span><br><span class="line">  fd = open(fn, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">  ck_write(fd, mem, len, fn);</span><br><span class="line">  close(fd);</span><br><span class="line"></span><br><span class="line">  ck_free(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> keeping;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>init_forkserver(char*‘* argv’)：</strong></p>
<p>设置fork server，通过保持子进程来避免多次执行execve()，使用pipe来进行进程间通信，获取执行结果</p>
<img src="/2024/01/21/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vgdklauwfw.drawio--2-.svg" class title="img">
<p>from <a target="_blank" rel="noopener" href="https://www.ruanx.net/afl-source-5/">AFL源码阅读（五）：fuzzer启动 (ruanx.net)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_forkserver</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  s32 rlen;</span><br><span class="line"></span><br><span class="line">  ACTF(<span class="string">&quot;Spinning up the fork server...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(st_pipe) || pipe(ctl_pipe)) PFATAL(<span class="string">&quot;pipe() failed&quot;</span>); <span class="comment">//创建管道</span></span><br><span class="line"></span><br><span class="line">  forksrv_pid = fork(); <span class="comment">//创建子进程为forkserver</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123; <span class="comment">//子进程的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span>  <span class="comment">//rlimit类型——资源限制，包含内存、CPU时间等，&lt;sys/resource.h&gt;中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Umpf. On OpenBSD, the default fd limit for root users is set to</span></span><br><span class="line"><span class="comment">       soft 128. Let&#x27;s try to fix that... */</span></span><br><span class="line"><span class="comment">//修改fd上限到200</span></span><br><span class="line">    <span class="keyword">if</span> (!getrlimit(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">      r.rlim_cur = FORKSRV_FD + <span class="number">2</span>;</span><br><span class="line">      setrlimit(RLIMIT_NOFILE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">      r.rlim_max = r.rlim_cur = ((<span class="keyword">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* This takes care of OpenBSD, which doesn&#x27;t have RLIMIT_AS, but</span></span><br><span class="line"><span class="comment">         according to reliable sources, RLIMIT_DATA covers anonymous</span></span><br><span class="line"><span class="comment">         maps - so we should be getting good protection against OOM bugs. */</span></span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered</span></span><br><span class="line"><span class="comment">       before the dump is complete. */</span></span><br><span class="line"><span class="comment">// rlim_max: 表示资源的硬限制，即资源的最大限制。rlim_cur: 表示当前的资源限制。</span></span><br><span class="line">    r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setrlimit(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"></span><br><span class="line">    setsid(); <span class="comment">//起一个新的进程组</span></span><br><span class="line"><span class="comment">//int dup2(int oldfd, int newfd); 关闭 newfd 指向的文件描述符（如果 newfd 已经打开的话），然后将 oldfd 复制到 newfd，并返回 newfd。</span></span><br><span class="line">    dup2(dev_null_fd, <span class="number">1</span>); <span class="comment">//关闭stdout</span></span><br><span class="line">    dup2(dev_null_fd, <span class="number">2</span>); <span class="comment">//关闭stderr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line"><span class="comment">//如果以文件为输入，则关闭stdin</span></span><br><span class="line">      dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//输入重定向到out_fd</span></span><br><span class="line">      dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">      close(out_fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);<span class="comment">// 将 fd 198 重定向到 ctl_pipe[0] 以接收 supervisor 指令</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);<span class="comment">// 将 fd 199 重定向到 st_pipe[1] 以向 supervisor 发送回复</span></span><br><span class="line"><span class="comment">//关闭无用的管道，只保留fd 198 和 fd 199</span></span><br><span class="line">    close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line">    close(st_pipe[<span class="number">0</span>]);</span><br><span class="line">    close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 这几个 fd 是从 afl-fuzz 进程遗传下来的，与 fork server 没关系，需要关掉</span></span><br><span class="line">    close(out_dir_fd);</span><br><span class="line">    close(dev_null_fd);</span><br><span class="line">    close(dev_urandom_fd);</span><br><span class="line">    close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This should improve performance a bit, since it stops the linker from</span></span><br><span class="line"><span class="comment">       doing extra work post-fork(). */</span></span><br><span class="line"><span class="comment">//设置环境变量</span></span><br><span class="line">    <span class="keyword">if</span> (!getenv(<span class="string">&quot;LD_BIND_LAZY&quot;</span>)) setenv(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MSAN is tricky, because it doesn&#x27;t support abort_on_error=1 at this</span></span><br><span class="line"><span class="comment">       point. So, we do this in a very hacky way. */</span></span><br><span class="line"></span><br><span class="line">    setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                           <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                           <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                           <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//执行目标程序</span></span><br><span class="line">    execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv()</span></span><br><span class="line"><span class="comment">       falling through. */</span></span><br><span class="line"><span class="comment">//正常情况下执行不到这里。如果执行到这里，说明 execv 失败了</span></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Close the unneeded endpoints. */</span></span><br><span class="line"><span class="comment">// 父进程代码</span></span><br><span class="line"><span class="comment">// 关闭无用管道口</span></span><br><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//设置控制管道和状态读取管道</span></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the fork server to come up, but don&#x27;t wait too long. */</span></span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 设置定时器</span></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);<span class="comment">//读取来自forkserver的4字节，注意read是阻塞的</span></span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    FATAL(<span class="string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (waitpid(forksrv_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="comment">//等待子进程执行结束</span></span><br><span class="line">    PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;<span class="comment">//根据返回状态给出建议</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan) &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! Since it seems to be built with ASAN and you have a\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    restrictive memory limit configured, this is expected; please read\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Whoops, the target binary crashed suddenly, before receiving any input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    from the fuzzer! There are several probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      target to hit an OOM condition in the dynamic linker. Try bumping up\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      the limit with the -m setting in the command line. A simple way confirm\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      this diagnosis would be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">           <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - The binary is just buggy and explodes entirely on its own. If so, you\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      need to fix the underlying problem or find a better replacement.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      break afl-fuzz performance optimizations when running platform-specific\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">           <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">           <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">           DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FATAL(<span class="string">&quot;Fork server crashed with signal %d&quot;</span>, WTERMSIG(status));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*(u32*)trace_bits == EXEC_FAIL_SIG)</span><br><span class="line">    FATAL(<span class="string">&quot;Unable to execute target application (&#x27;%s&#x27;)&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem_limit &amp;&amp; mem_limit &lt; <span class="number">500</span> &amp;&amp; uses_asan) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    handshake with the injected code. Since it seems to be built with ASAN and\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    you have a restrictive memory limit configured, this is expected; please\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    read %s/notes_for_asan.txt for help.\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. Perhaps there is a horrible bug in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    fuzzer. Poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Hmm, looks like the target binary terminated before we could complete a\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    handshake with the injected code. There are %s probable explanations:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;%s&quot;</span></span><br><span class="line">         <span class="string">&quot;    - The current memory limit (%s) is too restrictive, causing an OOM\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      fault in the dynamic linker. This can be fixed with the -m option. A\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      simple way to confirm the diagnosis may be:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">         <span class="string">&quot;      ( ulimit -Sv $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">         <span class="string">&quot;      ( ulimit -Sd $[%llu &lt;&lt; 10]; /path/to/fuzzed_app )\n\n&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;      Tip: you can use http://jwilk.net/software/recidivm to quickly\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      estimate the required amount of virtual memory for the binary.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;    - Less likely, there is a horrible bug in the fuzzer. If other options\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      fail, poke &lt;lcamtuf@coredump.cx&gt; for troubleshooting tips.\n&quot;</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ? <span class="string">&quot;three&quot;</span> : <span class="string">&quot;two&quot;</span>,</span><br><span class="line">         getenv(DEFER_ENV_VAR) ?</span><br><span class="line">         <span class="string">&quot;    - You are using deferred forkserver, but __AFL_INIT() is never\n&quot;</span></span><br><span class="line">         <span class="string">&quot;      reached before the program terminates.\n\n&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">         DMS(mem_limit &lt;&lt; <span class="number">20</span>), mem_limit - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>run_target(char** argv, u32 timeout)</strong>：执行目标程序，并要求在指定的时间内完成，执行完成后会返回对应的状态信息，同时更新trace_bits</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">run_target</span><span class="params">(<span class="keyword">char</span>** argv, u32 timeout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">static</span> u32 prev_timed_out = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> u64 exec_ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">  u32 tb4;</span><br><span class="line"></span><br><span class="line">  child_timed_out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* After this memset, trace_bits[] are effectively volatile, so we</span></span><br><span class="line"><span class="comment">     must prevent any earlier operations from venturing into that</span></span><br><span class="line"><span class="comment">     territory. */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we&#x27;re running in &quot;dumb&quot; mode, we can&#x27;t rely on the fork server</span></span><br><span class="line"><span class="comment">     logic compiled into the target program, so we will just keep calling</span></span><br><span class="line"><span class="comment">     execve(). There is a bit of code duplication between here and </span></span><br><span class="line"><span class="comment">     init_forkserver(), but c&#x27;est la vie. */</span></span><br><span class="line"><span class="comment">// dumb模式下直接使用execve执行，而非使用forkserver</span></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) &#123;</span><br><span class="line"></span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"><span class="comment">// 子进程代码 类似forkserver</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line"></span><br><span class="line">        r.rlim_max = r.rlim_cur = ((<span class="keyword">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line"></span><br><span class="line">        setrlimit(RLIMIT_AS, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        setrlimit(RLIMIT_DATA, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^RLIMIT_AS */</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      setrlimit(RLIMIT_CORE, &amp;r); <span class="comment">/* Ignore errors */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Isolate the process and configure standard descriptors. If out_file is</span></span><br><span class="line"><span class="comment">         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span></span><br><span class="line"></span><br><span class="line">      setsid();</span><br><span class="line"></span><br><span class="line">      dup2(dev_null_fd, <span class="number">1</span>);</span><br><span class="line">      dup2(dev_null_fd, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line"></span><br><span class="line">        dup2(dev_null_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        dup2(out_fd, <span class="number">0</span>);</span><br><span class="line">        close(out_fd);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */</span></span><br><span class="line"></span><br><span class="line">      close(dev_null_fd);</span><br><span class="line">      close(out_dir_fd);</span><br><span class="line">      close(dev_urandom_fd);</span><br><span class="line">      close(fileno(plot_file));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Set sane defaults for ASAN if nothing else specified. */</span></span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                             <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      setenv(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> STRINGIFY(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                             <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                             <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      execv(target_path, argv);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Use a distinctive bitmap value to tell the parent about execv()</span></span><br><span class="line"><span class="comment">         falling through. */</span></span><br><span class="line"></span><br><span class="line">      *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 正常情况，使用fork server来执行进程</span></span><br><span class="line">    s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply</span></span><br><span class="line"><span class="comment">       tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;<span class="comment">//向forkserver写入4字节，使其启动执行</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;<span class="comment">// 读child pid</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to request new process from fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt;= <span class="number">0</span>) FATAL(<span class="string">&quot;Fork server is misbehaving (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure timeout, as requested by user, then wait for child to terminate. */</span></span><br><span class="line"><span class="comment">//设置超时时间</span></span><br><span class="line">  it.it_value.tv_sec = (timeout / <span class="number">1000</span>);</span><br><span class="line">  it.it_value.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">1</span> || no_forkserver) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) PFATAL(<span class="string">&quot;waitpid() failed&quot;</span>); <span class="comment">//dumb模式，等待子进程执行完</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>) &#123;<span class="comment">// 从 fork server 读取 child 退出原因</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      RPFATAL(res, <span class="string">&quot;Unable to communicate with fork server (OOM?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!WIFSTOPPED(status)) child_pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  getitimer(ITIMER_REAL, &amp;it);</span><br><span class="line">  exec_ms = (u64) timeout - (it.it_value.tv_sec * <span class="number">1000</span> +</span><br><span class="line">                             it.it_value.tv_usec / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">  it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setitimer(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  total_execs++;<span class="comment">//总执行次数++</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Any subsequent operations on trace_bits must not be moved by the</span></span><br><span class="line"><span class="comment">     compiler below this point. Past this location, trace_bits[] behave</span></span><br><span class="line"><span class="comment">     very normally and do not have to be treated as volatile. */</span></span><br><span class="line"></span><br><span class="line">  MEM_BARRIER();</span><br><span class="line"></span><br><span class="line">  tb4 = *(u32*)trace_bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line">  classify_counts((u64*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  classify_counts((u32*)trace_bits);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  prev_timed_out = child_timed_out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Report outcome to caller. */</span></span><br><span class="line"><span class="comment">//宏，用于检查一个子进程是否是由于收到信号而终止的 #define WIFSIGNALED(status)    (((status) &amp; 0xff) != 0)</span></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status); <span class="comment">//获取导致子进程终止的信号编号 #define WTERMSIG(status)    (((status) &amp; 0x7f))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT; <span class="comment">// 超时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH; <span class="comment">//崩溃</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A somewhat nasty hack for MSAN, which doesn&#x27;t support abort_on_error and</span></span><br><span class="line"><span class="comment">     must use a special exit code. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (uses_asan &amp;&amp; WEXITSTATUS(status) == MSAN_ERROR) &#123;</span><br><span class="line">    kill_signal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dumb_mode == <span class="number">1</span> || no_forkserver) &amp;&amp; tb4 == EXEC_FAIL_SIG)</span><br><span class="line">    <span class="keyword">return</span> FAULT_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* It makes sense to account for the slowest units only if the testcase was run</span></span><br><span class="line"><span class="comment">  under the user defined timeout. */</span></span><br><span class="line">  <span class="keyword">if</span> (!(timeout &gt; exec_tmout) &amp;&amp; (slowest_exec_ms &lt; exec_ms)) &#123;</span><br><span class="line">    slowest_exec_ms = exec_ms;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FAULT_NONE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>find_start_position(void)：在恢复模糊测试时尝试找到要从哪个队列位置开始。到路径下fuzzer_stats下获取队列起始位置的信息。（即从哪个开始fuzz）</p>
</li>
<li><p>find_timeout(void)：与find_start_position类似，获取超时设置信息。</p>
</li>
<li><p>load_auto(void)：加载自动生成的extra文件</p>
</li>
</ul>
<ul>
<li><p>pivot_inputs(void)：用于创建输入测试用例的硬链接到输出目录，并根据一定规则选择好的名称。</p>
</li>
<li><p>describe_op(u8 hnb)：构建文件名称，AFL的输出文件夹中包含测试样例，其名称中包含变异源文件、变异方法和变异位置等</p>
</li>
<li><p>setup_dirs_fds()：打开相应的输出文件，并获取文件指针</p>
</li>
<li><p>check_crash_handling(void)：检查core_pattern，避免崩溃被误认为超时，也是设置echo core &gt;/proc/sys/kernel/core_pattern的原因</p>
</li>
<li><p>check_cpu_governor(void)：检查CPU调频策略</p>
</li>
<li><p>setup_signal_handlers(void)：用于设置信号处理，使得程序在执行期间能够捕获信号并执行不同的处理逻辑</p>
</li>
<li><p>read_testcases(void)：从输入文件夹中读取所有测试样例，并进行排序。在开始的时候调用。</p>
</li>
<li><p>perform_dry_run(char** argv)：先运行一次所有的testcases，确保软件能正常工作，仅在开始的时候调用一次。</p>
</li>
<li><p>sync_fuzzers(char** argv)：用于在各个fuzzer之间同步状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Grab interesting test cases from other fuzzers. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sync_fuzzers</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  DIR* sd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">sd_ent</span>;</span></span><br><span class="line">  u32 sync_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  sd = opendir(sync_dir);</span><br><span class="line">  <span class="keyword">if</span> (!sd) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line"></span><br><span class="line">  stage_max = stage_cur = <span class="number">0</span>;</span><br><span class="line">  cur_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Look at the entries created for every other fuzzer in the sync directory. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((sd_ent = readdir(sd))) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> u8 stage_tmp[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    DIR* qd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">qd_ent</span>;</span></span><br><span class="line">    u8 *qd_path, *qd_synced_path;</span><br><span class="line">    u32 min_accept = <span class="number">0</span>, next_min_accept;</span><br><span class="line"></span><br><span class="line">    s32 id_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip dot files and our own output directory. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sd_ent-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> || !<span class="built_in">strcmp</span>(sync_id, sd_ent-&gt;d_name)) <span class="keyword">continue</span>;<span class="comment">//跳过.开头的文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip anything that doesn&#x27;t have a queue/ subdirectory. */</span></span><br><span class="line"></span><br><span class="line">    qd_path = alloc_printf(<span class="string">&quot;%s/%s/queue&quot;</span>, sync_dir, sd_ent-&gt;d_name);<span class="comment">//跳过没有queue子文件夹的目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(qd = opendir(qd_path))) &#123;</span><br><span class="line">      ck_free(qd_path);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Retrieve the ID of the last seen test case. */</span></span><br><span class="line"><span class="comment">//在自己的 out_dir/.synced 下面，打开一个以其他实例 sync_id 为名的文件</span></span><br><span class="line">    qd_synced_path = alloc_printf(<span class="string">&quot;%s/.synced/%s&quot;</span>, out_dir, sd_ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    id_fd = open(qd_synced_path, O_RDWR | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id_fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, qd_synced_path);</span><br><span class="line"><span class="comment">// 若这个文件已经存在，则它的首 4 字节表示 min_accept</span></span><br><span class="line">    <span class="keyword">if</span> (read(id_fd, &amp;min_accept, <span class="keyword">sizeof</span>(u32)) &gt; <span class="number">0</span>) </span><br><span class="line">      lseek(id_fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    next_min_accept = min_accept;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Show stats */</span>    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(stage_tmp, <span class="string">&quot;sync %u&quot;</span>, ++sync_cnt);</span><br><span class="line">    stage_name = stage_tmp;</span><br><span class="line">    stage_cur  = <span class="number">0</span>;</span><br><span class="line">    stage_max  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For every file queued by this fuzzer, parse ID and see if we have looked at</span></span><br><span class="line"><span class="comment">       it before; exec a test case if not. */</span></span><br><span class="line"><span class="comment">// 遍历用例，解析ID看是否执行过，如果没有则执行</span></span><br><span class="line">    <span class="keyword">while</span> ((qd_ent = readdir(qd))) &#123;</span><br><span class="line"></span><br><span class="line">      u8* path;</span><br><span class="line">      s32 fd;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="comment">//跳过.开头的文件，和此前执行过的（id&lt; min_accept）</span></span><br><span class="line">      <span class="keyword">if</span> (qd_ent-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> ||</span><br><span class="line">          <span class="built_in">sscanf</span>(qd_ent-&gt;d_name, CASE_PREFIX <span class="string">&quot;%06u&quot;</span>, &amp;syncing_case) != <span class="number">1</span> || </span><br><span class="line">          syncing_case &lt; min_accept) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* OK, sounds like a new one. Let&#x27;s give it a try. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (syncing_case &gt;= next_min_accept)</span><br><span class="line">        next_min_accept = syncing_case + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      path = alloc_printf(<span class="string">&quot;%s/%s&quot;</span>, qd_path, qd_ent-&gt;d_name);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Allow this to fail in case the other fuzzer is resuming or so... */</span></span><br><span class="line"></span><br><span class="line">      fd = open(path, O_RDONLY);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         ck_free(path);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fstat(fd, &amp;st)) PFATAL(<span class="string">&quot;fstat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Ignore zero-sized or oversized files. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (st.st_size &amp;&amp; st.st_size &lt;= MAX_FILE) &#123;</span><br><span class="line"></span><br><span class="line">        u8  fault;</span><br><span class="line">        u8* mem = mmap(<span class="number">0</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mem == MAP_FAILED) PFATAL(<span class="string">&quot;Unable to mmap &#x27;%s&#x27;&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* See what happens. We rely on save_if_interesting() to catch major</span></span><br><span class="line"><span class="comment">           errors and save the test case. */</span></span><br><span class="line"></span><br><span class="line">        write_to_testcase(mem, st.st_size);<span class="comment">// 写进outfile</span></span><br><span class="line"></span><br><span class="line">        fault = run_target(argv, exec_tmout);<span class="comment">// 注意 run_target 只会跑一遍程序并给 shm 分桶，不会把用例加入 queue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        syncing_party = sd_ent-&gt;d_name;</span><br><span class="line">        queued_imported += save_if_interesting(argv, mem, st.st_size, fault);<span class="comment">//保留有趣用例</span></span><br><span class="line">        syncing_party = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        munmap(mem, st.st_size);<span class="comment">//解除内存映射</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(stage_cur++ % stats_update_freq)) show_stats();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ck_free(path);</span><br><span class="line">      close(fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ck_write(id_fd, &amp;next_min_accept, <span class="keyword">sizeof</span>(u32), qd_synced_path);</span><br><span class="line"></span><br><span class="line">    close(id_fd);</span><br><span class="line">    closedir(qd);</span><br><span class="line">    ck_free(qd_path);</span><br><span class="line">    ck_free(qd_synced_path);</span><br><span class="line">    </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  closedir(sd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>calculate_score(struct queue_entry* q)：</p>
</li>
<li><p><strong>common_fuzz_stuff(char\</strong> argv, u8<em> out_buf, u32 len)：*</em>用于运行变异后的测试样例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write a modified test case, run program, process results. Handle</span></span><br><span class="line"><span class="comment">   error conditions, returning 1 if it&#x27;s time to bail out. This is</span></span><br><span class="line"><span class="comment">   a helper function for fuzz_one(). */</span></span><br><span class="line"></span><br><span class="line"><span class="function">EXP_ST u8 <span class="title">common_fuzz_stuff</span><span class="params">(<span class="keyword">char</span>** argv, u8* out_buf, u32 len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fault;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_handler) &#123;</span><br><span class="line"></span><br><span class="line">    out_buf = post_handler(out_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_to_testcase(out_buf, len);</span><br><span class="line"></span><br><span class="line">  fault = run_target(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;<span class="comment">// subseq_tmouts 自增。若超过 250，说明对这个用例的 fuzz 过于耗时，放弃 fuzz</span></span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) &#123;</span><br><span class="line"></span><br><span class="line">     skip_requested = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line"><span class="comment">// 判断是否有趣并加入队列</span></span><br><span class="line">  queued_discovered += save_if_interesting(argv, out_buf, len, fault);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><ul>
<li>一开始是一个switch-case，解析输入的各个参数</li>
<li>进行环境检查。调用setup_signal_handlers()，注册信号并调用不同处理函数；调用check_asan_opts来检查ASAN选项…</li>
<li>初始化设置，加载测试样例，设置输出文件指针，设置共享内存和比特图，检查插桩等…</li>
<li>获取参数，先将输入运行一遍以检查软件能否正常运行（perform_dry_run），修剪队列，并获取起始测试位置（是否恢复上一次的模糊测试）。然后进入循环</li>
<li>在每一轮循环中<ul>
<li>首先使用cull_queue对输入队列进行修剪</li>
<li>如果是刚开始fuzz或开启了新的一轮测试，则找到fuzz的起始点，根据是否发现新路径而调整变异策略，如果采用并行模式则使用sync_fuzzers来同步测试</li>
<li>使用fuzz_one来变异并进行测试</li>
<li>并行模式下，每处理完 5 个用例的变异，便与其他 fuzzer 同步。</li>
<li>跳到下一个模糊测试样例</li>
</ul>
</li>
<li>进行退出处理，展示模糊测试状态，杀掉forkserver和测试的进程，写入bitmap和状态温江，释放内存等。</li>
</ul>
<h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h4><p>AFL的核心函数，长达1688行，负责对testcase进行变异和测试。当成功执行测试时返回0，失败或跳过则返回1</p>
<h4 id="变异函数相关"><a href="#变异函数相关" class="headerlink" title="变异函数相关"></a>变异函数相关</h4><ul>
<li>trim_case</li>
<li>could_be_bitflip</li>
</ul>
<h3 id="afl-cmin"><a href="#afl-cmin" class="headerlink" title="afl_cmin"></a>afl_cmin</h3><p>使用afl-cmin工具能够对输入或输出的语料库进行稍微复杂但慢得多的的处理，<br> 可以精简语料库，去掉可能重复的测试用例，针对一些复杂的语料库十分有用，可大大减少无用的 fuzz 用例。产生适用于afl-fuzz或者外部工具的更小的语料库</p>
<p>afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。</p>
<h3 id="afl-tmin"><a href="#afl-tmin" class="headerlink" title="afl-tmin"></a>afl-tmin</h3><p>afl-tmin工具减小<strong>单个文件</strong>的大小，对每个文件进行更细化的处理，因为 afl 要求测试用例的大小最好小于 1KB，因此最好将精简后的用例进一步缩小体积。</p>
<h3 id="afl-gotcpu-c"><a href="#afl-gotcpu-c" class="headerlink" title="afl-gotcpu.c"></a>afl-gotcpu.c</h3><h3 id="types-h"><a href="#types-h" class="headerlink" title="types.h"></a>types.h</h3><p>负责定义数据类型，把一些数据类型用简称表示，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef uint8_t  u8;</span><br><span class="line">typedef uint16_t u16;</span><br><span class="line">typedef uint32_t u32;</span><br></pre></td></tr></table></figure>
<p>此外还定义了一些简单的函数如：MIN、MAX和SWAP16等</p>
<p>注意到一些有趣的地方，如内存屏障，强制编译器和处理器确保对内存的访问按照程序员的意图进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define MEM_BARRIER() \ </span><br><span class="line">  __asm__ volatile(&quot;&quot; ::: &quot;memory&quot;)</span><br></pre></td></tr></table></figure>
<p>还有优化语句：这里使用了GCC（GNU Compiler Collection）的内建函数 <code>__builtin_expect</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define likely(_x)   __builtin_expect(!!(_x), 1)</span><br><span class="line">#define unlikely(_x)  __builtin_expect(!!(_x), 0)</span><br></pre></td></tr></table></figure>
<p>这两个宏的目的是为了提高分支预测的准确性，从而优化代码的执行路径。</p>
<p>具体来说：</p>
<ol>
<li><strong><code>likely(_x)</code>：</strong> 这个宏表示 <code>_x</code> 在大多数情况下为真。<code>__builtin_expect(!!(_x), 1)</code> 告诉编译器，我们期望 <code>_x</code> 是真的，因此它会尝试优化真分支，使得在代码中包含 <code>_x</code> 的分支更可能被预测为“likely”（可能发生的）。</li>
<li><strong><code>unlikely(_x)</code>：</strong> 这个宏表示 <code>_x</code> 在大多数情况下为假。<code>__builtin_expect(!!(_x), 0)</code> 告诉编译器，我们期望 <code>_x</code> 是假的，因此它会尝试优化假分支，使得在代码中包含 <code>_x</code> 的分支更可能被预测为“unlikely”（不太可能发生的）。</li>
</ol>
<h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><p>配置信息</p>
<p>如每次测试的超时时间（实际还会自动缩放），内存限制….</p>
<p>如果要调整AFL运行的一些运行设置，可以从此处更改</p>
<h3 id="debug-h"><a href="#debug-h" class="headerlink" title="debug.h"></a>debug.h</h3><p>定义了用户终端文本的颜色</p>
<p>然后定义了一些输出函数，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* Just print stuff to the appropriate stream. */</span><br><span class="line"></span><br><span class="line">#ifdef MESSAGES_TO_STDOUT</span><br><span class="line">#  define SAYF(x...)    printf(x)</span><br><span class="line">#else </span><br><span class="line">#  define SAYF(x...)    fprintf(stderr, x)</span><br><span class="line">#endif /* ^MESSAGES_TO_STDOUT */</span><br><span class="line"></span><br><span class="line">/* Show a prefixed warning. */</span><br><span class="line"></span><br><span class="line">#define WARNF(x...) do &#123; \</span><br><span class="line">    SAYF(cYEL &quot;[!] &quot; cBRI &quot;WARNING: &quot; cRST x); \</span><br><span class="line">    SAYF(cRST &quot;\n&quot;); \</span><br><span class="line">  &#125; while (0)</span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269534.htm">AFL二三事 — 源码分析 1-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269536.htm">AFL二三事 — 源码分析 2-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269537.htm">AFL二三事 — 源码分析 3-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanx.net/afl-source-5/">AFL源码阅读（五）：fuzzer启动 (ruanx.net)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanx.net/afl-source-6/">AFL源码阅读（六）：队列、变异、同步 (ruanx.net)</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p><a href="http://curator-kim.github.io/2024/01/21/AFL源码阅读/">http://curator-kim.github.io/2024/01/21/AFL源码阅读/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><a href="http://Curator-Kim.github.io"><p>Curator-Kim</p></a></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-01-21</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-09-18</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># Related Post</span><br><span>  1.<a class="is-size-6" href="/2024/09/18/awesome-chatgpt-prompts/" target="_blank"> </a><br></span><span>  2.<a class="is-size-6" href="/2024/09/18/SoK%20Security%20of%20Programmable%20Logic%20Controllers/" target="_blank"> </a><br></span><span>  3.<a class="is-size-6" href="/2024/09/18/A%20Survey%20of%20Protocol%20Fuzzing/" target="_blank"> </a><br></span><span>  4.<a class="is-size-6" href="/2024/02/21/010editor%20%E7%A0%B4%E8%A7%A3%E8%AE%B0%E5%BD%95/" target="_blank"> </a><br></span><span>  5.<a class="is-size-6" href="/2024/02/07/L3HCTF%202024/" target="_blank"> </a><br></span><span>  6.<a class="is-size-6" href="/2024/01/21/%E9%99%87%E5%89%91%E6%9D%AF%202023%20Writeup/" target="_blank"> </a><br></span><span>  7.<a class="is-size-6" href="/2024/01/21/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/" target="_blank"> </a><br></span><span>  8.<a class="is-size-6" href="/2024/01/21/Universal%20Fuzzing%20via%20Large%20Language%20Models/" target="_blank"> </a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/alipay.png?raw=true" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/wechat.png?raw=true" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/01/21/%E6%98%A5%E7%A7%8B%E6%9D%AF%202024/"><i class="level-item fas fa-chevron-left"></i><span class="level-item"> </span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/"><span class="level-item">加密与解密(一)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">Comments</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'd41d8cd98f00b204e9800998ecf8427e',
            repo: 'blog_comment',
            owner: 'Curator-Kim',
            clientID: '46a9f3481b46ea0129d8',
            clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24',
            admin: ["Curator-Kim"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/22a41709ffc26f62191d72a87ffbb342d46bfce3/img/icon.jpg?raw=true" alt="Curator-Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Curator-Kim</p><p class="is-size-6 is-block">寻几处好景破星光</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>火星</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">57</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/curator-kim"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="/804242129@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"From《"+data.from+"》</p><p>Provider-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-18T07:01:03.174Z">2024-09-18</time></p><p class="title"><a href="/2024/09/18/awesome-chatgpt-prompts/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-18T06:59:04.582Z">2024-09-18</time></p><p class="title"><a href="/2024/09/18/SoK%20Security%20of%20Programmable%20Logic%20Controllers/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-18T06:58:24.805Z">2024-09-18</time></p><p class="title"><a href="/2024/09/18/A%20Survey%20of%20Protocol%20Fuzzing/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-21T11:54:21.947Z">2024-02-21</time></p><p class="title"><a href="/2024/02/21/010editor%20%E7%A0%B4%E8%A7%A3%E8%AE%B0%E5%BD%95/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-07T11:25:11.851Z">2024-02-07</time></p><p class="title"><a href="/2024/02/07/L3HCTF%202024/"> </a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2024/09/"><span class="level-start"><span class="level-item">September 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><span class="tag">汇编语言</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Crypto/"><span class="tag">Crypto</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctf/"><span class="tag">ctf</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pwn/"><span class="tag">pwn</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CopperSmith/"><span class="tag">CopperSmith</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DES/"><span class="tag">DES</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HWS/"><span class="tag">HWS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NTRU/"><span class="tag">NTRU</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RE/"><span class="tag">RE</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reverse/"><span class="tag">Reverse</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angr/"><span class="tag">angr</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"><span class="tag">加密与解密</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><span class="tag">论文阅读</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"><span class="tag">预备知识</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/logo.png?raw=true" alt="Curator-Kim的小站" height="28"></a><p class="size-small"><span>&copy; 2024 Curator-Kim</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">粤ICP备88888888号-8（测试）</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️Site from <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> has existed <strong>" + dnum + "</strong> d <strong>" + hnum + "</strong> h <strong>" + mnum + "</strong> m <strong>" + snum + "</strong> s！❤️";
        }var now = new Date();setInterval("createTime('2022/1/21 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️Thx <strong><span id="busuanzi_value_site_uv">99+</span></strong> users <strong><span id="busuanzi_value_site_pv">99+</span></strong> visited！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="137510737" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','Curator-Kim','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','Curator-Kim','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>