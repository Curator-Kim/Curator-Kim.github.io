<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Curator-Kim的小站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Curator-Kim的小站"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Curator-Kim的小站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="NothingLe3t_h3re"><meta property="og:type" content="blog"><meta property="og:title" content="Curator-Kim"><meta property="og:url" content="https://curator-kim.github.io/"><meta property="og:site_name" content="Curator-Kim"><meta property="og:description" content="NothingLe3t_h3re"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://curator-kim.github.io/img/icon.jpg"><meta property="article:author" content="Curator-Kim"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/icon.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://Curator-Kim.github.io"},"headline":"Curator-Kim的小站","image":["http://curator-kim.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Curator-Kim"},"description":"NothingLe3t_h3re"}</script><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/logo.png?raw=true" alt="Curator-Kim的小站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/album">Album</a><a class="navbar-item" href="/friend">Friend</a><a class="navbar-item" href="/message">Message</a><a class="navbar-item" href="/self-talking">Self-talking</a><a class="navbar-item" href="/music">Music</a><a class="navbar-item" href="/media">Media</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-08-03  <a class="commentCountImg" href="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/#comment-container"><span class="display-none-class">5c9d6ba5f39efe3f4506d4ec545e3d8b</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="5c9d6ba5f39efe3f4506d4ec545e3d8b">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>23 m  <i class="fas fa-pencil-alt"> </i>3.5 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/">加密与解密(一)</a></h1><div class="content"><span id="more"></span>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h2><h3 id="1-3-Windows操作系统"><a href="#1-3-Windows操作系统" class="headerlink" title="1.3 Windows操作系统"></a>1.3 Windows操作系统</h3><h4 id="1-3-2-WOW64"><a href="#1-3-2-WOW64" class="headerlink" title="1.3.2 WOW64"></a>1.3.2 WOW64</h4><p>WOW64(Windows-on-Windows 64-bit)是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上</p>
<h4 id="1-3-3-Windows消息机制"><a href="#1-3-3-Windows消息机制" class="headerlink" title="1.3.3 Windows消息机制"></a>1.3.3 Windows消息机制</h4><p>Windows系统中有两种消息队列：一种是系统消息队列；另一种是应用程序消息队列。当一个消息发生时，Windows先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在他的消息对队列中检索每个消息并发送给相应的窗口函数。</p>
<h4 id="1-3-4虚拟内存"><a href="#1-3-4虚拟内存" class="headerlink" title="1.3.4虚拟内存"></a>1.3.4虚拟内存</h4><img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20220705212424246.png" class title="image-20220705212424246">
<h1 id="调试篇"><a href="#调试篇" class="headerlink" title="调试篇"></a>调试篇</h1><h2 id="第二章-动态分析技术"><a href="#第二章-动态分析技术" class="headerlink" title="第二章 动态分析技术"></a>第二章 动态分析技术</h2><h3 id="2-1-Ollydbg"><a href="#2-1-Ollydbg" class="headerlink" title="2.1 Ollydbg"></a>2.1 Ollydbg</h3><h4 id="2-1-4-常用断点"><a href="#2-1-4-常用断点" class="headerlink" title="2.1.4 常用断点"></a>2.1.4 常用断点</h4><ol>
<li>INT 3 断点</li>
</ol>
<p><strong>原理</strong>：在对应地址处使用INT 3指令替换原指令，当执行到此处时触发异常，被调试器检测到从而停止运行，并把原指令恢复。</p>
<p><strong>反调试</strong>：检测API首地址是否为0xCC</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20220710204027706.png" class title="image-20220710204027706">
<blockquote>
<p>函数功能：检索指定的动态链接库(DLL)中的输出库函数地址 原型：</p>
<p>FARPROC GetProcAddress(</p>
<p>HMODULE hModule, // DLL模块句柄</p>
<p>LPCSTR lpProcName // 函数名</p>
<p>);</p>
</blockquote>
<p><strong>反反调试</strong>：将断点设在函数内部或末尾</p>
<ol>
<li>硬件断点</li>
</ol>
<p>硬件断点和DRx调试寄存器有关</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20220710205703275.png" class title="image-20220710205703275">
<p>DRx调试寄存器共有8个(DR0~DR7)，每个寄存器特性如下</p>
<ul>
<li>DR0~DR3：调试地址寄存器，用于保存需要监视的地址</li>
<li>DR4~DR5：保留，未公开具体作用</li>
<li>DR6：调试寄存器组状态寄存器</li>
<li>DR7：调试寄存器组控制寄存器</li>
</ul>
<p>硬件断点的原理是使用DR0、DR1、DR0、DR3设定地址，并使用DR7设定状态，因此最多设置4个断点，硬件执行断点与CC断点作用一样，但因为硬件执行断点不会将指令首字节修改为”CC”，所以更难检测。</p>
<ol>
<li>内存断点</li>
</ol>
<p>Ollydbg可以设置内存访问断点或内存写入断点，原理是对所设的地址赋予不可访问/不可写属性，这样当访问/写入的时候就会产生异常。Ollydbg截获异常后，比较异常地址是不是断点地址，如果是就中断，让用户继续操作。</p>
<ol>
<li>内存访问一次性断点</li>
</ol>
<p>Windows对内存采用段页式的管理方式。在Ollydbg上可对整个内存块设置该类断点，当所在段被读取或执行时就会中断。如果想捕捉调用或返回某个模块，该类断点就特别有用。该类断点仅在NT架构在可用</p>
<ol>
<li>消息断点</li>
</ol>
<p>Windows本身是由消息驱动的，如果调试时没有合适的断点，可以尝试使用消息断点。当某个特定窗口函数接收到某个特定消息时，消息断点将使得程序中断</p>
<ol>
<li>条件断点</li>
</ol>
<p>条件断点即断点在满足一定条件时才会中断。Ollydbg的条件断点可以按寄存器、存储器、消息等设断。条件断点是一个带有条件表达式的普通INT 3断点。当调试器遇到此类断点时，将计算表达式的值，如果结果非零或表达式有效，则断点生效。</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20220712214333756.png" class title="image-20220712214333756">
<ol>
<li>条件记录断点</li>
</ol>
<h2 id="第三章-静态分析技术"><a href="#第三章-静态分析技术" class="headerlink" title="第三章 静态分析技术"></a>第三章 静态分析技术</h2><h3 id="3-1-文件类型分析"><a href="#3-1-文件类型分析" class="headerlink" title="3.1 文件类型分析"></a>3.1 文件类型分析</h3><p>PeEiD利用特征串搜索完成识别。</p>
<h3 id="3-2-反汇编引擎"><a href="#3-2-反汇编引擎" class="headerlink" title="3.2 反汇编引擎"></a>3.2 反汇编引擎</h3><ul>
<li>ODDisasm. OllyDbg自带，但已经落后了，对一些指令集的支持不太好</li>
<li>BeaEngine</li>
<li>Udis86</li>
<li>Capstone. 集大成者，移植自LLVM</li>
<li>AsmJit</li>
<li>Keysone</li>
</ul>
<h1 id="解密篇"><a href="#解密篇" class="headerlink" title="解密篇"></a>解密篇</h1><h2 id="第四章-逆向分析技术"><a href="#第四章-逆向分析技术" class="headerlink" title="第四章 逆向分析技术"></a>第四章 逆向分析技术</h2><h3 id="4-1-32位软件逆向技术"><a href="#4-1-32位软件逆向技术" class="headerlink" title="4.1 32位软件逆向技术"></a>4.1 32位软件逆向技术</h3><h4 id="4-1-1-启动函数"><a href="#4-1-1-启动函数" class="headerlink" title="4.1.1 启动函数"></a>4.1.1 启动函数</h4><p>Windows程序首先被执行的是启动函数的相关代码，由编译器生成。对Visual C++程序来说，他调用的是C/C++运行时启动函数，负责对C/C++运行库进行初始化。可以在crt/src/crt0.c文件中找到启动函数的源代码。</p>
<p>所有C/C++程序运行时，启动函数的作用基本相同：检索指向新进程的命令行指针、检索指向新进程的环境变量指针、全局变量初始化、内存栈初始化…</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230702004041311.png" class title="image-20230702004041311">
<p>有个Visual C++编译程序的启动代码的汇编代码：</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230702004427763.png" class title="image-20230702004427763">
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230702004435528.png" class title="image-20230702004435528">
<h4 id="4-1-2-函数"><a href="#4-1-2-函数" class="headerlink" title="4.1.2 函数"></a>4.1.2 函数</h4><ol>
<li><p>函数的参数</p>
<ul>
<li><p>利用栈传递参数</p>
<p>调用函数时，将参数依次压入栈，然后调用函数。函数被调用后，从栈中取出数据。</p>
<p>两个重要问题：参数传递顺序，谁平衡栈？</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230702005136081.png" class title="image-20230702005136081">
<p>假设有调用函数test1(Par1,Par2.Par3)，汇编代码如下所示</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230702010029627.png" class title="image-20230702010029627">
<p>栈过程</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230704003321573.png" class title="image-20230704003321573">
<p>or</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230704003407700.png" class title="image-20230704003407700">
<p>编译器优化时，情况有所不同。如VC 6.0的Maxizmize Speed编译，会节省ebp寄存器，直接通过esp对参数进行寻址</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230704003801727.png" class title="image-20230704003801727">
</li>
<li><p>寄存器传参</p>
<p>Fastcall调用规定。参数先放在寄存器，不够再放栈里面</p>
<p>thiscall调用规定，是C++中非静态类成员函数的默认调用约定，对象的每个函数隐含接收this参数。采用thiscall约定时，函数的参数按照从右到左的顺序入栈，被调用的函数在返回前清理传送参数的栈，仅通过ecx寄存器传送一个额外的参数——this指针</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230704004511028.png" class title="image-20230704004511028">
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230704004548134.png" class title="image-20230704004548134">
</li>
<li><p>名称修饰约定</p>
<p>为了允许使用操作符和函数重载，C++编译器会按照某种规则改写每一个入口点的函数名。从而运行同一个名字(具有不同参数类型或参数域)有多个用法且不会破坏现有的基于C的链接器。</p>
<p>C编译函数名修饰约定：</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230712213753089.png" class title="image-20230712213753089">
<p>C++编译函数名修饰约定规则：</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230712213842956.png" class title="image-20230712213842956">
</li>
</ul>
</li>
<li><p>函数的返回值</p>
<ul>
<li>用return操作符返回值</li>
<li>通过参数按传引用方式返回值</li>
</ul>
</li>
</ol>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li><p>局部变量</p>
<ul>
<li><p>利用栈存放局部变量</p>
<p>sub esp,8为局部变量分配变量。用[ebp-xxx]寻址调用变量，[ebp+xxx]调用参数。但在编译器优化模式时，通过esp寄存器直接对局部变量和参数进行参数。函数退出时，用add esp,8平衡栈。另外，编译器可能用push reg取代sub esp,4，节省几个字节空间</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230712215740057.png" class title="image-20230712215740057">
</li>
<li><p>全局变量</p>
<p>位于.data段固定地址处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr [4084c0h]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组</p>
<p>数组一般是通过基址加变址寻址实现的</p>
</li>
</ul>
</li>
</ol>
<h4 id="4-1-4-虚函数"><a href="#4-1-4-虚函数" class="headerlink" title="4.1.4 虚函数"></a>4.1.4 虚函数</h4><p>虚函数是在程序运行时定义的函数。虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的引用都放在一个专用数组——虚函数表(VTBL)，数组的每个元素中存放的就是类中虚函数的地址。调用虚函数时，程序先取出虚函数表指针(Virtual Table Pointer, VPTR)，得到虚函数表的地址，再根据这个地址到虚函数表中取出该函数的地址，最后调用该函数</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230720100454294.png" class title="image-20230720100454294">
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230720101109458.png" class title="image-20230720101109458">
<h4 id="4-1-5-控制语句"><a href="#4-1-5-控制语句" class="headerlink" title="4.1.5 控制语句"></a>4.1.5 控制语句</h4><ol>
<li><p>IF-THEN-ELSE</p>
</li>
<li><p>SWITCH-CASE</p>
</li>
<li><p>转移指令机器码的计算</p>
<p>根据转移距离的不同，转移指令有如下类型</p>
<ul>
<li>短转移</li>
<li>长转移</li>
<li>子程序调用指令</li>
</ul>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230720102826363.png" class title="image-20230720102826363">
</li>
<li><p>条件设置指令(SETcc)</p>
<p>条件设置指令的形式是 “SETcc r/m8”，其中”r/m8”表示8位寄存器或单字节内存单元。</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230720104956601.png" class title="image-20230720104956601">
</li>
<li><p>纯算法实现逻辑判断</p>
<p>使用数学技巧将逻辑分支转换成算术操作，减少条件转移指令</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230720105807285.png" class title="image-20230720105807285">
</li>
</ol>
<h4 id="4-1-6-循环语句"><a href="#4-1-6-循环语句" class="headerlink" title="4.1.6 循环语句"></a>4.1.6 循环语句</h4><h4 id="4-1-7-数学运算符"><a href="#4-1-7-数学运算符" class="headerlink" title="4.1.7 数学运算符"></a>4.1.7 数学运算符</h4><p>主要介绍经编译器优化的运算符</p>
<ol>
<li><p>整数加减法</p>
<p>编译优化时，lea指令代替add和sub指令。lea指令允许用户在一个时钟周期内完成对c=a+b+78h的计算，其中a、b与c都是在有寄存器的情况下才有效</p>
<p>以下代码lea指令实际等价于edx=ecx+eax+78h</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230731003825776.png" class title="image-20230731003825776">
</li>
<li><p>整数的乘法</p>
<p>mul、imul -&gt; shl与加法结合，如：</p>
<p>eax<em>5 写成 lea eax,[4\</em>eax]</p>
</li>
<li><p>整数除法</p>
<p>如果被除数是一个未知数，则使用div指令</p>
<p>如果被除数是一个常量，情况则较复杂，例如计算a/11</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230731010242911.png" class title="image-20230731010242911">
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230731010255208.png" class title="image-20230731010255208">
</li>
</ol>
<h4 id="4-1-8-文本字符串"><a href="#4-1-8-文本字符串" class="headerlink" title="4.1.8 文本字符串"></a>4.1.8 文本字符串</h4><ol>
<li><p>字符串存储格式 略</p>
</li>
<li><p>字符寻址指令</p>
<p>mov与lea</p>
</li>
<li><p>字母大小写转换</p>
</li>
<li><p>计算字符串的长度</p>
<p>strlen()函数在优化编译模式下的汇编代码：</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230801002051093.png" class title="image-20230801002051093">
<p><strong>scasb</strong>指令：SCAN String Byte 的缩写，具体操作计算 AL - byte of [ES:EDI] , 设置相应的标志寄存器的值；修改寄存器EDI的值：如果标志DF为0，则 inc EDI；如果DF为1，则 dec EDI。SCASB指令常与循环指令REPZ/REPNZ合用。例如，REPNZ SCASB 语句表示当 寄存器ECX&gt;0 且 标志寄存器ZF=0，则再执行一次SCASB指令。</p>
<p>比较寄存器AL的值不相等则重复查找的字</p>
<p><strong>repnz</strong>指令：重复执行其后面的指令，CX或ECX存放最多比较次数，DI或EDI存放查找表首地址，AL或AX或EAX存放想查找的内容。当(CX或ECX)= 0 或 ZF=1 退出重复，否则，(CX或ECX)自减一，执行其后的串指令。CX或ECX为0结束是因为已经查表完毕，没有匹配到；ZF=1说明 “比较的结果为0”，也就是查找到一样的内容，说明匹配到想要查找的内容</p>
</li>
</ol>
<h4 id="4-1-9-指令修改技巧"><a href="#4-1-9-指令修改技巧" class="headerlink" title="4.1.9 指令修改技巧"></a>4.1.9 指令修改技巧</h4><h3 id="4-2-64位软件逆向技术"><a href="#4-2-64位软件逆向技术" class="headerlink" title="4.2 64位软件逆向技术"></a>4.2 64位软件逆向技术</h3><h4 id="4-2-1-寄存器"><a href="#4-2-1-寄存器" class="headerlink" title="4.2.1 寄存器"></a>4.2.1 寄存器</h4><img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230801003915036.png" class title="image-20230801003915036">
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230801003922069.png" class title="image-20230801003922069">
<h4 id="4-2-2-函数"><a href="#4-2-2-函数" class="headerlink" title="4.2.2 函数"></a>4.2.2 函数</h4><ol>
<li><p>栈平衡</p>
<p>当函数调用完成时，需要释放所申请的空间，保证栈顶和函数调用前位置一致。需要注意，x64环境下，某些汇编指令对栈顶的对齐值有要求，因此Visual Studio编译器在申请栈空间时，会尽量保证栈顶地址的对齐值为16</p>
</li>
<li><p>启动函数</p>
</li>
<li><p>调用约定</p>
<p>x64只有一种寄存器快速调用约定。前四个参数依次使用寄存器RCX、RDX、R8、R9传递，多余的参数放入栈中，入栈顺序从右到左，由函数调用方平衡栈空间。任何大于8字节或者不是1字节、2字节、4字节、8字节的参数必须由引用来传递(地址传递)。所有浮点参数的传递都是使用XMM寄存器完成的，他们在XMM0、XMM1、XMM2和XMM3中传递</p>
<blockquote>
<p>注：System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</p>
</blockquote>
<p>函数前4个参数虽然使用寄存器传递，但栈仍然为这四个参数预留了空间(32字节)，称之为预留栈空间，避免函数较复杂导致寄存器不够用的问题。预留栈空间由函数调用者提前申请。由函数调用者负责平衡栈空间。</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230801005501526.png" class title="image-20230801005501526">
</li>
<li><p>参数传递</p>
<p>(3)参数为结构体</p>
<p>如果参数为结构体且结构体小于8字节，在传递结构体参数时，应直接把整个结构体的内容放在寄存器中。在函数里，通过访问寄存器的高32位和低32位来分别访问结构体成员。</p>
<p>如果结构体大于8字节，在传递参数时，先把结构内容复制到栈空间中，再把结构体地址当成函数参数来传递(引用传递)。在函数内部通过”结构体+偏移“方式访问结构体内容</p>
<p>(4)thiscall传递</p>
<p>VC++环境下，c++类的成员函数调用约定</p>
<p>唯一区别：结构体成员函数调用会隐含传递一个this指针</p>
</li>
</ol>
<h4 id="4-2-3-数据结构"><a href="#4-2-3-数据结构" class="headerlink" title="4.2.3 数据结构"></a>4.2.3 数据结构</h4><ol>
<li><p>局部变量</p>
</li>
<li><p>全局变量</p>
<p>先定义的在低地址，后定义的在高地址</p>
</li>
<li><p>数组</p>
</li>
</ol>
<h4 id="4-2-4-控制语句"><a href="#4-2-4-控制语句" class="headerlink" title="4.2.4 控制语句"></a>4.2.4 控制语句</h4><ol>
<li><p>switch case语句</p>
<p>当case&gt;=6，且case值的间隔比较小时，编译器会采用case表的方式实现switch语句</p>
<p>小于6时直接使用if…else语句实现</p>
</li>
<li><p>转移指令机器码的计算</p>
<p>(1) call/jmp direct</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230803010247398.png" class title="image-20230803010247398">
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230803010252842.png" class title="image-20230803010252842">
<p>(2) call/jmp memory direct</p>
<img src="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/image-20230803010312525.png" class title="image-20230803010312525">
</li>
</ol>
<h4 id="4-2-5循环语句"><a href="#4-2-5循环语句" class="headerlink" title="4.2.5循环语句"></a>4.2.5循环语句</h4></div><div class="index-category-tag">  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/">加密与解密</a></div><hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-08-03  <a class="commentCountImg" href="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 h  <i class="fas fa-pencil-alt"> </i>21.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/"> </a></h1><div class="content"><h1 id="A-Survey-of-Symbolic-Execution-Techniques"><a href="#A-Survey-of-Symbolic-Execution-Techniques" class="headerlink" title="A Survey of Symbolic Execution Techniques"></a>A Survey of Symbolic Execution Techniques</h1><h2 id="Introduction，"><a href="#Introduction，" class="headerlink" title="Introduction，"></a>Introduction，</h2><p>符号执行——程序分析技术，测试软件是否会违反某种规则，例如除零、引用不存在的指针、后门…</p>
<p>关键思想：允许程序采用符号输入值，而非具体输入值。执行由符号执行引擎完成，该引擎维护每条已探索的控制流路径：(i)一阶布尔公式，用于描述沿该路径执行的分支所满足的条件；(ii)符号存储，用于将变量映射为符号表达式或值。分支执行更新公式，而赋值更新符号存储  |  模型检查器通常基于可满足性模态理论（SMT）求解器，最终用于验证每条探索路径是否存在违反属性的情况，以及路径本身是否可实现，即其公式是否可以通过对程序符号参数的具体值赋值来满足。(即条件方程是否有具体解？)</p>
<h3 id="1-1-A-Warm-Up-Example"><a href="#1-1-A-Warm-Up-Example" class="headerlink" title="1.1 A Warm-Up Example"></a>1.1 A Warm-Up Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(a != <span class="number">0</span>)&#123;</span><br><span class="line">		y=<span class="number">3</span>+x;</span><br><span class="line">		<span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">			x = <span class="number">2</span>*(a+b);</span><br><span class="line">	&#125;</span><br><span class="line">	assert(x - y != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单纯随机生成的输入难以让assert断言失败，但通过符号执行可以获取满足这一要求的输入类</p>
<p>更具体地说，每一个变量(如函数参数、系统调用的返回值)都被符号如$\alpha$所代替</p>
<p>在任何时刻，符号执行引擎保持状态$(stmt,\sigma,\pi)$</p>
<ul>
<li>stmt 是下一个要评估的语句(指令？)，目前可假设stmt是赋值、条件分支或跳转(call 和 loops等更复杂的在下节讨论)</li>
<li>$\sigma$是一个符号存储，将程序变量与具体值上的表达式或符号值$\alpha_i$相关联</li>
<li>$\pi$表示路径约束，即要到达stmt的分支$\alpha_i$所要满足的一组假设。在分析开始时，$\pi$=true</li>
</ul>
<p>根据stmt，符号引擎按以下改变状态</p>
<ul>
<li>x=e的复制会通过将x与符号表达$e_s$更新内存$\sigma$.使用$x→e_s$记这种关联，其中$e_s$通过当前上下文的表达式得到，可以是涉及符号或具体值的一元/二元运算符</li>
<li>条件语句if会影响路径约束$\pi$，此时会创建两个条件执行，分别为$\pi_{true}$和$\pi_{false}$，分别对应分支$\pi_{true}=\pi \and e_s$和$\pi_{false}=\pi \and \neg e_s$。符号执行在这两个状态下分别进行。（路径爆炸</li>
<li>跳转语句 goto s会通过将符号执行推进到语句s更新执行状态</li>
</ul>
<p>foobar函数的符号执行过程，可以等效地表示为一棵树，初始化为true，输入参数与符号值相联系。在第2行初始化x和y后，符号存储会分别将x与1,y与0联系。第三行包括一个条件语句，这会克隆执行，接下来在不同的分支会依据符号$\alpha_a$执行不同语句(C/D)在$\alpha_a\not = 0$,y被赋值x+3，并在E处获取y=4,因为在C中x=1。总之，算式会被符号值简单计算。在扩展所有执行状态直到assert语句后，可以检查输入参数a、b是否能让assert断言失败。通过分析状态D、G、G，我们发现只有H能让x-y=0。实际上，类似下式的输入都会令assert失败。具体例子可以通过SMT solver求解</p>
<script type="math/tex; mode=display">
2(\alpha_a+\alpha_b)-4=0\and \alpha_a \not=0\and\alpha_b=0</script><img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230712004756091.png" class title="image-20230712004756091">
<h3 id="1-2-Challenges-in-Symbolic-Execution"><a href="#1-2-Challenges-in-Symbolic-Execution" class="headerlink" title="1.2 Challenges in Symbolic Execution"></a>1.2 Challenges in Symbolic Execution</h3><ul>
<li>内存：怎么handle指针、数组还有比较复杂的对象，代码执行指针和数据结构不仅影响符号所存储的数据，还有符号表达式所指向的地址</li>
<li>环境：引擎怎么handle软件栈的交互？系统代码和库调用会带来副作用，例如文件创建或用户代码回调，这些都会影响后面的执行。然而评估可能的交互结果是不可行的</li>
<li>状态空间爆炸（路径爆炸）：loop语句可能会带来爆炸的状态空间，不可能在合理的时间内将其处理完</li>
<li>约束求解：SMT solver可以扩展到数百个复杂变量的组合约束，但处理非线性运算将会影响效率。</li>
</ul>
<h3 id="1-3-Related-Work"><a href="#1-3-Related-Work" class="headerlink" title="1.3 Related Work"></a>1.3 Related Work</h3><h2 id="2-SYMBOLIC-EXECUTION-ENGINES"><a href="#2-SYMBOLIC-EXECUTION-ENGINES" class="headerlink" title="2 SYMBOLIC EXECUTION ENGINES"></a>2 SYMBOLIC EXECUTION ENGINES</h2><p>介绍符号执行引擎的设计原则，介绍concolic execution（混合执行symbolic execution + concrete execution）</p>
<h3 id="2-1-Mixing-Symbolic-and-Concrete-Execution"><a href="#2-1-Mixing-Symbolic-and-Concrete-Execution" class="headerlink" title="2.1 Mixing Symbolic and Concrete Execution"></a>2.1 Mixing Symbolic and Concrete Execution</h3><p>经典符号执行引擎的一个主要限制是不能探索无法求解路径约束的执行路径。完整性的缺失源自执行器无法跟踪的外部代码，还有源自复杂运算例如非线性计算和先验函数。此外，实际程序通常不是自包含的：在执行过程中难以评估任何可能的副作用，要准确静态分析整个软件的堆栈很困难。解决这些问题的一个方法就是concolic执行：将符号执行与具体执行混合</p>
<p><strong>动态符号执行(Dynamic Symbolic Execution, DSE)：</strong>除了符号存储和路径约束，执行引擎会维护一个具体存储$\sigma_c$。在选择任意输入开始后，它会同时更新$\sigma_c $和$\sigma$。当具体执行执行某一分支时，符号执行会执行同一分支，并且从分支条件中提取的约束将添加到当前路径约束集。简而言之，符号执行是由特定的具体执行驱动的。因此，符号引擎不需要调用约束求解器来判断哪个分支状态是否被满足：这由具体执行直接测试。为了探索不同的路径，可以否定由一个或多个分支给出的路径条件，并调用SMT求解器来生成新的输入</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230721181522403.png" class title="image-20230721181522403">
<p>尽管DSE使用具体的输入来将符号执行推向特定的路径，但每当必须探索新路径时，它仍然需要选择一个分支来否定。要注意的是，每次具体执行都可能会增加必须访问的新分支，由于在所有已执行的具体执行中，未被访问的分支集合可能非常庞大，因此采用有效的搜索启发式（第 2.2 节）可以起到至关重要的作用。由于只探索了部分状态空间，初始输入对整个方法的有效性起着至关重要的作用，与黑盒模糊测试类似。</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113719498.png" class title="image-20230723113719498">
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113726255.png" class title="image-20230723113726255">
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113733535.png" class title="image-20230723113733535">
<p>如以上示例所示，假阴性(即遗漏路径)和路径分歧是动态符号执行的显著缺点。DSE以健全性换取性能和执行难度，由于程序执行会被遗漏，导致假阴性的存在，外部调用、异常、类型转换和符号指针导致路径偏移，需要谨慎处理。</p>
<p><strong>Selective Symbolic Execution：</strong>SSE采用了一种不同的方法来混合符号和具体执行，只全面探索软件栈的部分组件，而不关心其他组件。</p>
<p>假设函数A调用函数B，执行模式在调用处发生变化。会出现两种情况：</p>
<p>(1)从具体到符号再返回：B的参数被符号化，B被全部符号化。B也以具体方式执行，其具体结果返回给A</p>
<p>(2)从符号到具体再返回：B的参数被具体化，B被具体执行，然后在A中恢复符号执行。这可能会影响分析的合理性和完整性：</p>
<p>(i)为确保符号执行跳过任何因执行具体化而无法实现的路径（可能导致误报），SSE 收集了路径约束，以跟踪参数如何被具体化、B 产生了哪些副作用以及它产生了哪些返回值。</p>
<p>(ii)具体化可能导致 A 恢复后错过分支（可能导致假否定）。为了解决这个问题，收集到的约束被标记为软约束：只要返回 A 后的分支因软约束而无法执行，执行就会回溯，并尝试为 B 选择不同的参数。为了引导 B 的参数重新具体化，S2E 还会收集 B 具体执行过程中的分支条件，并选择具体值，以便在 B 中实现不同的具体执行路径。</p>
<h3 id="2-2-Path-Selection"><a href="#2-2-Path-Selection" class="headerlink" title="2.2 Path Selection"></a>2.2 Path Selection</h3><p>本节介绍路径选择策略：枚举所有路径花销太高，需要选择更有希望的路径</p>
<p><em>Depth-first search</em>(DFS)和<em>breadth-first search</em>（BFS）是最常用的策略，前者是在回溯到最深的未探索分支之前尽可能扩展路径，后者是并行扩展所有路径。当内存使用率较高时，DFS 通常会被采用，但包含循环和递归调用的路径会阻碍 DFS 的使用。因此，尽管内存压力较大，而且完成特定路径的探索需要较长的时间，一些工具还是会采用 BFS，它允许引擎快速探索不同的路径，及早发现有趣的行为。另一种流行的策略是random path selection，它已被改进为多种变体。例如，KLEE [20] 根据路径的长度和分支的弧度为路径分配概率： 它更青睐探索次数较少的路径，从而避免了循环和其他路径爆炸因素造成的饥饿。</p>
<p>另外一些旨在最大化代码覆盖率的启发式算法：KLEE中讨论的<strong>覆盖率优化搜索</strong>会为每个状态计算一个权重，然后用它来随机选择状态。权重是通过考虑最近的未覆盖指令的距离、该状态是否覆盖了新代码以及该状态的调用堆栈来获得的；<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/2509136.2509553">Li You</a>等提出的<strong>子路径引导搜索</strong>，试图通过选择控制流图中被探索次数较少的子路径来探索程序中被探索次数较少的部分。“这是通过保持已探索子路径的频率分布来实现的，其中子路径被定义为完整路径上长度为 n 的连续子序列。有趣的是，n 值对使用这种启发式的符号引擎所实现的代码覆盖率起着至关重要的作用，而且没有任何特定值被证明是普遍最优的。”；<strong>最短距离符号执行</strong>并不以覆盖率为目标，而是旨在识别程序中特定点执行的程序输入。然而，与基于覆盖率的策略一样，启发式也是以评估到目标点的最短距离为基础的。计算公式为程序间控制流图中最短路径的长度，引擎会优先处理距离最短的路径。</p>
<p>其他一些搜索启发式方法则试图优先选择可能通往某些目标所关注状态的路径。例如，AEG [8] 引入了两种这样的策略。<strong>错误路径优先策略</strong>选择那些过去状态包含小错误但无法利用的路径。我们的直觉是，如果一条路径包含一些小错误，那么它很可能没有经过适当的测试。因此，未来的状态很有可能包含有趣的、有望被利用的错误。同样，<strong>循环穷举策略</strong>也会探索访问循环的路径。这种方法的灵感来自于一个实际观察结果，即循环中常见的编程错误可能会导致缓冲区溢出或其他与内存相关的错误。为了找到可利用的错误，Mayhem [25] 优先考虑识别到内存访问符号地址或检测到符号指令指针的路径。</p>
<p>参考文献[118]提出了一种新颖的动态符号执行方法，用于自动查找满足规则属性的程序路径，即可以用有限状态机（FSM）表示的属性（如文件使用或内存安全）。动态符号执行由 FSM 引导，因此执行路径中最有可能满足该属性的分支会首先被探索。这种方法利用静态和动态分析来计算要选择探索的路径的优先级：在符号执行过程中，动态地计算当前执行路径已经达到的 FSM 状态，同时使用后向数据流分析静态地计算未来状态。如果这两个集合的交集是非空的，那么很可能有一条路径满足属性要求。</p>
<p>适度函数主要用于基于搜索的测试生成，衡量探索的路径与实现目标测试覆盖率的接近程度。参考文献 [112] 介绍了 fitnex，这是一种在concolic执行中翻转分支的策略，它优先考虑可能更接近特定分支的路径。更详细地说，给定一个目标分支，其相关条件的形式为  $|a-c|==0$，通过利用路径中变量 a 和 c 的具体值，计算出路径的接近度为 $|a-c|$。对于其他类型的分支条件，也可以计算类似的合适度值。符号引擎会选择某个分支拟合度值最低的路径。尚未到达分支的路径将获得最差的适配值。</p>
<h3 id="2-3-Symbolic-Backward-Execution"><a href="#2-3-Symbolic-Backward-Execution" class="headerlink" title="2.3 Symbolic Backward Execution"></a>2.3 Symbolic Backward Execution</h3><p><strong>符号逆向执行(Symbolic backward execution (SBE))</strong>是符号执行的一种变体，从程序的目标点开始探索到入口点，因此是反向进行分析。这种方法的主要目的通常是确定一个可以触发执行特定代码行（如断言或抛出语句）的测试输入实例。这对开发人员进行程序调试或回归测试非常有用。由于探索是从目标开始的，因此会沿着遍历过程中遇到的分支收集路径约束。SBE 引擎可以同时探索多条路径，而且与前向符号执行类似，会定期检查路径的可行性。当路径条件被证明不可行时，引擎会丢弃路径并返回。</p>
<p>SBE的一种变体 <strong>call-chain backward symbolic execution (CCBSE)</strong>，该技术首先要确定目标行所在函数的有效路径。找到路径后，引擎会移动到包含目标点的函数的调用者之一，并尝试重建从调用者入口点到目标点的有效路径。这个过程会递归重复，直到从程序的主函数重建出一条有效路径为止。与传统 SBE 的主要区别在于，虽然 CCBSE 从目标点向后跟踪调用链，但在每个函数内部的探索都与传统的符号执行一样。</p>
<p>在 SBE 和 CCBSE 中，逆向探索的一个关键要求是程序间控制流图的可用性，它提供了整个程序的控制流，并使确定探索所涉及的函数的调用点成为可能。遗憾的是，在实践中构建这样一个图可能相当具有挑战性。此外，一个函数可能有许多可能的调用点，这使得 SBE 的探索成本仍然很高。另一方面，在反向收集约束条件时，也会产生一些实际优势。我们将在第 6 节中进一步讨论这些优势。</p>
<h3 id="2-4-Design-Principles-of-Symbolic-Executors"><a href="#2-4-Design-Principles-of-Symbolic-Executors" class="headerlink" title="2.4 Design Principles of Symbolic Executors"></a>2.4 Design Principles of Symbolic Executors</h3><ul>
<li>Progress.执行器应能在不超出给定资源的情况下任意长时间地运行。由于可能存在大量不同的控制流路径，内存消耗尤为重要。</li>
<li>Work repetition. 不应重复执行工作，避免从一开始就多次重启程序，分析可能具有共同前缀的不同路径。</li>
<li>应尽可能重复使用以前运行的分析结果。特别是，应避免对先前已解决的路径约束条件进行代价高昂的 SMT 求解器调用。</li>
</ul>
<p>不同符号引擎在运行时间/内存、性能和完整性之前作出不同权衡。</p>
<p>在线执行器：在一次运行中同时执行多条路径，在每个依赖输入的分支上克隆执行状态。KLEE、AEG 和 S2E中都有这样的例子。这些引擎从不重新执行以前的指令，从而避免了工作重复。然而，许多活动状态需要保留在内存中，内存消耗可能会很大，从而可能阻碍进程。减少内存占用的有效技术包括 “写时拷贝 “技术，该技术试图在不同状态之间尽可能多地共享内存[20]。另一个问题是，并行执行多条路径需要确保执行状态之间的隔离，例如，通过模拟系统调用的效果来保持操作系统的不同状态。</p>
<p>离线执行器：在符号执行中，一次只对一条路径进行推理。与在线执行器相比，独立运行每条路径的内存消耗较低，而且可以立即重复使用之前运行的分析结果。另一方面，由于每次运行通常都会从头开始重新启动程序的执行，因此大部分工作都会重复。在离线执行器的典型实现中，运行是具体的，需要输入种子，首先具体执行程序，记录指令轨迹，记录轨迹会被符号化执行。</p>
<p>混合执行器：（如 Mayhem [25]）试图在速度和内存需求之间取得平衡：它们以在线模式启动，当内存使用量或并发活动状态的数量达到阈值时，会生成检查点，而不是分叉新的执行器。检查点维护符号执行状态和重放信息。当选中一个检查点进行恢复时，就会从恢复后的具体状态重新开始在线探索。</p>
<h2 id="3-MEMORY-MODEL"><a href="#3-MEMORY-MODEL" class="headerlink" title="3 MEMORY MODEL"></a>3 MEMORY MODEL</h2><p>符号执行的一个重要方面是如何建立内存模型，以支持带有指针和数组的程序。对内存地址建模的存储空间 σ 可以看作是将内存地址（索引）与具体值表达式或符号值相关联的映射。写$x\rarr e$表示变量x和表达式e时，我们指的是$\&amp;x\rarr e$，&amp;x是x的具体地址，$v[c]\rarr e$表示$\&amp;v+c\rarr e$</p>
<p>内存模型是符号引擎的一个重要设计选择，因为它能显著影响探索的覆盖率和约束求解的可扩展性。当操作中引用的地址是一个符号表达式时，就会出现符号内存地址问题。</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230724111514733.png" class title="image-20230724111514733">
<h3 id="3-1-Fully-Symbolic-Memory"><a href="#3-1-Fully-Symbolic-Memory" class="headerlink" title="3.1 Fully Symbolic Memory"></a>3.1 Fully Symbolic Memory</h3><p>At the highest level of generality，引擎将所有地址符号化。大量的工作都采用了这种方法，King在一篇开创性文章中首创以下两种基本方法</p>
<ul>
<li><p>State Forking.如果一个操作从一个符号地址读取数据或向一个符号地址写入数据，那么就会考虑该操作可能产生的所有状态，对该状态进行分叉。每个分叉状态的路径约束都会相应更新。</p>
<p>例如图5的例子，第四行的写操作会根据i的值影响a[0]和a[1]，在执行内存赋值后，状态分叉创建两个状态。同样根据第五行的内存读操作可能会访问[0]或a[1]。因此对于a[i]=5的两种可能结果的每一种，都有两种可能的断言结果，通过分叉相应的状态来探索相应结果</p>
</li>
<li><p>if-then-else formulas. 另一种方法是将符号指针的可能值编码到符号存储和路径约束的表达式中，而不分叉任何新的状态。主要思路是利用求解器的能力，对ite(c,t,f)的公式进行推理(if-then-else)，若c为true，则产生 t，否则产生f。这种方法对内存读写操作的作用不同。假设 α 是一个符号地址，它的具体值可能是 a1、a2，则：</p>
<ul>
<li>从$\alpha$中读取会得到表达式$ite(\alpha = a_1,\sigma(a_1),ite(\alpha=a_2,\sigma(a_2),…))$</li>
<li>在$\alpha$中写入表达式$e$会对$a_1,a_2$更新符号存储：$\sigma(a_i)\larr ite(\alpha=a_i,e,\sigma(a_i))$</li>
</ul>
<p>再看图5的例子，在第4行操作a[i]=5后，if-then-else方法没有产生分叉，而是编码两种可能的结果来更新内部存储$a[0] → ite (α_i = 0, 5, 0) 和 a[1] → ite (α_i = 1, 5, 0)$。同样在第五行，没有给a[j]的每一个可能的不同地址创建一个新的状态，而是将j的不确定性编码为单一表达式$ite (α_j = 0, σ (a[0]), σ (a[1])) = ite (α_j = 0,ite (α_i = 0, 5, 0),ite (α_i = 1, 5, 0)) $</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230724180939130.png" class title="image-20230724180939130">
</li>
</ul>
<p>fully symbolic memory可以最准确描述程序内存行为，并考虑所有可能的内存操作。在许多实际场景中，内存操作可能引用的地址集很小，如图5的例子，索引i和j的范围在一个有界区间内，因此可以使用合理的资源量精确分析。然而在一般情况下，符号地址可能引用内存中任何单元，造成状态数量激增。因此设计一系列技术提高可扩展性：</p>
<ul>
<li>以紧凑的方式表示内存。将符号地址表达式（而非具体地址表达式）映射为数据，以紧凑、隐式的形式表示使用符号地址引用内存时可能出现的其他状态。查询被卸载到高效的分页间隔树实现中，以确定内存读取操作可能会引用哪些存储数据。</li>
<li>用合理性换取性能。大致是用具体地址取代符号指针，将符号探索限制在执行状态的子集内。</li>
<li>堆建模。将探索限制在指针为空或指向先前堆分配对象的状态，而不是指向任何通用内存位置的状态。</li>
</ul>
<h3 id="3-2-Address-Concretization"><a href="#3-2-Address-Concretization" class="headerlink" title="3.2 Address Concretization"></a>3.2 Address Concretization</h3><p>指针值范围过大时导致组合复杂性爆炸时，地址具体化（包括将指针具体化为单个特定地址）可以有效减少状态数量，降低输入求解器的公式复杂度，但可能会遗漏一些路径，例如依赖于某些指针特定值的路径。</p>
<p>离线执行器自然性地出现具体化，它们通过将 T* 类型的引用具体化为 NULL 或新分配的 sizeof(T) 字节的对象地址来处理内存初始化。若T是结构体，那么同样的具体化方法将递归地应用于指向对象的所有字段。</p>
<h3 id="3-3-Partial-Memory-Modeling"><a href="#3-3-Partial-Memory-Modeling" class="headerlink" title="3.3 Partial Memory Modeling"></a>3.3 Partial Memory Modeling</h3><p>为了缓解完全符号化内存的可扩展性问题和内存具体化的合理性损失，Mayhem 引入部分内存模型,其主要思想是，如果写入地址可能取值的连续区间足够小，那么写入地址总是具体化的，而读取地址则是符号化的。这种模型基于一种权衡：它使用比具体化更具表现力的公式，因为它对每个状态的多个指针值进行编码，但并不试图像完全符号化内存那样对所有指针值进行编码。约束地址可能取值集合的基本方法包括尝试不同的具体值，并检查它们是否满足当前的路径约束，每次尝试都排除地址空间的大部分，直到找到一个严格的范围。这种算法有许多注意事项：例如，在每次符号取消引用时查询求解器的成本很高；内存范围可能不连续；符号指针内存区域内的值可能具有结构。因此，Mayhem 进行了一系列优化，例如值集分析 [42] 和各种形式的查询缓存（第 6 节），以高效地细化范围。如果在这一过程结束时，范围大小超过了给定的阈值（如 1024），那么地址就会被具体化。Angr [95] 也采用了部分内存模型的思想，并对其进行了扩展，可选择支持对小范围连续区间（最多 128 个地址）内的符号指针进行写操作。</p>
<h3 id="3-4-Lazy-Initialization"><a href="#3-4-Lazy-Initialization" class="headerlink" title="3.4 Lazy Initialization"></a>3.4 Lazy Initialization</h3><p>一种针对高级面向对象语言结构的符号执行技术。作者描述了一种软件验证框架，结合符号执行和模型检查来处理链接数据结构，如列表和树。</p>
<p>引入Lazy initialization来处理动态分配的对象。与1.1节的例子相比，增加了用于维护此类对象的堆配置。符号执行对复杂对象以未初始化字段开始，只有在执行过程中首次访问这些字段才对其初始化。当访问未初始化的引用字段时，算法会使用三种不同的堆配置分叉当前状态，其中字段初始化为(1)空；(2)对一个具有所有符号属性的新对象的引用(3)先前引入的所需类型的具体对象</p>
<p>参考文献[66]和[107]将lazy initialiation和用户提供的先决条件结合(即在方法执行前假定为真的条件)。前置条件用于描述那些程序输入状态，在这些状态下，方法有望按照程序员的意图运行。例如，我们希望二叉树数据结构是非循环的，每个节点（根节点除外）都有一个父节点。保守先决条件用于确保在初始化过程中消除不正确的堆配置，从而加快符号执行过程。</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230725180826998.png" class title="image-20230725180826998">
<p>例子：图8展示了一个java的递归add方法，将节点追加到链表的末尾，以及在应用lazy initialization时符号执行的最小表示形式。</p>
<blockquote>
<p>树节点表示 add 的直线片段的执行。最初，片段 A 对引用 l 进行求值，该引用是符号化的，因此未初始化。符号引擎会考虑三种情况：(1) l 为空；(2) l 指向一个新对象；(3) l 指向一个先前分配的对象。由于这是第一次遇到 Node 类型的引用，因此排除了选项 (3)。然后对剩下的两个选项进行扩展，执行相关的片段。第一个路径在执行片段 B 后结束，而第二个路径由于懒初始化隐式创建了一个新对象 o1，然后执行 C，递归调用 add。当扩展递归调用时，执行片段 A，引擎再次考虑三个选项，并分叉为三个不同的路径。由于之前已分配了一个 Node 对象（即 o1），因此现在考虑了选项 (3)。然而，这条路径很快就被引擎终止，因为它违反了非循环性前提条件（在本例中以注释的形式表示）。其他分叉路径会进一步扩展，重复同样的过程。由于链表的最大长度未知，探索过程可能会无止境地进行下去。因此，通常会假设实体化（即字段实例化）链的深度有一个上限。</p>
</blockquote>
<p>该领域的最新进展主要集中在提高堆配置的生成效率上。如在参考文献[38]中，引用变量的具体化被推迟到实际访问对象时才进行。参考文献[87]则采用了边界细化方法，通过使用已具体化字段的信息来剪除无意义的堆配置，同时使用 SAT 解算器来检查给定配置的声明性条件（而不是原始算法中的命令性条件）是否成立。</p>
<h2 id="4-INTERACTION-WITH-THE-ENVIRONMENT"><a href="#4-INTERACTION-WITH-THE-ENVIRONMENT" class="headerlink" title="4 INTERACTION WITH THE ENVIRONMENT"></a>4 INTERACTION WITH THE ENVIRONMENT</h2><p>Missing symbolic data flows through these software elements might indeed affect the meaningfulness of the analysis.</p>
<p><strong>System Environment</strong>：早期的一些研究（如 DART [51]、CUTE [91] 和 EXE [21]）通过使用具体参数实际执行外部调用，将系统环境纳入了分析范围。与完全符号策略相比，这确实限制了它们可以探索的行为，而完全符号策略则可能是不可行的。在在线执行器中，这种选择还可能导致来自不同执行路径的外部调用相互干扰。由于没有跟踪每次外部调用副作用的机制，因此可能存在状态不一致的风险，例如，一个执行路径可能在读取文件的同时，另一个执行路径却在试图删除文件。</p>
<p>克服这一问题的方法是创建能捕捉这些互动的抽象模型。例如，在 KLEE [20] 中，每个执行状态都有一个基本的符号文件系统来支持符号文件，该系统由一个包含 n 个符号文件的目录组成，符号文件的数量和大小由用户指定。对符号文件的操作会产生 n+1 个状态分支：每个可能的文件都有一个，另外还有一个可选分支，用于捕捉操作中的意外错误。由于标准库中的函数数量通常很大，为它们编写模型既昂贵又容易出错[12]，因此模型通常在系统调用级而不是库级实现。这样也可以对库进行符号探索。</p>
<p>AEG [8] 模拟了攻击者可用作输入源的大部分系统环境，包括文件系统、网络套接字和环境变量。此外，还模拟了 70 多个库和系统调用，包括线程和进程相关的系统调用，以及用于捕捉潜在缓冲区溢出的常用格式化函数。符号文件的处理方式与 KLEE [20] 类似，而符号套接字的处理方式与 KLEE [20] 类似，数据包及其有效载荷的处理方式与符号文件及其内容的处理方式类似。CLOUD9 [18] 支持额外的 POSIX 库，允许用户控制测试环境中的高级条件。例如，它可以模拟由网络数据流碎片引起的重新排序、延迟和数据包丢弃。</p>
<p>S2E指出模型除了编写成本高昂外，很少能达到完全准确，而且如果建模系统发生变化，模型可能很快就会过时。因此，最好让分析程序在探索多条路径时与真实环境交互。但是，这样做必须避免环境干扰或状态不一致。为了实现这一目标，S2E 采用了虚拟化技术，以防止在与真实环境交互时，副作用在多条独立执行路径间传播。QEMU 被用来模拟整个软件栈：指令被透明地翻译成由本地主机运行的微操作，而 x86 到LLVM 的提升器被用来在 KLEE [20] 中执行指令序列的符号执行。这样，S2E 就能正确评估环境造成的任何副作用。请注意，每当评估符号分支条件时，执行引擎都会分叉仿真器的并行实例，以探索替代路径。选择性符号执行（第 2.1 节）用于限制整个软件堆栈的符号探索范围，从而部分减轻仿真整个堆栈（如用户代码、库、驱动程序）的开销，因为这可能会大大限制整体解决方案的可扩展性。</p>
<p>DART 的方法[51]有所不同，其目标是实现自动单元测试。DART 将 C 程序中引用的所有外部变量和函数以及顶层函数的参数都视为外部接口。外部函数是通过非确定地返回其指定返回类型的任何值来模拟的。为了对不依赖于环境的库函数进行符号探索，用户可以调整外部函数和非外部函数之间的界限，以调整符号分析的范围。</p>
<p><strong>Application Environment</strong></p>
<p>在Swing或Android框架中会出现这些问题，如何分析用户交互过程调用的控制流和数据流。对于运行在托管运行时的应用程序，符号值也会在分析范围之外流动。这些特性使引擎的实现变得复杂：例如，Java 中的本地方法和反射依赖于底层 JVM 的内部机制 [3]。闭源组件也是一大难题。</p>
<p>与系统环境建模类似，DART [51] 和 CUTE [91] 等早期使用具体参数执行对其他组件的调用，这可能会导致探索不完整，无法为可行的程序路径生成输入。另一方面，对其代码进行符号执行也不可能成功，原因有很多：例如，外部简单行为的实现通常很复杂，因为它必须考虑到可扩展性和可维护性，或者可能包含与探索无关的细节，如如何显示触发回调的按钮[63]。一种解决方案是用<strong>更简单、更抽象的模型</strong>来模仿外部组件。然而，手动编写组件模型本身可能就是一项艰巨的任务，而且由于源代码不可用，使用不支持模型的应用程序仍将遥不可及。</p>
<p>一些工作尝试找到在符号探索时组件中需要符号值的实体，并因此需要人工干预分析。另一些尝试自动生成模型，这可能是闭源组件唯一的选择。参考文献[24]和[105]采用程序切片的方法来提取操作与分析相关的给定字段集的代码，并从中建立抽象模型。参考文献[63]则更进一步，使用程序合成来生成 Java 框架的模型。这些模型提供了许多框架中大量使用的设计模式的等效实例： 这有助于符号执行器发现控制流—例如通过观察者模式回调用户代码—否则就会被忽略。使用程序合成的一个优势是，它可以生成比切片更简洁的模型，因为它通过捕捉程序的功能行为，抽象掉了程序编写的细节和纠葛。</p>
<h2 id="5-PATH-EXPLOSION"><a href="#5-PATH-EXPLOSION" class="headerlink" title="5 PATH EXPLOSION"></a>5 PATH EXPLOSION</h2><p>符号执行器可能在每一个分支fork一个新状态，导致路径数指数级上涨</p>
<p>路径爆炸的主要来源是循环和函数调用。</p>
<blockquote>
<p>考虑以下代码片段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = sym_input();//e.g., read from file</span><br><span class="line">while(x&gt;0) x = sym_input();</span><br></pre></td></tr></table></figure>
<p>sym_input是一个从外部读取输入的线程。任何final state的路径约束有以下形式</p>
<script type="math/tex; mode=display">
\pi = (\and_{i\in[1,k]}\alpha_i>0)\and(\alpha_{k+1}\leq 0)</script><p>where k is the number of iterations and αi is the symbol produced by sym_input() at the ith iteration</p>
</blockquote>
<p>简单方法：将循环探索限制在有限的迭代次数，但容易错过重要路径。</p>
<p>下面将介绍另外策略，例如通过总结策略来描述不同循环迭代或函数调用之间的相似性，从而防止重复探索代码部分，或者通过推断不变式来归纳描述计算的属性。</p>
<h3 id="5-1-Pruning-Unrealizable-Paths"><a href="#5-1-Pruning-Unrealizable-Paths" class="headerlink" title="5.1 Pruning Unrealizable Paths"></a>5.1 Pruning Unrealizable Paths</h3><p>缩小路径空间的一种方法是在每个分支上调用约束求解器，修剪无法实现的分支：<em>如果求解器能证明某个分支的路径约束所给出的逻辑公式是不可满足的，那么程序输入值的任何赋值都不可能驱动实际执行走向该路径，符号引擎就可以在不影响稳健性的情况下安全地丢弃该分支。</em></p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230727010130477.png" class title="image-20230727010130477">
<p>这种方法被称为eager evaluation of path constraints，因为在每个分支上都会即刻检查约束，这也是大多数符号引擎的默认设置。</p>
<p>参考文献[90]介绍了一种有助于减少检查路径数量的正交方法。虽然 SMT 求解器可用于每次探索一条路径的大型搜索空间，但它最终往往会推理出许多路径共享的控制流。这项工作利用了这一观察结果，从每条被证明为不可满足的路径中提取最小的不满足核心，在保留不满足性的同时删除尽可能多的语句。这样，引擎就可以利用不满足核心来放弃共享相同（不可满足）语句的路径。</p>
<h3 id="5-2-Function-and-Loop-Summarization"><a href="#5-2-Function-and-Loop-Summarization" class="headerlink" title="5.2 Function and Loop Summarization"></a>5.2 Function and Loop Summarization</h3><p>当一个代码片段—无论是函数还是循环体—被多次遍历时，符号执行器就能建立一个代码执行摘要，供后续重复使用。</p>
<p><strong>Function Summaries</strong>. 参考文献[50]针对concolic执行动态生成函数摘要，允许执行器有效重用之前发现的分析结果。该技术通过公式 $\phi_w$捕捉函数调用的效果，将在探索路径 $w $期间观察到的函数输入约束与输出约束结合在一起，描述了等价的具体执行。</p>
<p>函数摘要由不同类的$\phi_w$公式定义，可行的程序间路径由程序内路径的符号执行组合而成。参考文献[4]扩展了组合式符号执行，将摘要生成为带有未解释函数的一阶逻辑公式，允许形成不完整摘要（即只捕获函数内路径的一个子集），在程序间分析过程中，随着更多语句被覆盖，这些摘要可以按需扩展。</p>
<p>参考文献[14]提供了一种不同的摘要生成方法：如果两种状态仅在某些程序值上存在差异，而这些程序值以后不会被读取，那么由这两种状态产生的执行将产生相同的副作用。因此，代码片段的副作用可以被缓存，并可能在以后重复使用。</p>
<p><strong>Loop Summaries.</strong> 与函数调用类似，参考文献[54]描述了循环部分摘要。循环摘要使用了符号执行过程中通过推理循环条件和符号变量之间的依赖关系动态计算出的前置与后置条件。缓存循环摘要不仅能让符号引擎避免在同一程序状态下重复执行同一循环，还能将摘要推广到同一循环在不同条件下的不同执行。</p>
<p>早期的研究成果只能为循环生成摘要，这些循环通过增加一个固定量来更新迭代中的符号变量。此外，它们也无法处理嵌套循环或多路径循环，即在循环体中带有分支的循环。Proteus [113] 是一个用于总结多路径循环的通用框架。它根据路径条件的值变化模式（即感应变量是否更新）和循环内路径交错模式（即是否存在规律性）对循环进行分类。这种分类方法利用了控制流图的扩展形式，然后用它来构建一个自动机，对循环内路径交错进行建模。该自动机以深度优先的方式遍历，并为其中所有可行的轨迹构建摘要，其中一个轨迹代表循环中的一次执行。这种分类方法决定了一个循环是可以被精确或近似地捕获（这可能仍有实际意义），还是不能被捕获。对于具有不规则模式或非归纳更新的多路循环的精确总结，以及更重要的嵌套循环的总结，仍然是有待解决的研究课题。</p>
<p>参考文献[96]介绍了一种压缩技术，通过分析控制流图中的循环路径，可以得到声明性描述程序状态的模板，这些状态由部分代码生成，形成一棵紧凑的符号执行树。通过利用模板，符号执行引擎可以探索的程序状态数量大大减少。这种方法的缺点是模板在路径约束中引入了量词：反过来，这可能会大大增加约束求解器的负担。</p>
<h3 id="5-3-Path-Subsumption-and-Equivalence"><a href="#5-3-Path-Subsumption-and-Equivalence" class="headerlink" title="5.3 Path Subsumption and Equivalence"></a>5.3 Path Subsumption and Equivalence</h3><p>庞大的符号状态空间为探索路径相似性的技术提供了空间，例如，摒弃不能带来新发现或抽象出差异的路径。在本节中，我们将讨论一些这方面的工作。</p>
<p><strong>Interpolation</strong>(插值？)现代 SAT 求解器依赖于搜索和演绎的相互促进组合，当前者受阻时，后者将推动前者摆脱冲突。与此类似，符号执行也能从插值技术中获益，从没有显示出所需属性的程序路径中推导出属性，从而避免探索无法满足属性的类似路径。</p>
<p><em>Craig interpolants</em>可以决定一个公式的哪些信息与一个属性相关。</p>
<p>假设蕴涵 P → Q 在某种逻辑中成立，我们可以构造一个内插式 I，使得 P → I 和 I → Q 都有效，并且 I 中的每个非逻辑符号都同时出现在 P 和 Q 中。插值法在程序验证中常用如下：给定一个不可满足公式 P ∧ Q 的反驳证明，可以构造一个反向插值器 I，使得 P → I 有效，而 I ∧ Q 不可满足。</p>
<p>插值在很大程度上被用于模型检查、谓词抽象、谓词细化、定理证明等领域。例如，插值法提供了一种将有界模型检查扩展到无界情况的方法—有界模型检查的目的是证伪程序的安全属性，而程序的过渡关系是在给定边界内展开的。特别是，由于有界证明通常包含无界证明的成分，插值法可以帮助从有界情况的反驳证明中构建所有可到达最终状态的过度逼近，从而获得足以证明不存在违规行为的过度逼近。</p>
<p><strong>Subsumption with Interpolation.</strong> 在符号验证带有明确错误位置标记（如使用断言）的程序时，插值法可用于解决路径爆炸问题。在探索过程中，引擎会为每个程序位置注释一些条件，这些条件概括了之前通过该位置但未能到达错误位置的路径。每次遇到分支时，执行器都会检查路径条件是否被之前的探索所包含。在最佳情况下，这种方法可以成倍地减少访问路径的数量。</p>
<p>参考文献[75]为分支和语句提出了一种注释算法，即如果它们的标签是由当前状态暗示的，那么它们就不会导致错误位置。插值法用于构建弱标签，从而实现高效的蕴含计算。参考文献[117]提出了一种类似的去除冗余的方法，称为后置条件符号执行，在这种方法中，程序位置被标注上后置条件，即总结先前探索路径后缀的最弱前提条件。这里的直觉是，插值越弱，就越有可能实现路径归并。后置条件是从完全探索过的路径中增量构建并向后传播的。当遇到分支时，相应的后置条件会被否定并添加到路径约束中。</p>
<p>路径归并的合理性依赖于这样一个事实，即为某个位置计算的插值能够捕捉到经过该位置的所有路径。因此，路径选择策略在内插法构建中起着关键作用： 例如，DFS 非常方便，因为它可以快速全面探索路径，从而构建内插值并最终向后传播；而 BFS 则会阻碍归并，因为在检查分支冗余时，由于尚未全面探索类似路径，内插值可能不可用。参考文献[59]提出了一种名为 “贪婪确认 “的新策略，它将路径选择问题与内插值形成问题分离开来，允许用户在使用 DFS 以外的启发式方法时从路径归并中获益。贪婪确认可区分路径树已被全部或部分探索过的节点： 对于后者，它会对额外的路径进行有限的遍历，以实现插值形成。</p>
<p>事实证明，插值法有助于在给定的时间内探索复杂程序的较大部分。参考文献 [117] 称，路径冗余在现实世界中非常广泛。通常情况下，插值的开销（可在 SMT 求解器或专用引擎中执行）会在早期阶段降低探索速度，但插值的优势最终会开始显现，从而大大加快探索速度[59]。</p>
<p><strong>Unbounded Loops.</strong> 如果代码中存在无界循环，就很难在其中的程序位置执行合理的子归纳，因为有大量路径可以通过这些位置。参考文献[75]设计了一种迭代深化策略，将循环展开到固定深度，并尝试计算循环不变的内插值，这样就可以用它们来证明无界情况下错误节点的不可到达性。然而，这种方法可能无法终止那些需要互不相关的循环不变式的程序。因此，参考文献 [61] 提出了一种策略，即计算足够强的推测不变式，使循环的符号执行快速收敛，同时也足够宽松，尽可能允许路径归并。在后续工作中[60]，在符号执行过程中使用拓宽算子单独发现循环不变式，并构建路径子假设的最弱先决条件，使其与不变式相蕴涵。</p>
<p><strong>Subsumption with Abstraction</strong>. 参考文献[6]采用了一种不基于插值的方法，描述了一种针对符号状态的双重归并检查技术。符号状态是通过符号堆和一组标量变量约束来定义的。因此，该技术不仅针对标量类型，还针对未初始化或部分初始化的数据结构。本文介绍了一种通过图遍历来匹配堆配置的算法，同时还使用了一种现成的求解器来推理标量数据的归并。</p>
<p>为了应对可能无限制的状态数量，这项工作提出了抽象方法，使符号状态空间有限，从而使子归并有效。抽象方法可以概括堆的形状和标量数据的约束条件；给出了链表和数组的例子。归并检查发生在欠近似状态上，这意味着可行的行为可能会被遗漏。作者在证伪场景中结合模型检查使用了这一技术，并将其应用于仅基于符号执行的验证中。</p>
<p><strong>Path Partition.</strong> 控制流和数据流的依赖性分析揭示了一些偶然关系，在探索过程中可以利用这些关系过滤掉无法揭示其他程序行为的路径。参考文献[74]将concolic执行的输入划分为互不干扰的区块，以符号方式探索每个区块，而其他区块则固定为具体值。当两个输入共同影响一个语句或由控制或数据依赖关系连接的语句时，就会发生干扰。参考文献[84]侧重于输出，如果两条路径在程序输出方面具有相同的相关片段，则将它们置于同一分区。相关片段是动态数据和控制依赖关系的传递闭包，也是涉及不执行会影响输出的语句的潜在依赖关系的传递闭包。参考文献[109]还通过为单个语句建立相关片段来探索与输出无关的故障，捕捉它们是如何通过符号输入计算出来的。依赖性分析能有效检查切片的等价性，当所有语句实例的切片都被之前的路径覆盖时，路径就会被认为是多余的。</p>
<h3 id="5-4-Under-Constrained-Symbolic-Execution"><a href="#5-4-Under-Constrained-Symbolic-Execution" class="headerlink" title="5.4 Under-Constrained Symbolic Execution"></a>5.4 Under-Constrained Symbolic Execution</h3><p>避免路径爆炸的一种可行方法：将要分析的代码（例如函数）从其外层系统中剪切出来，并对其进行隔离检查。例如3.4节的lazy initialization，就是遵循这一原则自动重构复杂数据结构的。然而，由于与周围环境关系紧密，将代码从应用程序中分离存在困难：在孤立函数中检测到的错误可能是假的，这是因为函数在完整的上下文执行时，输入可能永远不会是某些值。先前工作如参考文献[35]，首先对代码进行孤立分析，然后使用具体执行来测试生成的崩溃输入，以过滤误报。</p>
<p><em>Under-constrained symbolic execution.</em> 欠约限符号执行是符号执行的一个转折，将函数的符号输入以及可能被影响的全句数据标记为欠约束状态，从而对函数进行孤立分析。直观地说，如果在分析过程中，我们没有考虑到从程序入口点到函数的前缀路径上本应收集到的对符号变量值的约束，那么这个符号变量就是欠约束变量。在实践中，符号引擎可以通过跟踪内存访问并识别其位置，自动将数据标记为欠约束，而无需人工干预：例如，当对堆栈上的未初始化数据进行内存读取时，就可以检测到函数的输入。欠约束变量与经典的全约束符号变量具有相同的语义，但在表达式中使用时会产生错误。特别是，只有在当前已知的变量约束条件的所有解都会导致错误发生时，才会报告错误，也就是说，错误对上下文不敏感，因此是真正的正面错误。否则，它的否定将被添加到路径约束中，并恢复正常执行。这种方法可视为试图从代码中插入的检查中重建先决条件：任何违反已添加否定约束的后续操作都将被报告为错误。为了保持这种分析的正确性，只要任何表达式同时涉及欠约束值和完全约束值，就必须在变量之间传播标记。例如，在 a &gt; b 的比较中，a 是欠约束值，而 b 不是，这就迫使引擎将标记从 a 传播到 b，就像在污点分析中处理污点值一样。符号引擎通常使用阴影内存来跟踪标记。</p>
<p>虽然这种技术可能会遗漏错误，并不完善，但它仍能在较大的程序中发现有趣的错误。此外，欠约束符号执行的应用不仅限于函数： 例如，如果某个代码区域（如循环）可能会给符号执行器带来麻烦，那么就可以通过将其影响的位置标记为欠约束来跳过该代码区域。一般来说，要了解跳过的代码会影响哪些数据并不容易，因此可能需要手动标注，以保证分析的正确性。</p>
<h3 id="5-5-Exploiting-Preconditions-and-Input-Features"><a href="#5-5-Exploiting-Preconditions-and-Input-Features" class="headerlink" title="5.5 Exploiting Preconditions and Input Features"></a>5.5 Exploiting Preconditions and Input Features</h3><p>减少路径爆炸的另一种方法是利用某些输入属性的知识。AEG [8] 提出了先决条件符号执行法，通过引导探索满足先决条件谓词的输入空间子集，减少探索状态的数量。其基本原理是将重点放在可能导致程序某些行为的输入上（例如，将探索范围缩小到最大大小的输入，以揭示潜在的缓冲区溢出）。前置条件符号执行以合理性换取性能：精心设计的前置条件既不能太具体（会错过有趣的路径），也不能太通用（会影响空间状态缩减带来的速度提升）。这种方法不是从一个空的路径约束集开始，而是将先决条件添加到初始 π 中，这样探索的其余部分就会跳过不满足这些先决条件的分支。虽然在初始化时为 π 添加更多的约束条件可能会增加求解器的负担，因为它需要在每个分支执行更多的检查，但这在很大程度上可能会被更小的状态空间所带来的性能提升所抵消。</p>
<p>符号执行中常见的前提条件类型包括：已知长度（即缓冲区的大小已知）、已知前缀（即缓冲区的前缀已知）和完全已知（即缓冲区的内容完全具体）。在处理对具有已知或预定义结构的输入进行操作的代码（如字符串解析器或数据包处理工具）时，这些前提条件是非常自然的。</p>
<blockquote>
<p>Example. Example. Consider the following simplified packet header processing code: pkt points to the input buffer, while header to the fixed expected content. If no precondition is considered, then this code can generate an exponential number of paths, since any mismatch forces a new call to get_input. However, if a known prefix precondition is set on the input, then only a single path is generated when exploring the loop. The engine can thus focus its exploration on parse_payload().</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start: get_input(&amp;pkt);</span><br><span class="line">for(k = 0; k &lt; 128; k++)</span><br><span class="line">	if (pkt[k] != header[k])</span><br><span class="line">		goto start;</span><br><span class="line">parse_payload(pkt)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>参考文献[88]提出了一种称为循环扩展符号执行（loop-extended symbolic execution）的技术，只要有描述输入程序的语法，这种技术就能有效地探索循环。将迭代次数与程序输入的特征联系起来，可以有效地指导对循环产生的程序状态的探索，从而减少路径爆炸问题。</p>
<h3 id="5-6-State-Merging"><a href="#5-6-State-Merging" class="headerlink" title="5.6 State Merging"></a>5.6 State Merging</h3><p>状态合并是一种功能强大的技术，它能将不同的路径合并成一个状态。合并后的状态由一个公式来描述，该公式代表了在保持独立的情况下描述各个状态的公式的析取。与抽象解释等其他静态程序分析技术不同，符号执行中的合并不会导致过度逼近。</p>
<blockquote>
<p>图a：未使用状态归并，图b：借助ite语句实现状态归并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo(int x,int y)&#123;</span><br><span class="line">	if(x&lt;5)</span><br><span class="line">		y=y*2;</span><br><span class="line">	else</span><br><span class="line">		y=y*3;</span><br><span class="line">	return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230731105753547.png" class title="image-20230731105753547">
</blockquote>
<p><strong>Tradeoffs: To Merge or Not to Merge?</strong>  原则上，两个要评估同一语句且在符号存储上相似的符号状态，将其合并可能是有利的</p>
<p>给定两个状态$(stmt,\sigma_1,\pi_1)$和$(stmt,\sigma_2,\pi_2)$，合并后的状态可以构造为$(stmt,\sigma,\pi_1\or\pi_2)$，其中$\sigma$是$\sigma_1$和$\sigma_2$之间的合并符号存储空间，使用ite表达式建立，以考虑存储空间的差异，而$\pi_1 \or \pi_2$是两个合并状态的路径约束的并集。</p>
<p>控制流结构，如 if-else 语句（如前面的例子）或简单循环，通常会产生非常相似的后继状态，是状态合并的最佳候选。</p>
<p>早期的研究[50, 57]表明，合并技术能有效减少探索路径的数量，但同时也会给约束求解器带来负担，因为不连接会妨碍求解。合并还可能在代码中引入新的符号表达式，例如，将条件赋值中的不同具体值合并为条件的符号表达式。参考文献 [70] 对状态合并技术的设计空间进行了精彩的讨论。一方面，在基于搜索的符号执行（第 2.2 节）中使用的路径完全分离技术不执行合并。在另一端，静态状态合并将控制流连接点上的状态合并起来，实质上是用一个公式表示整个程序。静态状态合并用于整个程序验证条件生成器[10, 114]，这种生成器通常以精度换取可扩展性，例如只展开循环一次。</p>
<p><strong>Merging Heuristics. </strong>中间合并方案采用启发式方法来识别状态合并，从而加快探索过程。事实上，产生较大的符号表达式和可能的额外求解器调用可能会超过状态较少带来的好处，从而导致整体性能较差 [57, 70]。查询次数估算 [70] 依靠简单的静态分析来确定每个变量在 CFG 中任何给定点之后的分支条件中的使用频率。估算结果可以代表特定变量可能参与的求解器查询次数。如果两个状态的不同变量在以后的查询中出现的频率很低，那么这两个状态就很适合合并。Veritesting [9] 实现了一种基于容易语句和困难语句区分的合并启发式，后者涉及间接跳转、系统调用和其他难以实现精确静态分析的操作。静态合并是在容易语句序列上进行的，其效果用 ite 表达式捕捉，而每当遇到难以分析的语句时，就进行逐路径符号探索。(启发式合并)</p>
<p><strong>Dynamic State Merging.</strong> 参考文献[70]引入了动态状态合并，这种合并不受搜索策略所强加的探索顺序的影响。假设符号引擎维护着一个状态工作列表和一个有界的前代状态历史。当引擎需要选择下一个要探索的状态时，它首先会检查工作列表中是否有两个状态 s1 和 s2，它们不匹配，无法合并，但 s1 和 s2 的前一个状态匹配。如果 s2 和 s1 的后继状态之间的预期相似度也很高，那么算法就会通过将 s1 的执行提前固定步数来尝试合并。这体现了一种理念，即如果两个状态相似，那么它们各自的后继状态也很可能在几步后变得相似。如果合并失败，算法就会让搜索启发式选择下一个要探索的状态。</p>
<h3 id="5-7-Leverageing-Program-Analysis-and-Optimization-Techniques"><a href="#5-7-Leverageing-Program-Analysis-and-Optimization-Techniques" class="headerlink" title="5.7 Leverageing Program Analysis and Optimization Techniques"></a>5.7 Leverageing Program Analysis and Optimization Techniques</h3><p>借助程序分析技术优化符号执行</p>
<p><strong>Program Slicing.</strong> 从程序行为的子集开始分析，从程序中能够表示该行为的最小序列提取。这些信息可以帮助符号引擎：例如参考文献[94]利用向后程序切片来限制对特定目标程序点的符号探索。</p>
<p><strong>Taint Analysis. </strong> 这项技术[89]试图检查程序中哪些变量的值可能来自潜在危险的外部来源，如用户输入。这种分析既可静态执行，也可动态执行，后者的结果更为准确。在符号执行方面，污点分析可以帮助引擎检测哪些路径依赖于污点值。例如，参考文献[25]将分析重点放在跳转指令被污染的路径上，并通过符号执行利用漏洞。</p>
<p><strong>Fuzzing. </strong>这种软件测试方法会随机改变用户提供的测试输入，导致崩溃或断言失败，并可能发现潜在的内存泄漏。模糊测试可与符号执行相结合，收集输入的约束条件，并否定这些约束条件以生成新的输入。另一方面，符号执行器也可以通过模糊处理进行增强，从而更快、更高效地达到更深的探索状态。</p>
<p><strong>Branch Prediction. </strong>这是一种在流水线执行中减轻错误预测惩罚的策略，方法是避免在代码的极小部分进行跳转： 例如，控制流分叉结构（如 C 语言的三元运算符）可以用谓语选择指令代替。参考文献[30]指出，在使用符号执行交叉检查程序的两个实现时，采用这种策略可使探索路径的数量呈指数级减少。</p>
<p><strong>Type Checking. </strong> 符号分析与类型检查可以有效结合，例如类型检查可以确认符号分析难以进行的函数的返回类型，这些信息可以帮助执行器裁剪某些路径。</p>
<p><strong>Program Differencing. </strong>?没看懂？依赖性分析可以识别受代码编辑影响的分支和数据流。定向增量符号执行 [116] 可以静态识别受更改影响的 CFG 节点，并利用这些信息只对那些行使未发现的受影响节点序列的路径进行探索。</p>
<p><strong>Compiler Optimzations. </strong>参考文献[19]认为，程序优化技术应与搜索启发式、状态合并和约束求解优化等广为接受的解决方案一起，成为符号执行实际实现的一流要素。事实上，程序转换既能影响路径探索过程中产生的约束的复杂性，也能影响探索本身。例如，使用查找表对函数结果进行预计算，会因内存访问而导致路径条件中的约束条件数量增加，而对乘法运算进行强度还原，则可能导致一连串的加法运算，从而增加约束条件求解器的成本。此外，编译高级开关语句的方式也会极大地影响路径探索的性能，而采用条件指令（如 LLVM 中的 select 或 x86 中的 setcc 和 cmov）则可以通过生成简单的 ite 表达式来避免昂贵的状态分叉。</p>
<p>编译器优化的效果通常可以通过运行时执行的指令数量或大小来预测，但在符号执行中，类似的优化效果并不明显[41]，这主要是因为约束求解器通常是作为黑盒使用的。据我们所知，只有少数工作尝试分析编译器优化对约束生成和路径探索的影响 [41，108]，留下了一些有趣的开放性问题。参考文献[80]中介绍的工作与此不同，它探讨了动态常量折叠和优化约束编码等变换，以加快基于数组理论的符号执行器中的内存操作（第 3.1 节）。</p>
<h2 id="6-CONSTRAINT-SOLVING"><a href="#6-CONSTRAINT-SOLVING" class="headerlink" title="6 CONSTRAINT SOLVING"></a>6 CONSTRAINT SOLVING</h2><p>约束求解仍然是符号执行引擎可扩展性的主要障碍之一，而且在面对涉及昂贵理论（如非线性算术）或不透明库调用的约束时，也阻碍了其可行性。</p>
<p>本部分主要讨论优化约束求解器的方法；包括(i) 减少要检查的约束条件的大小和复杂性；(ii) 通过采用缓存约束解、延迟求解器查询或具体化等方法减轻求解器的负担；(iii) 增强符号执行以处理对决策程序有问题的约束条件。</p>
<p><strong>Constraint Reduction.</strong> 将约束条件简化为更简单的形式，如编译器中常用的技术，常数折叠、强度降低和简化线性表达式（参见 KLEE [20]）。</p>
<p>EXE[21]引入了约束独立性优化，利用了一个约束集经常可以分成多个独立约束子集的事实。这种优化与查询结果缓存策略交互良好，当引擎向求解器询问特定约束的可满足性时，它还能提供额外的优势，因为它能从查询中删除不相关的约束。事实上，在实际程序中经常出现的独立分支会导致不必要的约束条件迅速累积。</p>
<p>程序在执行过程中会为某些变量添加特定的约束条件，如x:=5，可以对现有约束进行重写和优化，例如在x:=5后，将变量值x的其他约束简化为True，如x&gt;0，还可以在涉及 x 的其他后续约束中用相关的具体值代替符号 x。后一种优化方法也称为隐含值具体化，例如 KLEE [20] 就采用了这种方法。</p>
<p>S2E [29] 引入了比特字段理论表达式简化器，将比特运算掩盖掉的符号变量部分用具体值代替。例如，对于任何 8 位符号值 v，表达式 v | 10,000,0002 的值中最高位总是 1。简化器可以在树形表达式中传播信息，如果可以确定其值中的每一位，表达式就会被替换为相应的常量。</p>
<p><strong>Reuse of Constraint Solutions. </strong> 重用先前约束的计算结果来加快约束求解。目前，大多数约束求解的重用方法都是基于约束的语义或语法等价性。</p>
<p>EXE[21]缓存了约束求解和可满足性查询的结果，以尽可能减少调用求解器的需要。缓存由服务器进程处理，该进程可接收来自多个并行执行引擎实例的查询，每个实例都在探索不同的程序状态。</p>
<p>KLEE [20] 实现了一种名为反例缓存的增量优化策略。通过缓存，约束集被映射为具体的变量赋值，或者在约束集不可满足时映射为特殊的空值。当缓存中的不可满足集是给定约束集 S 的子集时，S 也被视为不可满足。反之，当缓存中包含 S 的超集的解时，该解也必然满足 S。最后，当缓存中包含 S 的一个或多个子集的解时，算法会尝试替换所有解，以检查是否能找到满足 S 的解。</p>
<p><em>Memorized Symbolic execution</em> [115] 的灵感来自于这样一个观察结果，即符号执行往往会导致重新运行大体相似的子问题，例如，发现一个错误，修复它，然后再次测试程序以检查修复是否有效。在路径探索过程中做出的选择会被紧凑地编码在前缀树中，从而为在连续运行中重复使用之前计算出的结果提供了可能。</p>
<p>The Green framework[106]不仅探讨了相同程序运行中的约束解决方案重用，还探讨了类似程序、不同程序和不同分析运行中的约束解决方案重用。通过切片转换，约束被提炼为其基本部分，并以规范形式表示，以实现良好的重用，即使在单次分析运行中也是如此。参考文献[64]介绍了该框架的扩展，它利用约束之间的逻辑蕴涵关系来支持约束重用和更快的执行时间</p>
<p><strong>Lazy Constraints.</strong> 参考文献 [85] 对约束求解器查询采用了一种timeout approch：当执行器遇到涉及代价较高的符号运算的分支语句时，会同时选择真分支和假分支，并在路径条件中添加一个Lazy Constraints。当探索到达满足某个目标的状态时（例如，发现错误），算法将检查路径的可行性，如果认为在实际执行中无法到达，则抑制该路径。</p>
<p>相比于即时检查可行性的eager approach，lazy strategy可能会导致更多的活动状态，进而导致更多的求解器查询。不过，作者报告说，在很多情况下，延迟查询比急切查询更有效： 事实上，在懒惰约束后添加的路径约束可以缩小求解器的求解空间。</p>
<p><strong>Concretization. </strong> 参考文献 [22] 讨论了经典符号执行在遇到约束求解器无法求解（至少无法高效求解）的公式时的局限性。Concolic executor 生成一些随机输入，同时进行具体和符号执行：具体执行中的一个可能值可用于求解器难以解决的公式中涉及的符号操作数，尽管代价可能是牺牲探索过程中的稳健性。</p>
<blockquote>
<p>Example. </p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230802111743884.png" class title="image-20230802111743884">
<p>在图 11 的代码片段中，引擎为第 2 行的真分支存储了一个形式为 αx = (αy ∗ αy ) % 50 的非线性约束。不支持非线性运算的求解器无法为程序生成任何输入。但concolic执行器可以利用具体值帮助求解器，例如，如果随机选择 x = 3 和 y = 5 作为初始输入参数，那么在具体执行时就不会出现这两个分支中的任何一个。然而，引擎可以重复使用 y 的具体值，由于 αy = 5，因此可以将之前的查询简化为 αx = 25。现在，引擎可以利用这个查询的直接解决方案来探索两个分支。请注意，如果 y 的值固定为 5，那么就无法生成一个新的输入，该输入只取第一条分支而不取第二条分支，从而导致假否定。在这种情况下，一个微不足道的解决方案是重新运行程序，为 y 选择一个不同的值（例如，如果 y = 2，那么 x = 4，这满足了第一条分支，但不满足第二条分支）。</p>
</blockquote>
<p>为了部分克服具体化带来的不完全性，参考文献 [78] 建议采用具体-符号混合解法，即在将一个或多个符号绑定到特定的具体值之前，先考虑路径上可收集到的所有路径约束。事实上，DART [51] 根据收集到的路径约束将符号具体化到目标分支。这样，同一路径的后续分支中包含的约束条件就不会被考虑在内，而且由于已经具体化的符号，该约束条件可能无法满足。如果出现这种情况，DART 会使用不同的随机具体值重新开始执行，希望能够满足后续分支的要求。参考文献[78]中提出的方法则要求沿着完整路径检测可解约束，并尽可能延迟具体化。</p>
<p><strong>Handling Problematic Constraints. </strong>强SMT求解器能够直接处理更多的路径约束，减少了对具体化的依赖，避免了由于随机选择值限制了可搜索解空间。然而，某些约束问题是不可判定的，如非线性整数运算，或经常用于模拟现实世界系统的三角函数的有理数理论。</p>
<p>参考文献[39]提出了一种concolic walk算法，可以解决涉及非线性运算和库调用的控制流依赖问题。(接下来就看不懂了)该算法将变量的赋值视为估值空间： 线性约束的解定义了一个可启发式行走的多面体，而其余约束的分配则使用一个适度函数来衡量估值点与约束的匹配程度。在多面体上选取点并对其进行非线性约束评估时，会对多面体进行自适应搜索。与具体-符号混合解法 [78] 相比，这两种技术都力求避免盲目承诺。不过，协整行走并不依赖求解器来获取评估复杂约束所需的所有具体输入，而是采用搜索启发式方法，引导在多边形上行走的人走向有希望的区域。</p>
<p>参考文献[40]介绍了符号后向执行（SBE）（第 2 节）和符号前向执行的新颖组合—符号前向执行（symcretic execution）。其主要思路是将探索分为两个阶段。在第一阶段，SBE 从目标点开始执行，并收集每条路径的轨迹。如果在反向探索过程中遇到任何有问题的约束，引擎就会通过在轨迹中添加特殊事件将其标记为潜在可满足的约束，然后继续反向遍历。每当沿着任何一条跟踪路径到达程序的入口点时，第二阶段就开始了。引擎会对收集到的轨迹进行具体评估，尝试满足在第一阶段被标记为有问题的任何约束。这是通过启发式搜索完成的，如上文所述的协程行走。与传统的concolic执行相比，symcretic 的优势在于它可以避免探索某些不可行的路径。例如，无论语句是如何到达的，后向阶段都可以确定该语句受不可满足分支的保护，而传统的concolic执行器只有在到达该语句时才会按路径检测其不可行性，这对路径 “深处 “的语句是不利的。</p>
<h2 id="7-FURTHER-DIRECTIONS"><a href="#7-FURTHER-DIRECTIONS" class="headerlink" title="7 FURTHER DIRECTIONS"></a>7 FURTHER DIRECTIONS</h2><p>相关领域可能用于提升符号执行的最新技术</p>
<h3 id="7-1-Separation-Logic"><a href="#7-1-Separation-Logic" class="headerlink" title="7.1 Separation Logic"></a>7.1 Separation Logic</h3><p>SL(separation logic) 对Hoare逻辑进行了扩展，方便对操作指针数据结构的程序进行推理，并允许以简洁的方式表达堆配置的复杂不变式。</p>
<p>看不到，略</p>
<h3 id="7-2-Invariants"><a href="#7-2-Invariants" class="headerlink" title="7.2 Invariants"></a>7.2 Invariants</h3><blockquote>
<p>Question:什么是不变式？什么是谓词？</p>
</blockquote>
<p>利用不变式可以捕捉循环的效果并对其进行推理，对符号执行器大有裨益，但不需要人工干预情况下计算循环不变式非常困难。</p>
<p>不过，许多研究人员最近探索了自动或只需少量人工帮助即可推断循环不变式的技术[47]</p>
<p><em>Termination analysis</em></p>
<p><em>Predicate abstraction</em></p>
<p><em>LoopFrog</em></p>
<h3 id="7-3-Function-Summaries"><a href="#7-3-Function-Summaries" class="headerlink" title="7.3 Function Summaries"></a>7.3 Function Summaries</h3><blockquote>
<p>Question: 函数摘要是什么样的？如何生成？</p>
</blockquote>
<p>函数摘要（第 5.2 节）主要用于静态和动态程序分析，尤其是程序验证。许多此类工作都为推动符号执行技术的发展提供了有趣的机会。例如，Calysto 静态检查器[10]会走程序的调用图，以构建每个函数效果的符号表示，即返回值、对全局变量的写入以及根据参数访问的内存位置。每个函数只处理一次，可能会在其调用位置内联小函数的效果。Calysto 和 Saturn [114] 等静态检查器在构建摘要时以可扩展性换取健全性，因为它们只对少量迭代的循环进行展开： 因此，在符号执行环境中使用它们，可能会失去健全性。参考文献[44]考虑到不同的输入条件，使用摘要缓存来记忆函数的效果，从而构建了更精细的摘要。<br>参考文献[93]提出了一种为模型检查提取函数摘要的技术，在模型检查中通常一次检查多个规范，因此摘要可以在验证运行中重复使用。特别是，它们是利用插值法（第 5.3 节）作为超近似值计算的，当过于微弱时，可在各次运行中加以完善。这种技术的优势在于，基于插值法的摘要能以比函数本身更简洁的方式捕捉通过函数的所有可能执行轨迹。后来，参考文献[92]将这一技术扩展到处理嵌套函数调用。</p>
<h3 id="7-4-Program-Analysis-and-Optimization"><a href="#7-4-Program-Analysis-and-Optimization" class="headerlink" title="7.4 Program Analysis and Optimization"></a>7.4 Program Analysis and Optimization</h3><p><em>Loop unfolding</em>，展示“结构良好”的循环，（例如，显示不变代码，或将常量或仿射函数作为数组引用的下标）</p>
<p><em>Program synthesis</em>能自动构建一个符合高级规范的程序[82]，这项技术引起了验证界的关注，因为 Reference [97] 已经展示了如何找到程序作为 SAT 问题的解决方案。在第 4 节中，我们讨论了参考文献 [63] 中使用该技术为复杂 Java 框架创建紧凑模型的方法： 该技术将框架中的类、方法和类型作为输入，同时还使用了练习其各部分的教程程序（通常由供应商提供）。我们认为，在路径爆炸问题的背景下，这种方法值得进一步研究。它有可能应用于软件模块（如标准库），以生成简洁的模型，从而对搜索空间进行更具扩展性的探索，因为合成可以捕捉外部行为，同时抽象掉实现过程中的纠缠。</p>
<h3 id="7-5-Symbolic-Computation"><a href="#7-5-Symbolic-Computation" class="headerlink" title="7.5 Symbolic Computation"></a>7.5 Symbolic Computation</h3><p>虽然 SMT 求解器在处理复杂表达式时结合理论和启发式的效率很高，但它们只在很小程度上利用了符号计算技术，而且对非线性实数和整数运算的支持仍处于起步阶段 [1]。据我们所知，只有 Z3 [36] 和 SMT-RAT [33] 可以同时对它们进行推理。<br>参考文献[1]指出，将符号计算技术作为 SMT 求解器的理论插件是一种很有前途的共生关系，因为它们为求解算术约束的连接提供了强大的程序。但由于这些程序的现有实现并不符合 SMT 兼容理论求解器所要求的增量、回溯和解释不一致性等特性，因此这一想法的实现受到了阻碍。SC2 [2]是一个值得关注的项目，其目标是创建一个新的社区，旨在弥合符号计算与可满足性检查之间的差距，结合两个领域的优势，解决目前各自无法解决的问题。</p>
<p>在处理非线性表达式时，还可以从符号-数值计算的最新进展中找到更多提高效率的机会[56]。特别是，这些技术旨在开发高效的多项式求解器，将数值算法与符号计算技术的保证结合起来，数值算法在近似局部解方面非常高效，但缺乏全局视角。这种混合技术可以扩展可高效求解问题的范围，因此对符号执行的非线性约束很有意义。</p>
<h2 id="8-CONCLUSIONS"><a href="#8-CONCLUSIONS" class="headerlink" title="8 CONCLUSIONS"></a>8 CONCLUSIONS</h2></div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-07-04  <a class="commentCountImg" href="/2023/07/04/CrackMe%E7%B3%BB%E5%88%97/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>16 m  <i class="fas fa-pencil-alt"> </i>2.4 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/04/CrackMe%E7%B3%BB%E5%88%97/"> </a></h1><div class="content"><h1 id="2023吾爱破解春节领红包系列"><a href="#2023吾爱破解春节领红包系列" class="headerlink" title="2023吾爱破解春节领红包系列"></a>2023吾爱破解春节领红包系列</h1><p>题目来源与WP参考：<a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1738015&amp;highlight=%B4%BA%BD%DA">【2023春节】解题领红包活动开始喽，解出就送论坛币！ - 『站点公告』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2023/07/04/CrackMe%E7%B3%BB%E5%88%97/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2023-07-07T13:11:21.208Z"><i class="far fa-calendar-check"> Last Modified: </i>2023-07-07</time></div></div></div></article></div><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-06-30  <a class="commentCountImg" href="/2023/06/30/FirmFuzz/#comment-container"><span class="display-none-class">07a38c8f99d8c150231de20884c02f9b</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="07a38c8f99d8c150231de20884c02f9b">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>24 m  <i class="fas fa-pencil-alt"> </i>3.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/06/30/FirmFuzz/">Firm-Fuzz</a></h1><div class="content"><h1 id="Firm-Fuzz"><a href="#Firm-Fuzz" class="headerlink" title="Firm-Fuzz"></a>Firm-Fuzz</h1><p>Firm-Fuzz：基于Linux硬件镜像的设备无关性仿真和动态分析框架</p></div><div class="index-category-tag">  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2023/06/30/FirmFuzz/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2023-06-30T07:12:19.352Z"><i class="far fa-calendar-check"> Last Modified: </i>2023-06-30</time></div></div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-04-28  <a class="commentCountImg" href="/2023/04/28/BUAACTF2023/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>38 m  <i class="fas fa-pencil-alt"> </i>5.7 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/04/28/BUAACTF2023/"> </a></h1><div class="content"><h1 id="BUAACTF-2023"><a href="#BUAACTF-2023" class="headerlink" title="BUAACTF 2023"></a>BUAACTF 2023</h1><p>by CuratorJin</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2023/04/28/BUAACTF2023/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2023-04-28T07:57:50.222Z"><i class="far fa-calendar-check"> Last Modified: </i>2023-04-28</time></div></div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-02-18  <a class="commentCountImg" href="/2023/02/18/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>21 m  <i class="fas fa-pencil-alt"> </i>3.2 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/18/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/"> </a></h1><div class="content"><h1 id="模糊测试技术综述-仁泽众等"><a href="#模糊测试技术综述-仁泽众等" class="headerlink" title="模糊测试技术综述_仁泽众等"></a>模糊测试技术综述_仁泽众等</h1><p><strong>模糊测试技术</strong>是漏洞检测技术的一种，通过使用针对目标程序生成的随机字符流，队目标程序进行多次测试，以检测可能存在的漏洞</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2023/02/18/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2023-04-28T07:53:33.563Z"><i class="far fa-calendar-check"> Last Modified: </i>2023-04-28</time></div></div></div></article></div><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-02-18  <a class="commentCountImg" href="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>36 m  <i class="fas fa-pencil-alt"> </i>5.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/"> </a></h1><div class="content"><h1 id="Path-sensitive-fuzzing-for-Native-Application"><a href="#Path-sensitive-fuzzing-for-Native-Application" class="headerlink" title="Path sensitive fuzzing for Native Application"></a>Path sensitive fuzzing for Native Application</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>代码覆盖率对于覆盖引导的模糊器至关重要</p>
<p>由于高额的开销使得跟踪路径覆盖不可行</p>
<h3 id="1-1-覆盖不精确如何影响漏洞发现"><a href="#1-1-覆盖不精确如何影响漏洞发现" class="headerlink" title="1.1 覆盖不精确如何影响漏洞发现"></a>1.1 覆盖不精确如何影响漏洞发现</h3><ol>
<li>覆盖不精确可能会导致测试器没有能够区分两条不同的路径。如果一个测试用例探索到了一条新路径，但他与之前已探索过的路径碰撞了，测试器则会认为这条新路径不那么重要</li>
<li>覆盖不精确会影响测试策略。它影响力测试器选择最优的种子进行测试</li>
</ol>
<h3 id="1-2-如何提高覆盖精确度并引导测试器"><a href="#1-2-如何提高覆盖精确度并引导测试器" class="headerlink" title="1.2 如何提高覆盖精确度并引导测试器"></a>1.2 如何提高覆盖精确度并引导测试器</h3><p>跟踪边缘和块覆盖是可能的</p>
<p>AFL的覆盖跟踪有着更低的时间开销</p>
<p>由于哈希冲突问题，AFL的边缘覆盖是不完美的。对该问题的解决措施是扩大AFL用于存储覆盖的比特图的大小</p>
<p>CollAFL解决了AFL的哈希碰撞问题并提高了覆盖精确度，还提出了三个新的测试策略，来驱动测试器发现未探索的道路，并提高发现漏洞的效率</p>
<p>CollAFL通过确认每条路径有一个特定的Hash，所以AFL能区分每一条路径</p>
<h3 id="1-3-如何将建议的解决方案应用于二进制应用程序？"><a href="#1-3-如何将建议的解决方案应用于二进制应用程序？" class="headerlink" title="1.3 如何将建议的解决方案应用于二进制应用程序？"></a>1.3 如何将建议的解决方案应用于二进制应用程序？</h3><p>使用静态二进制检查(static binary instrumentation(SBI))来将解决方案应用到二进制程序中。对于每一个二进制程序，fuzzer会反汇编该程序，恢复其控制流图，并使用建议的覆盖跟踪方案对应用程序进行检测</p>
<h3 id="1-4-覆盖敏感的测试器表现如何"><a href="#1-4-覆盖敏感的测试器表现如何" class="headerlink" title="1.4 覆盖敏感的测试器表现如何"></a>1.4 覆盖敏感的测试器表现如何</h3><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230105215701827.png" class title="image-20230105215701827">
<p>测试结果</p>
<ul>
<li>在真实应用中哈希碰撞问题很普遍，75%边界会与其他产生冲突</li>
<li>论文中所提出的碰撞减轻方案可以解决所有已知边界的哈希碰撞，并能够帮助测试器探索9.9%多的代码，250%多独特的冲突和140%多的安全漏洞</li>
<li>在碰撞减轻方案和未接触分支指向种子选择的联合作用下，探索多了20%的代码，320%多的冲突，260%多的安全漏洞</li>
</ul>
<p>总结：</p>
<ul>
<li>哈希碰撞问题严重影响了AFL的效率，覆盖不精确的问题降低了覆盖引导的fuzzer的效率</li>
<li>设计了一套算法来解决AFL中的哈希碰撞问题，低开销情况下提高了边覆盖精确度</li>
<li>提出了三个覆盖敏感的种子选择策略。经验表明基于精确的边覆盖信息来权衡种子选择能提高fuzzer的表现</li>
<li>提供了CollAFL的两个变种，能够在提供或不提供源码的情况下测试程序</li>
</ul>
<h2 id="2-Background-And-Related-Work"><a href="#2-Background-And-Related-Work" class="headerlink" title="2 Background And Related Work"></a>2 Background And Related Work</h2><h3 id="2-1Fuzzing"><a href="#2-1Fuzzing" class="headerlink" title="2.1Fuzzing"></a>2.1Fuzzing</h3><h3 id="2-2Coverage-Guided-Fuzzing"><a href="#2-2Coverage-Guided-Fuzzing" class="headerlink" title="2.2Coverage Guided Fuzzing"></a>2.2Coverage Guided Fuzzing</h3><p>进化算法</p>
<p>最先进的覆盖导向fuzzer：AFL、libFuzzer、VUzzer</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230109003758238.png" class title="image-20230109003758238">
<h3 id="2-3-Coverage-Tracking"><a href="#2-3-Coverage-Tracking" class="headerlink" title="2.3 Coverage Tracking"></a>2.3 Coverage Tracking</h3><p>覆盖导向的fuzzers跟踪不同层次的代码覆盖。</p>
<p>LibFuzzer和honggfuzz利用Clang编译器提供的SanitizerOverage检测方法来跟踪块覆盖</p>
<p>AFL使用静态/动态分析来跟踪边覆盖</p>
<p>Angora记录调用上下文并跟踪上下文敏感的边缘覆盖</p>
<p>块覆盖是最不敏感的<br>上下文敏感的边缘覆盖是最敏感的</p>
<p>给定边缘覆盖率，很容易去推导块覆盖率。然而几乎不可能从块覆盖率去推导边覆盖率</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230109011226897.png" class title="image-20230109011226897">
<p>图中无关键路径，P1和P2走了完全不同的路径，块覆盖一致而路径覆盖不一致</p>
<p>尽管上下文敏感的边缘覆盖可以帮助识别更多的路径，但带来了许多负面的效果</p>
<ul>
<li>由于不同的调用上下文，不同路径的相同边会分配不同的哈希，使边和位图之间的映射不确定。因此fuzzer很难获得每个边的全局覆盖状态，因此具有较低的控制流灵敏度。为了解决这个问题，Angora分配了额外的共享内存来记录边映射。</li>
<li>提供上下文敏感边缘覆盖的解决方案将为队列引入许多无用的路径，因此将浪费计算资源并削弱新边缘的发现</li>
</ul>
<h4 id="2-3-1哈希碰撞问题"><a href="#2-3-1哈希碰撞问题" class="headerlink" title="2.3.1哈希碰撞问题"></a>2.3.1哈希碰撞问题</h4><p>AFL使用位图（默认大小64KB）来跟踪应用的边覆盖。每一个位图的字节代表了特定边的统计数据。每个边的Hash作为位图的键值。因此可能会有哈希碰撞的问题，即两个两条边共享一个哈希值，使得fuzzer不能区分这些边，导致覆盖的不精确</p>
<p>AFL为目标程序的基本块分配随机键值，例如边A-&gt;B，AFL以如下方式计算器Hash</p>
<script type="math/tex; mode=display">
cur\oplus(prev>>1)</script><p>其中prev和cur是基本块A和B的键值。由于生日攻击，哈希碰撞的比例非常高</p>
<p>实验表明，由于哈希碰撞，在真实应用测试中高达75%的边对于AFL是不可见的</p>
<h3 id="2-4-种子选择策略"><a href="#2-4-种子选择策略" class="headerlink" title="2.4 种子选择策略"></a>2.4 种子选择策略</h3><p>AFL倾向于更小和执行速度更快的种子</p>
<p>VUzzer倾向于能探索更深路径的种子</p>
<p>AFLfast倾向于探索频率较低的和更少被选择的种子</p>
<p>考虑到代码覆盖信息并不精确，这会使得fuzzer在筛选种子时不能做出最优选择。例如冷热路径的选择</p>
<h3 id="2-5-论文的关注点"><a href="#2-5-论文的关注点" class="headerlink" title="2.5 论文的关注点"></a>2.5 论文的关注点</h3><p>提出了CollAFL，覆盖敏感的fuzz解决方案。它提高了代码覆盖跟踪的精度，并利用精确覆盖的信息来指引fuzzer。而且，我们评估了将此解决方案应用于闭源应用程序的可行性</p>
<h2 id="3-Imporve-Coverage-Accuracy"><a href="#3-Imporve-Coverage-Accuracy" class="headerlink" title="3 Imporve Coverage Accuracy"></a>3 Imporve Coverage Accuracy</h2><h3 id="3-1-覆盖粒度"><a href="#3-1-覆盖粒度" class="headerlink" title="3.1 覆盖粒度"></a>3.1 覆盖粒度</h3><p>三种覆盖粒度：块覆盖、边覆盖、路径覆盖</p>
<p>典型的块覆盖方案会跟踪测试中每个块的击中次数。然而它不跟踪块的顺序，导致了覆盖信息的损失</p>
<p>典型的边覆盖跟踪每条边的击中次数，然而它同样不跟踪边的次序，同样导致了信息的损失。</p>
<p>路径覆盖方案会跟踪边的顺序，提供最完整的代码覆盖信息。然而代码路径非常长，且数量庞大，时间与空间开销难以承受，实际上不可行。一种优化方法是上下文敏感的边覆盖，能够跟踪部分函数调用顺序。这种方法有较高的性能开销和低效率。</p>
<p>边覆盖方案达到了性能的平衡。然而存在哈希碰撞的问题。CollAFL采用边覆盖跟踪策略解决了这一问题。</p>
<h3 id="3-2-哈希冲突的简单解决方案"><a href="#3-2-哈希冲突的简单解决方案" class="headerlink" title="3.2 哈希冲突的简单解决方案"></a>3.2 哈希冲突的简单解决方案</h3><p>直接解决方案是扩大哈希空间，即AFL中的位图大小，然而当前默认的位图大小(64KB)已经是一种性能上的折中</p>
<p>这种方法会带来性能上的大量损失。要减少5%的哈希碰撞，需要将位图大小从4KB扩大到4MB，导致60%执行速度上的损失。</p>
<h3 id="3-3-CollAFL的解决方案"><a href="#3-3-CollAFL的解决方案" class="headerlink" title="3.3 CollAFL的解决方案"></a>3.3 CollAFL的解决方案</h3><p>使用了一种新的哈希计算方式：</p>
<script type="math/tex; mode=display">
Fmul(cur,prev)=(cur>>x)\oplus(prev>>y)+z</script><p><x,y,z>是要确定的参数，对于不同的边可以不一样</x,y,z></p>
<p>如下图所示，对于每个末尾块，可以选择一系列参数</p>
<p>使用贪心算法逐个搜索每个块的参数</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230109141811234.png" class title="image-20230109141811234">
<p>这里还有些不明白）</p>
<h4 id="3-3-1-具有单一先例的块的哈希算法"><a href="#3-3-1-具有单一先例的块的哈希算法" class="headerlink" title="3.3.1 具有单一先例的块的哈希算法"></a>3.3.1 具有单一先例的块的哈希算法</h4><p>如果一个块只有一个先例，那么我们可以直接在末尾块给这条边分配一个哈希，而不是使用前面的计算公式进行计算。</p>
<p>因此，对于只有一个先例块A的块B，我们不需要寻找参数<x,y,z>，而可以使用下列的哈希算法</x,y,z></p>
<script type="math/tex; mode=display">
Fsingle(cur,prev):c</script><p>哈希值c硬编码于块B中。</p>
<p>实验表明，大部分应用超过60%的基础块只有一个先例块</p>
<h4 id="3-3-2具有多个先例的块的哈希算法"><a href="#3-3-2具有多个先例的块的哈希算法" class="headerlink" title="3.3.2具有多个先例的块的哈希算法"></a>3.3.2具有多个先例的块的哈希算法</h4><p>对于一个不可解的块B，我们引入另一个哈希算法来计算边A-&gt;B</p>
<script type="math/tex; mode=display">
Fhash(cur,prev):hash_table_lookup(cur,prev)</script><p>它构建了一个离线的Hash表，包含有所有以不可解的块为结尾的边的哈希。在运行时，他会查询这个预计算好的哈希表，使用他们的开始和结束块作为键来获取这些边的哈希。</p>
<p>Fhash是比Fmul和Fsingle慢很多的，因此要尽量限制不可解块的数量</p>
<p>至今还不明白的一个点：什么是solvable blocks，什么是unsolvable blocks）</p>
<p>使用贪心算法求解这些块的参数，将可解决的块标记为solvable blocks，其他即unsolvable</p>
<h4 id="3-3-3-整体优化方案"><a href="#3-3-3-整体优化方案" class="headerlink" title="3.3.3 整体优化方案"></a>3.3.3 整体优化方案</h4><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230109170043442.png" class title="image-20230109170043442">
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230109164706446.png" class title="image-20230109164706446">
<p>预处理程序。依靠静态分析工具，我们首先得到基本块和目标程序的先例信息。如第一行所示，首先可以获取程序的基本块BBS(basic blocks)，并根据这个块是否有多个先例把它分为两组SingleBBs和MultiBBS。在第二行，他给程序中每个块分配了随机密钥。分配信息存储于Keys中。</p>
<p>确定块算法。如第四行所示，我们首先尝试使用CalcFmul为有多个先例的块寻找适当的参数，并获取可解块集Solv和不可解块集Unsol以及可解块的参数Params和边的哈希Hashes。在第五行，我们使用CalcFash为不可解块Unsol构建了哈希图HashMap，并获取了未被任何边所使用的哈希集合FressHashes</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230109174441209.png" class title="image-20230109174441209">
<p>算法2展示了CalcFmul的工作流，即，如何搜寻含多个先例的块的参数。</p>
<p>（不懂：为什么不在生成哈希的时候就保存参数，而是全部生成完再一个个保存参数？）</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230111155430656.png" class title="image-20230111155430656">
<p>算法3展示了如何给不可解块构建哈希表。给每条以不可解块结尾的边选择随机未使用过的哈希，并存储在哈希表HashMap中。</p>
<h3 id="3-4表现分析"><a href="#3-4表现分析" class="headerlink" title="3.4表现分析"></a>3.4表现分析</h3><p>开销方面：</p>
<script type="math/tex; mode=display">
cost(Fhash)>cost(Fmul)>cost(Fsingle)\approx0</script><p>使用次数</p>
<script type="math/tex; mode=display">
num(Fsingle)>num(Fmul)>num(Fhash)\approx0</script><p>总的来说：CollAFL使用的哈希计算带来的总体性能成本很小</p>
<h3 id="3-5-实现细节"><a href="#3-5-实现细节" class="headerlink" title="3.5 实现细节"></a>3.5 实现细节</h3><h4 id="3-5-1-CollAFL-for-Applications-With-Source-Code"><a href="#3-5-1-CollAFL-for-Applications-With-Source-Code" class="headerlink" title="3.5.1 CollAFL for Applications With Source Code"></a>3.5.1 CollAFL for Applications With Source Code</h4><p>CollAFL扩展了AFL的llvm模式，并写了Clang链路时间优化传递来</p>
<ol>
<li>获取所需的基本块和边信息</li>
<li>给每个块分配密钥</li>
<li>根据每个基本块的类型解析哈希计算算法</li>
<li>用哈希计算和覆盖跟踪代码检测每个块</li>
</ol>
<p>在第一步，使用CLang默认实施获取后例和先例信息，例如。通过API llvm::TerminatorInst::getSuccessor.然而，离线解决间接控制转移的目标是一个公开的挑战，这会影响我们所需的先例信息的准确性。例如，它可能错误地将一些基本块分类为单个（或没有）先例块。</p>
<p>因此采取两步来改良。第一，将不被任何人直接调用的函数的入口块标记为多先例块。另外，将间接调用指令展开为一组直接调用和一个间接调用指令，类似于去虚拟化技术。因此能够连接基本块在一起，减少单先例的块，能够更多地使用Fmul而不是Fsingle来去计算块的哈希，减少碰撞的可能性。</p>
<p>(不懂：为啥要减少单先例的块，单先例的算法开销不是更小吗？)</p>
<h4 id="3-5-2-CollAFL-Bin-for-Binary-Applications"><a href="#3-5-2-CollAFL-Bin-for-Binary-Applications" class="headerlink" title="3.5.2 CollAFL-Bin for Binary Applications"></a>3.5.2 CollAFL-Bin for Binary Applications</h4><p>选择使用静态二进制检测来应用到边碰撞减少策略。</p>
<p>CollAFL-bin的综合检测过程如下：第一，使用API openBinary来加载二进制程序，并调用API getImage来获取程序镜像。然后通过API getModules获取所有模块，通过API getProcedures识别初始执行模块并获取所有函数。第二，遍历每个函数的所有基本块后获得CFG。有了CFG，就如有源码的CollAFL执行，即在没有冲突的情况下搜索相关的哈希id，并为每个基本块搜索各自的实施模式。最后，为三种实施模式创建调用函数。</p>
<p>静态分析中还有许多问题，间接跳转指令导致的不准确的控制流图….</p>
<p>识别潜在简介跳转和简介调用的目标，并分配保留的空闲HashID给这些潜在边。另外，给这些非返回函数修复了潜在返回边</p>
<p>解决二进制重写的问题，添加标签层</p>
<h2 id="4-Prioritize-Seed-Selection"><a href="#4-Prioritize-Seed-Selection" class="headerlink" title="4 Prioritize Seed Selection"></a>4 Prioritize Seed Selection</h2><p>直接驱动fuzzer到未探索的道路</p>
<ul>
<li>如果一条道路上上有很多未探索的邻近分支，那么这条道路的变异很可能能探索这些未探索的分支</li>
<li>如果一条道路上上有很多未探索的邻近后代，那么这条道路的变异很可能能探索这些未探索的后代</li>
</ul>
<p>提升漏洞发现的效率</p>
<ul>
<li>如果一条道路上有许多内存存储操作，很有可能能够触发潜在的内存破坏漏洞，变异策略同样。</li>
</ul>
<p>基于这些策略，提出以下种子选择策略</p>
<h3 id="4-1-Untouched-Neighbour-Branch-Guided-Policy"><a href="#4-1-Untouched-Neighbour-Branch-Guided-Policy" class="headerlink" title="4.1 Untouched-Neighbour-Branch Guided Policy"></a>4.1 Untouched-Neighbour-Branch Guided Policy</h3><p>能够探索更多为探索过的邻近分支的种子将会被赋予更高的优先级。将该策略称为CollAFL-br</p>
<p>将未探索的邻近边的数量成为测试例T的权重，函数IsUntouched返回1当且仅当边<bb;bb_i>没有被之前任何测试例覆盖</bb;bb_i></p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230114235220339.png" class title="image-20230114235220339">
<p>随着测试的进行，测试集也会发生变化，因此一个测试例的权重是动态的</p>
<h3 id="4-2-Untouched-Neighbour-Descendant-Guided-Policy"><a href="#4-2-Untouched-Neighbour-Descendant-Guided-Policy" class="headerlink" title="4.2 Untouched-Neighbour-Descendant Guided Policy"></a>4.2 Untouched-Neighbour-Descendant Guided Policy</h3><p>具有更多未探索的邻近后代会更有更高优先级，这种策略会具有更高优先级。这种策略称为CollAFL-desc</p>
<p>将未探索的邻近后代数量称为测试例T的权重</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115001249624.png" class title="image-20230115001249624">
<p>IsUntouched与前面相同，NumDesc返回从函数基本块开始的子路径，其正式定义如下：</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115001441249.png" class title="image-20230115001441249">
<p>基本块的子路径是确定的，可用静态分析计算</p>
<h3 id="4-3-Memory-Access-Guided-Policy"><a href="#4-3-Memory-Access-Guided-Policy" class="headerlink" title="4.3 Memory-Access Guided Policy"></a>4.3 Memory-Access Guided Policy</h3><p>记为CollAFL-mem，有更多内存读取操作的种子会具有更高优先级</p>
<p>将内存操作数量记为测试例T的权重：</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115003225973.png" class title="image-20230115003225973">
<p>函数NumMemInstr返回基本块内的内存操作数</p>
<h3 id="4-4-Implementation-Details"><a href="#4-4-Implementation-Details" class="headerlink" title="4.4 Implementation Details"></a>4.4 Implementation Details</h3><p>在运行时，首先检查测试用例的覆盖位图，并得到这个测试用例所覆盖的所有边和命中数。由于每个边都有不同的哈希值，我们可以从每个边的哈希值解码出它的开始和结束块。然后，对于每个块，我们将根据整体覆盖位图，得到其未触及的邻居分支的列表。加上已收集到的子路径和内存访问操作数，可以相应计算出三种策略的权重。</p>
<h2 id="5-Evaluation"><a href="#5-Evaluation" class="headerlink" title="5 Evaluation"></a>5 Evaluation</h2><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115111048707.png" class title="image-20230115111048707">
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115111053655.png" class title="image-20230115111053655">
<h3 id="5-1-Impact-of-Hash-Collision"><a href="#5-1-Impact-of-Hash-Collision" class="headerlink" title="5.1 Impact of Hash Collision"></a>5.1 Impact of Hash Collision</h3><h4 id="5-1-1-Prevalence-of-Hash-Collision"><a href="#5-1-1-Prevalence-of-Hash-Collision" class="headerlink" title="5.1.1 Prevalence of Hash Collision"></a>5.1.1 Prevalence of Hash Collision</h4><p>如表一所示，边碰撞比例非常高，与边的数量成正比。</p>
<p>原因在于，位图大小为64KB(65.5K bytes)，因此最多有65.5K条边存储于其中，这意味着无论使用什么哈希算法，194.5K(260K-65.5K)条边必须与其它边产生碰撞。</p>
<h4 id="5-1-2-Effectiveness-of-the-Trivial-Mitigation"><a href="#5-1-2-Effectiveness-of-the-Trivial-Mitigation" class="headerlink" title="5.1.2 Effectiveness of the Trivial Mitigation"></a>5.1.2 Effectiveness of the Trivial Mitigation</h4><p>这里主要指扩大位图的措施，能够减少碰撞，但降低了执行速度</p>
<p>测试软件越大，减少碰撞的效果越好</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115113021198.png" class title="image-20230115113021198">
<p>随着位图变大，执行速度下降</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115113031418.png" class title="image-20230115113031418">
<p>（一种想法：根据软件大小动态调节位图大小？）</p>
<h4 id="5-1-3-Effectiveness-of-CollAFL’s-Mitigation"><a href="#5-1-3-Effectiveness-of-CollAFL’s-Mitigation" class="headerlink" title="5.1.3 Effectiveness of CollAFL’s Mitigation"></a>5.1.3 Effectiveness of CollAFL’s Mitigation</h4><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115113323782.png" class title="image-20230115113323782">
<p>使用三种算法Fsingle，Fmul和Fhash来减少碰撞</p>
<p>表3展示了碰撞缓解的数据，平均而言，CollAFL比AFL少执行了2.93%的指令</p>
<p>CollAFL会适当地增大位图的大小(大于边的数量)，正如表三中所示，libtorrent在位图大小为64KB时，其碰撞率会升到74.84%</p>
<h3 id="5-2-Code-Coverage"><a href="#5-2-Code-Coverage" class="headerlink" title="5.2 Code Coverage"></a>5.2 Code Coverage</h3><h4 id="5-2-1-Total-Coverage-Improvement"><a href="#5-2-1-Total-Coverage-Improvement" class="headerlink" title="5.2.1 Total Coverage Improvement"></a>5.2.1 Total Coverage Improvement</h4><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115131457549.png" class title="image-20230115131457549">
<p>表四展示了不同fuzzers在200小时内探索11个应用的路径总数。与AFL相比，CollAFL(应用默认种子选择策略)平均能找到9.9%更多的路径,应用mem,desc,br策略平均能多找15.7%,17.23%,20.78%的路径；与AFLfast相比，采用默认策略可以多找8.45的路径。</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230115131628350.png" class title="image-20230115131628350">
<h4 id="5-2-2-Coverage-Growth-Over-Time"><a href="#5-2-2-Coverage-Growth-Over-Time" class="headerlink" title="5.2.2 Coverage Growth Over Time"></a>5.2.2 Coverage Growth Over Time</h4><p>附录的图7展示了200小时内的代码覆盖率增长情况。从增长趋势可以看出</p>
<ol>
<li>CollAFL和CollAFL-fast代码覆盖率增长的比AFL和AFL-fast快，说明碰撞缓解措施是有效的</li>
<li>CollAFL-br增长的比其他都快</li>
<li>AFLfast在路径发现方面并不总是比AFL表现好，一开始能够发现更多的路径，但后来被AFL追上了。说明用较长时间而非24小时来评估fuzzer的性能是值得的</li>
</ol>
<h3 id="5-3-Unique-Crashes"><a href="#5-3-Unique-Crashes" class="headerlink" title="5.3 Unique Crashes"></a>5.3 Unique Crashes</h3><p>比较了CollAFL、AFL、AFLfast发现不同冲突的效率</p>
<h4 id="5-3-1-Total-Crashes-Improvement"><a href="#5-3-1-Total-Crashes-Improvement" class="headerlink" title="5.3.1 Total Crashes Improvement"></a>5.3.1 Total Crashes Improvement</h4><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116011026204.png" class title="image-20230116011026204">
<p>上图展示了不同fuzzer在200小时内发现的11个应用的不同冲突，其中100%为基础线(平均效率)</p>
<h4 id="5-3-2-Crashes-Growth-Over-Time"><a href="#5-3-2-Crashes-Growth-Over-Time" class="headerlink" title="5.3.2 Crashes Growth Over Time"></a>5.3.2 Crashes Growth Over Time</h4><p>CollAFL-br,CollAFL-desc和CollAFL-mem在发现冲突方面展现了强劲的增长势头</p>
<h3 id="5-4-Vulnerablities"><a href="#5-4-Vulnerablities" class="headerlink" title="5.4 Vulnerablities"></a>5.4 Vulnerablities</h3><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116101955472.png" class title="image-20230116101955472">
<p>如表六所示，在200小时的检测中，发现了超过7500个独特的冲突，并确认了157个漏洞</p>
<p><em>冲突分类分析</em>。首先，利用开源工具afl-collect来消除重复的冲突。(它主要使用GDB插件exploitable)来计算每个崩溃backtrace的哈希值，根据哈希值来去除重复的崩溃。然后使用AddressSanitizer重新变异目标程序，使用去重后的冲突样本进行测试，AddressSanitizer随后可以报告这些崩溃的根本原因，并进一步去重。最后进行手动分析，确认了157个独特的漏洞。</p>
<p>值得注意的是，由于性能开销，我们只利用了AddressSanitizer来分类漏洞，并没有将它用在CollAFL，因此CollAFL有较好的执行速度，但却可能错失潜在的不会引起崩溃的漏洞。</p>
<h3 id="5-5-Randomness-Evaluation"><a href="#5-5-Randomness-Evaluation" class="headerlink" title="5.5 Randomness Evaluation"></a>5.5 Randomness Evaluation</h3><h4 id="5-5-1-Experiment-Setup"><a href="#5-5-1-Experiment-Setup" class="headerlink" title="5.5.1 Experiment Setup"></a>5.5.1 Experiment Setup</h4><p>设置了20次小型实验，每次在60小时内测试12个程序，总共测试了8个fuzzer</p>
<h4 id="5-5-2-Deviation-in-Path-Discovery-and-Crash-Findings"><a href="#5-5-2-Deviation-in-Path-Discovery-and-Crash-Findings" class="headerlink" title="5.5.2 Deviation in Path Discovery and Crash Findings"></a>5.5.2 Deviation in Path Discovery and Crash Findings</h4><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116111058626.png" class title="image-20230116111058626">
<p>RSD(relative standard deviation)</p>
<h4 id="5-5-3-Deviation-in-Vulnerability-Finding"><a href="#5-5-3-Deviation-in-Vulnerability-Finding" class="headerlink" title="5.5.3 Deviation in Vulnerability Finding"></a>5.5.3 Deviation in Vulnerability Finding</h4><p>漏洞发现的随机性&gt;冲突发现的随机性&gt;路径发现的随机性</p>
<p>检测方法：计算多少次实验可以找到一个特定的漏洞，以及这些实验用来找到这个漏洞的时间。表8为统计结果</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116111859677.png" class title="image-20230116111859677">
<h3 id="5-6-Comparision-Between-Fuzzers"><a href="#5-6-Comparision-Between-Fuzzers" class="headerlink" title="5.6 Comparision Between Fuzzers"></a>5.6 Comparision Between Fuzzers</h3><h4 id="5-6-1-Fuzzer-Settings"><a href="#5-6-1-Fuzzer-Settings" class="headerlink" title="5.6.1 Fuzzer Settings"></a>5.6.1 Fuzzer Settings</h4><h4 id="5-6-2-Vulnerability-Discovery"><a href="#5-6-2-Vulnerability-Discovery" class="headerlink" title="5.6.2 Vulnerability Discovery"></a>5.6.2 Vulnerability Discovery</h4><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116112617826.png" class title="image-20230116112617826">
<p>表9展示了fuzzer在20次实验中平均发现的漏洞数</p>
<h3 id="5-7-Evaluation-Results-On-Binary-Applications"><a href="#5-7-Evaluation-Results-On-Binary-Applications" class="headerlink" title="5.7 Evaluation Results On Binary Applications"></a>5.7 Evaluation Results On Binary Applications</h3><p>比较AFLdyinst和CollAFL-bin的表现。只使用二进制程序作为测试目标</p>
<h4 id="5-7-1-Code-Coverage"><a href="#5-7-1-Code-Coverage" class="headerlink" title="5.7.1 Code Coverage"></a>5.7.1 Code Coverage</h4><p>计算每个fuzzer运行10次，每次100小时所发现的平均路径和边。CollAFL-bin平均可以多覆盖7.9%的路径，2.7%的边，CollAFL-bin(br)可以多覆盖15%的路径和5.7%的边</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116120827813.png" class title="image-20230116120827813">
<h4 id="5-7-2-Bug-finding"><a href="#5-7-2-Bug-finding" class="headerlink" title="5.7.2 Bug finding"></a>5.7.2 Bug finding</h4><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116120921586.png" class title="image-20230116120921586">
<p>统计了每个fuzzer检测的冲突和漏洞总数。</p>
<h4 id="5-7-3-Negative-Impact-by-Imprecise-Binary-Analysis"><a href="#5-7-3-Negative-Impact-by-Imprecise-Binary-Analysis" class="headerlink" title="5.7.3 Negative Impact by Imprecise Binary Analysis"></a>5.7.3 Negative Impact by Imprecise Binary Analysis</h4><p>由于不精确的静态二进制分析，二进制版本CollAFL-bin表现得比源码版本CollAFL差。</p>
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116121522641.png" class title="image-20230116121522641">
<h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6 Conclusion"></a>6 Conclusion</h2><img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116121738173.png" class title="image-20230116121738173">
<img src="/2023/02/18/Path%20sensitive%20fuzzing%20for%20Native%20Application/image-20230116121747478.png" class title="image-20230116121747478"></div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-02-08  <a class="commentCountImg" href="/2023/02/08/HGAME2023WP/#comment-container"><span class="display-none-class">7beabc01a411c3118c3cc656e48ebf78</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="7beabc01a411c3118c3cc656e48ebf78">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>26 m  <i class="fas fa-pencil-alt"> </i>4.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/08/HGAME2023WP/">HGAME2023 Writeup</a></h1><div class="content"><p>太菜了还是，好多不会</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2023/02/08/HGAME2023WP/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2023-02-11T15:51:18.926Z"><i class="far fa-calendar-check"> Last Modified: </i>2023-02-11</time></div></div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-01-09  <a class="commentCountImg" href="/2023/01/09/HWS2023%20Winter%20Wp/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>27 m  <i class="fas fa-pencil-alt"> </i>4.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/09/HWS2023%20Winter%20Wp/"> </a></h1><div class="content"><h1 id="HWS2023-Winter-Wp"><a href="#HWS2023-Winter-Wp" class="headerlink" title="HWS2023 Winter Wp"></a>HWS2023 Winter Wp</h1><p>by CuratorJin</p></div><div class="index-category-tag">  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2023/01/09/HWS2023%20Winter%20Wp/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2023-01-19T03:57:56.969Z"><i class="far fa-calendar-check"> Last Modified: </i>2023-01-19</time></div></div></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-01-09  <a class="commentCountImg" href="/2023/01/09/%E5%A4%8D%E5%81%A5%E8%AE%AD%E7%BB%83/#comment-container"><span class="display-none-class">4c2ba5425c0c772b7004747ef95cddbc</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="4c2ba5425c0c772b7004747ef95cddbc">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>44 m  <i class="fas fa-pencil-alt"> </i>6.5 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/01/09/%E5%A4%8D%E5%81%A5%E8%AE%AD%E7%BB%83/">复健训练</a></h1><div class="content"><p>考完试了，写点题目练习一下，主要来自BUUOJ的近期比赛</p></div><div class="index-category-tag">  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/CTF/">CTF</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2023/01/09/%E5%A4%8D%E5%81%A5%E8%AE%AD%E7%BB%83/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2023-07-28T11:28:12.652Z"><i class="far fa-calendar-check"> Last Modified: </i>2023-07-28</time></div></div></div></article></div><!--!--><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/22a41709ffc26f62191d72a87ffbb342d46bfce3/img/icon.jpg?raw=true" alt="Curator-Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Curator-Kim</p><p class="is-size-6 is-block">寻几处好景破星光</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>火星</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">40</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/curator-kim"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="/804242129@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"From《"+data.from+"》</p><p>Provider-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-03T12:54:33.000Z">2023-08-03</time></p><p class="title"><a href="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/">加密与解密(一)</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-03T12:52:28.140Z">2023-08-03</time></p><p class="title"><a href="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-04T14:44:21.000Z">2023-07-04</time></p><p class="title"><a href="/2023/07/04/CrackMe%E7%B3%BB%E5%88%97/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-30T04:35:30.000Z">2023-06-30</time></p><p class="title"><a href="/2023/06/30/FirmFuzz/">Firm-Fuzz</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-28T07:53:04.000Z">2023-04-28</time></p><p class="title"><a href="/2023/04/28/BUAACTF2023/"> </a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/04/"><span class="level-start"><span class="level-item">April 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><span class="tag">汇编语言</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Crypto/"><span class="tag">Crypto</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctf/"><span class="tag">ctf</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pwn/"><span class="tag">pwn</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CopperSmith/"><span class="tag">CopperSmith</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DES/"><span class="tag">DES</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HWS/"><span class="tag">HWS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NTRU/"><span class="tag">NTRU</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RE/"><span class="tag">RE</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reverse/"><span class="tag">Reverse</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angr/"><span class="tag">angr</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"><span class="tag">加密与解密</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"><span class="tag">参考资料</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><span class="tag">论文阅读</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"><span class="tag">预备知识</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/logo.png?raw=true" alt="Curator-Kim的小站" height="28"></a><p class="size-small"><span>&copy; 2023 Curator-Kim</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">粤ICP备88888888号-8（测试）</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️Site from <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> has existed <strong>" + dnum + "</strong> d <strong>" + hnum + "</strong> h <strong>" + mnum + "</strong> m <strong>" + snum + "</strong> s！❤️";
        }var now = new Date();setInterval("createTime('2022/1/21 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️Thx <strong><span id="busuanzi_value_site_uv">99+</span></strong> users <strong><span id="busuanzi_value_site_pv">99+</span></strong> visited！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="137510737" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','Curator-Kim','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','Curator-Kim','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>