{"pages":[{"title":"board","text":"","link":"/board/index.html"}],"posts":[{"title":"1.22刷题记录","text":"1.22 刷题记录摸了好久的鱼了，现在属于是康复训练 testre 2019西湖论剑预选赛拖进ida后第一件事——shift+f12查看字符串 发现base64和base58的码表 随后进入主函数 其中sub_400D00函数只是读取字符串而已，继续查看sub_400700函数 开始时对输入的字符串进行了一次加密，但随后发现加密后的字符串并没有用到 中间进行了一些没有意义的循环和计算 随后就是对输入的字符串分别进行了base58和base64编码 但其实进行比较的是经过base58编码后的字符串 提取比较的字符串：D9cS9N9iHjMLTdA8YSMRMp，进行base58解码即得到flag：base58_is_boring","link":"/2022/01/21/1-22%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"BUUOJ Reverse(1)","text":"[CFI-CTF 2018]IntroToPE直接扔IDA，发现无法F5，转而查看汇编代码 在此处发现奇怪的Base64字符串，解码后得到flag:CFI{.NetC#_1s_@w3s0m3} [WUSTCTF2020]funnyre拖进ida分析 点进main函数，发现无法反编译为c代码，继续看汇编指令 发现有奇怪的指令，有几条jz、jnz和call指令都指向了不存在的地址，导致了F5的失败 将它们还有下面的几处都nop掉，再p一下得到了能看的c代码 一千多行，不是人能做的，寄！ 上网进行一个大佬的题解代码的抄，顺便了解了一下啥是符号执行（虽然还是不太懂 12345678910111213141516171819202122232425import angrimport claripyp=angr.Project('C:\\\\Users\\\\80424\\\\Downloads\\\\attachment',load_options={&quot;auto_load_libs&quot;: False})f=p.factorystate = f.entry_state(addr=0x400605)#设置state开始运行时的地址flag = claripy.BVS('flag',8*32)#要求的内容有32个，用BVS转成二进制给flag变量state.memory.store(0x603055+0x300+5,flag)#因为程序没有输入，所以直接把字符串设置到内存state.regs.rdx=0x603055+0x300state.regs.rdi=0x603055+0x300+5#然后设置两个寄存器sm = p.factory.simulation_manager(state)#准备从state开始遍历路径print(&quot;开始执行&quot;)sm.explore(find=0x401DAE)#遍历到成功的地址if sm.found: print(&quot;执行成功&quot;) x=sm.found[0].solver.eval(flag,cast_to=bytes) print(x)else: print('错误') 得到flag:flag{1dc20f6e3d497d15cef47d9a66d6f1af} 最后附上符号执行的相关资料： 5.3 符号执行 · CTF All In One (gitbooks.io) [羊城杯 2020]login下载附件，可以发现是python逆向题 使用pyinstxtractor整出.pyc文件 在解压出来的文件中发现login.pyc文件，使用010editor打开 打开struct.pyc文件，用该文件的前8字节替换login.pyc的前8字节，替换后的login.pyc文件如下 然后在线反编译pyc文件，得到login.py的代码 python反编译 - 在线工具 (tool.lu) 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationimport sysinput1 = input('input something:')if len(input1) != 14: print('Wrong length!') sys.exit()code = []for i in range(13): code.append(ord(input1[i]) ^ ord(input1[i + 1]))code.append(ord(input1[13]))a1 = code[2]a2 = code[1]a3 = code[0]a4 = code[3]a5 = code[4]a6 = code[5]a7 = code[6]a8 = code[7]a9 = code[9]a10 = code[8]a11 = code[10]a12 = code[11]a13 = code[12]a14 = code[13]if ((((a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5) + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36) + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60) + a14 * 29 == 22748) &amp; ((((a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25) + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66) + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39) + a14 * 17 == 7258) &amp; ((((a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65) + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33) + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34) + a14 * 23 == 26190) &amp; ((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 == 37136) &amp; (((a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52) + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36) + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; ((((a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45) + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26) + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61) + a14 * 28 == 17298) &amp; ((((a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42) + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47) + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44) + a14 * 65 == 19875) &amp; (((a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85) + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30) + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; ((((a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85) + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36) + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64) + a14 * 27 == 9710) &amp; (((((a1 * 67 - a2 * 68) + a3 * 68 - a4 * 51 - a5 * 43) + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38) + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52) + a14 * 31 == 13376) &amp; ((((a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51) + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6) + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67) + a14 * 78 == 24065) &amp; ((((a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5) + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35) + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61) + a14 * 20 == 27687) &amp; (((a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25) + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92) + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (((a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43) + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36) + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317): print('flag is GWHT{md5(your_input)}') print('Congratulations and have fun!')else: print('Sorry,plz try again...') 然后就是解方程 1234567891011121314151617181920212223242526272829303132from sympy import *import hashliba1=symbols('a1')a2=symbols('a2')a3=symbols('a3')a4=symbols('a4')a5=symbols('a5')a6=symbols('a6')a7=symbols('a7')a8=symbols('a8')a9=symbols('a9')a10=symbols('a10')a11=symbols('a11')a12=symbols('a12')a13=symbols('a13')a14=symbols('a14')print(solve([((((a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5) + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36) + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60) + a14 * 29 - 22748), ((((a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25) + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66) + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39) + a14 * 17 - 7258) ,((((a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65) + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33) + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34) + a14 * 23 - 26190) ,((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 * pow(2,7)) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 - 37136) ,(((a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52) + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36) + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 - 27915) ,((((a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45) + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26) + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61) + a14 * 28 - 17298) ,((((a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42) + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47) + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44) + a14 * 65 - 19875) ,(((a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85) + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30) + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 - 22784) ,((((a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85) + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36) + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64) + a14 * 27 - 9710) ,(((((a1 * 67 - a2 * 68) + a3 * 68 - a4 * 51 - a5 * 43) + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38) + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52) + a14 * 31 - 13376) ,((((a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51) + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6) + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67) + a14 * 78 - 24065) ,((((a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5) + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35) + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61) + a14 * 20 - 27687) ,(((a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25) + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92) + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 - 29250) ,(((a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43) + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36) + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 - 15317)],[a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14])) 得到结果：{a1: 119, a2: 24, a3: 10, a4: 7, a5: 104, a6: 43, a7: 28, a8: 91, a9: 52, a10: 108, a11: 88, a12: 74, a13: 88, a14: 33} 由于原输入和$a_i$ 不是一一对应的，需要稍微调整一下，然后在进行一个异或，最后md5一下就出来Flag了 12345678910111213import hashlibinput1=[10,24,119,7,104,43,28,91,108,52,88,74,88,33]for i in range(12,-1,-1): input1[i]^=input1[i+1]print(input1)flag=''for i in input1: flag+=chr(i)print(flag)print(len(flag))h=hashlib.md5()h.update(flag.encode())print(h.hexdigest()) flag{58964088b637e50d3a22b9510c1d1ef8}","link":"/2022/01/28/BUUOJ-Reverse-1/"},{"title":"WriteUp of DASCTF Jan Crypto","text":"Writeup of DasCTF Jan Crypto[签到题]babyRSA附件一：chall.py 12345678910111213141516171819202122232425262728import osfrom secret import FLAG,p,q,efrom Crypto.Util.number import bytes_to_long,long_to_bytesN = p*qdef encrypt(m,N,e): return pow(m,e,N)def decrypt(c,N,d): return pow(c,d,N)def padding(msg): res = msg if len(res) &lt; 128: res = res + os.urandom(128-len(res)) return resdef transfer(msg): assert len(msg) &lt; 128 m = padding(msg) return bytes_to_long(m)if __name__ == &quot;__main__&quot;: m = transfer(FLAG) print(N,e) print(encrypt(m,N,e)) 附件二 enc 1213123058934861171416713230498081453101147538789122070079961388806126697916963123413431108069961369055630747412550900239402710827847917960870358653962948282381351741121884528399369764530446509936240262290248305226552117100584726616255292963971141510518678552679033220315246377746270515853987903184512948801397452104554589803725619076066339968999308910127885089547678968793196148780382182445270838659078189316664538631875879022325427220682805580410213245364855569367702919157881367085677283124732874621569379901272662162025780608669577546548333274766058755786449491277002349918598971841605936268030140638579388226573929 21993444050767187234397761068183914169867746374174528181624770259579762134771917236641844074172347938149264183669057516897896991381236582927189515470739382448359233781032645742623198680727921871297555706961277968561362798136589237779330699241398622219476279693304507357580915558995515876051755678822535656131639723966406639590483110776910457915166718570203793342171416518556587956147610696870291406014395979782033752442433430526874886065448561168276810654141879579560499471430173054832001220333438573702236782364698874212615929305491367081600410014383502275942657148007530729391264646477039622603589304775707984208771492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524 看完附件后可以知道是比较简单的RSA类型 一开始看到e这么大便想到了维纳攻击，可是试了一下并没有解出d（还怀疑了一下脚本是不是出错了） 而后试了一下用yafu进行大数分解，并没有结果 最后还是得靠factordb.com(事实证明还是在线大数分解nb) 解出 12n=98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033*133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513 随后就可以随便算了 1234567891011from libnum import n2simport gmpy2p=133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513q=98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033e=2199344405076718723439776106818391416986774637417452818162477025957976213477191723664184407417234793814926418366905751689789699138123658292718951547073938244835923378103264574262319868072792187129755570696127796856136279813658923777933069924139862221947627969330450735758091555899551587605175567882253565613163972396640663959048311077691045791516671857020379334217141651855658795614761069687029140601439597978203375244243343052687488606544856116827681065414187957956049947143017305483200122033343857370223678236469887421261592930549136708160041001438350227594265714800753072939126464647703962260358930477570798420877c=1492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)flag=pow(c,d,p)# print(flag)print(n2s(73358773651424897743944056106548202261075477721417992498861765573582087801960732601862778348189621203820703393958329215404058952130344307891818721974239491062466090539708313506265450891835557762707471433442189955809731728025144732654599245515720346423528093783755219533095697004480866822694256749445957788813)) 最终得到flag:hwctf{01d_Curs3_c4Me_Again} crypto_Elgamal题目代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from Crypto.Util.number import *from key import FLAGdef keygen(size): q = getPrime(80) k = getPrime(944) while True: p = q * k + 1 if isPrime(p): break k += 1 g = 2 while True: if pow(g, q, p) == 1: break g += 1 A = getRandomInteger(size) % q B = getRandomInteger(size) % q x = getRandomInteger(size) % q h = pow(g, x, p) return (g, h, A, B, p, q), (x)def rand(A, B, q): global rand_state rand_state, ret = (A * rand_state + B) % q, rand_state return retdef encrypt(pubkey, m): g, h, A, B, p, q = pubkey assert 0 &lt; m &lt;= p r = rand(A, B, q) c1 = pow(g, r, p) c2 = (m * pow(h, r, p)) % p return (c1, c2)rand_state = getPrime(1024)pubkey, privkey = keygen(1024)m = bytes_to_long(FLAG)c1, c2 = encrypt(pubkey, m)c1_, c2_ = encrypt(pubkey, m)print(c1, c2)print(c1_, c2_)s0 = 543263588863771657634119s1 = 628899245716105951093835s2 = 78708024695487418261582s3 = 598971435111109998816796s4 = 789474285039501272453373assert ( A * s0 + B ) % q == s1assert ( A * s1 + B ) % q == s2assert ( A * s2 + B ) % q == s3assert ( A * s3 + B ) % q == s4p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311g = 27642593390439430783453736408814717946185190497201679721975757020767271070510268596627490205095779429964809833535285315202625851326460572368018875381603399143376574281200028337681552876140857556460885848491160812604549770668188783258592940823128376128198726254875984002214053523752696104568469730021811399216h = 54585833166051670245656045196940486576634589000609010947618047461787934106392112227019662788387352615714332234871251868259282522817042504587428441746855906297390193418159792477477443129333707197013251839952389651332058368911829464978546505729530760951698134101053626585254469108630886768357270544236516534904c1 = 60724920570148295800083597588524297283595971970237964464679084640302395172192639331196385150232229004030419122038089044697951208850497923486467859070476427472465291810423905736825272208842988090394035980454248119048131354993356125895595138979611664707727518852984351599604226889848831071126576874892808080133c2 = 48616294792900599931167965577794374684760165574922600262773518630884983374432147726140430372696876107933565006549344582099592376234783044818320678499613925823621554608542446585829308488452057340023780821973913517239972817669309837103043456714481646128392677624092659929248296869048674230341175765084122344264c1_ = 42875731538109170678735196002365281622531058597803022779529275736483962610547258618168523955709341579773947887175626960699426438456382655370090748369934296474999389316334717699127421889816721511602392591677377678759026657582648354688447456509292302633971842316239774410380221303269351351929586256938787054867c2_ = 64829024929257668640929285124747107162970460545535885047576569803424908055130477684809317765011143527867645692710091307694839524199204611328374569742391489915929451079830143261799375621377093290249652912850024319433129432676683899459510155157108727860920017105870104383111111395351496171846620163716404148070 （分析不难，关键在于转化为RSA问题后对e和p-1不互素情况下根的求解） 粗略分析一下，发现有对同一flag加密得到的两组密文，而这两组密文的联系是随机数r1和r2。因此可以断定从伪随机数发生器入手，对密文组(c1,c2)，(c1_ , c2_ )进行变换从而得到flag(由于密钥x为止因此基本可以忽略c1和c1_) 而对于伪随机数发生器，题目也给了相应的提示： 12345678910s0 = 543263588863771657634119s1 = 628899245716105951093835s2 = 78708024695487418261582s3 = 598971435111109998816796s4 = 789474285039501272453373assert ( A * s0 + B ) % q == s1assert ( A * s1 + B ) % q == s2assert ( A * s2 + B ) % q == s3assert ( A * s3 + B ) % q == s4 线性方程组乱解一通后便得到了： 123q= 791763770658839585424113A=12742153496769814072597B=3035433788765894539799 接下来分析c2和c2_的关系，已c_2=m*h^{r_1}\\ mod\\ p,c_2\\_=m*h^{r_2}\\ mod\\ p，而r_2=r_1*A+B\\ mod\\ p 即： c_2\\_=m*h^{r_1*A+B}=m*h^{r_1*A}*h^B=m^{1-A}*(m*h^{r_1})^A*h^B=c_2^A*m^{1-A}*h^B\\ mod\\ p因此： m^{1-A}=c_2\\_*c_2^{-A}*h^{-B}\\ mod\\ p由此即可以得到$m^{1-A}\\ mod\\ p$的值，现在已经将Elgamal问题转换为加密指数e=1-A的类RSA问题了 问题棘手的地方在于$gcd(1-A,p-1)=7438$,无法直接对1-A求逆 接下来的解决方法可以参考这题：NCTF2019 easyRSA (附上写的非常详细的wpNCTF2019-官方writeup – 郁离歌丶的博客 (yulige.top))（接下来我都建议去看这篇wp） 实际上在$gcd(1-A,p-1)=e$的情况下，$m$有$e$个解 首先先尝试得到其中一个解： 详细方法和情形可以参考这篇paper1111.4877.pdf (arxiv.org) 快速定位到此处： 通过这个算法能找到方程其中的一个解 那么如何找到所有解呢？ 观察 x^{p-1}=1\\ mod\\ p\\\\ (x^{\\frac{p-1}{e}})^e=1\\ mod\\ p也就是说，若$r$是方程$x^e=c\\ mod\\ p$的一个解，那么 r^e=c\\ mod\\ p\\\\ (r*x^{i*\\frac{p-1}{e}})^e=r^e*x^{i*(p-1)}=r^e*1^i=c\\ mod\\ p(r*x^{i*\\frac{p-1}{e}})也是方程的解，其中$x$为$(1,p-1)$的一个随机数，$i \\in [0,e-1]$， 遍历$i$，既可以得到方程的所有解，最后在所有解中搜索符合字符串’flag’即可得到flag:flag{19e9f185e6a680324cedd6e6d9382743} （应该是没错的，写完的时候比赛已经结束了 /(ㄒoㄒ)/~~） 附上解方程的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import randomfrom libnum import n2simport sympydef rth_root(cip,r,q): &quot;&quot;&quot; cip^r==q &amp;&amp; r|q-1 &quot;&quot;&quot; rnum=random.randint(1,q) while (pow(rnum,(q-1)//r,q)==1): rnum=random.randint(1,q) t=1 while((q-1)%pow(r,t)==0): t+=1 t-=1 s=(q-1)//pow(r,t) k = 1 while (k * s + 1) % r != 0: k += 1 alpha = (k * s + 1) // r a=pow(rnum,pow(r,t-1)*s,q) b=pow(cip,r*alpha-1,q) c=pow(rnum,s,q) h=1 print('t='+str(t)) for i in range(1,t): # print('1213') d=pow(b,pow(r,t-1-i),q) if d==1: j=0 else: j=(-sympy.discrete_log(q,d,a))%q b=b*(pow(pow(c,r,q),j,q))%q h=h*pow(c,j,q)%q c=pow(c,r,q)%q return pow(cip,alpha,q)*h%qdef findAllPRoot(root,p,e): maySolve=[root] while(len(maySolve)&lt;e): maySolve.append(root*pow(random.randint(2,p-1),(p-1)//e,p)%p) print('finish') return maySolveflag=52498780852251471256496883766677451330444042209592264044862955792645421608045437240170037309824495794108442986910150817628974914953272047997425815789167047966004466233826304133412591056777880709534691777621768967479001867448270089911182059438848229977940628161790899565867768072121376211486485752798175076955e=7438p = 65211247300401312530078141569304950676358489059623557848188896752173856845051471066071652073612337629832155846984721797768267868868902023383604553319793550396610085424563231688918357710337401138108050205457200940158475922063279384491022916790549837379548978141370347556053597178221402425212594060342213485311r=rth_root(flag,e,p)print(r)print(pow(r,e,p)==flag)maySolve=findAllPRoot(r,p,e)# x=random.randint(1,p)# solve2=r*pow(x,(p-1)//e,p)%p# print(solve2)# print(pow(solve2,e,p)==flag)print('start')file=open('111.txt','wb')for i in maySolve: file.write(n2s(i)) （写得比较乱，如有错漏还请客官指出）","link":"/2022/01/25/Writeup-of-DASCTF2022-Jan-Crypto2/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/19/hello-world/"},{"title":"一些不错的技术文章（持续更新）","text":"C语言相关 C语言函数调用栈（一）C语言函数调用栈(一) - clover_toeic - 博客园 (cnblogs.com) C语言函数调用栈（二）C语言函数调用栈(二) - clover_toeic - 博客园 (cnblogs.com) 工具学习待分类","link":"/2022/02/03/%E4%B8%80%E4%BA%9B%E4%B8%8D%E9%94%99%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"},{"title":"堆栈平衡","text":"参考：堆栈平衡 - cat47 - 博客园 (cnblogs.com) （本篇其实也就搬运了一下） 什么是堆栈平衡 如果要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RET这条指令前,ESP指向的是我们压入栈中的地址 如果通过堆栈传递参数来，那么在函数执行完毕后，要平衡参数导致的堆栈变化 含义就是当函数在一步步执行的时候一直到ret执行之前，堆栈栈顶的地址一定要是call指令的下一个地址。 如果堆栈变化了，就要走ret执行前将堆栈恢复成原来的样子 会影响堆栈的情况1. 函数中push进栈例如： 1234call xx函数函数： mov ...(不影响堆栈平衡) push ...(影响堆栈平衡) ret... 2. 堆栈传递参数函数调用时传递参数通过向栈中压入参数完成，在被调用函数完成后该传递的参数也就失去了作用，需要将堆栈恢复到调用前的位置，例如： 主函数： 被调用函数： 堆栈如下： 解决方法1. 在函数外部调整栈顶地址使用add指令，对esp寄存器进行操作 2. 在函数内部添加 ret 8 是把ret和把第一种情况的add两条指令整合成一条指令，在函数内部完成堆栈平衡。","link":"/2022/02/03/%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1/"},{"title":"汇编语言(2) 第一个程序","text":"还是只想摸鱼 4.1 一个源程序从写出到执行的过程 编写汇编源程序 对源程序进行编译链接 执行可执行文件中的程序 4.2 源程序12345678910111213assume cs:codesgcodesg segment mov ax,0123H mov bx,0456H add ax,bx add ax,ax mov ax,4c00H int 21Hcodesg endsend 1、伪指令汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。 伪指令没有对应的机器指令，最终不被CPU执行，而是由编译器执行来进行相关的编译工作。 XXX segment … XXX ends segment和ends是一对成对使用的伪指令，其功能为定义一个段，一个段还必须有一个名称来标识 end end是一个汇编程序的结束标记。编译器在编译汇编程序过程中，若碰到伪指令end，则结束对源程序的编译。 （注意区分end和ends） assume assume假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。 2、程序返回一个程序结束后，需要将CPU的控制权返还给使它运行的程序。 相关指令： 12mov ax,4c00Hint 21H 4.3 编辑源程序4.4 编译通过运行masm编译.asm文件生成.obj文件 4.5 连接运行line.exe，将上一步生成的.obj文件进行连接，生成可执行的.exe文件 连接的作用： Summary DOS系统中.EXE文件中程序的加载过程","link":"/2022/01/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"},{"title":"汇编语言（1）寄存器（内存访问）","text":"最近只想摸鱼 3.1 内存中字的存储 字单元，即存放一个字形数据（16位）的内存单元，有两个地址连续的内存单元组成。 图中字形数据4E20H的低位字节存放在0号单元中，高位字节存放在1号单元中 （在这里复习下大端存储和小段存储：) 大端存储：数据的低位保存在内存中的高地址中，数据的高位保存在内存的低地址中 小端存储：数据的高位保存在内存中的高地址中，数据的低位保存在内存的低地址中 3.2 DS和[address]8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。 比如要读取10000H单元的内容，可用如下程序段进行： 123mov bx,1000Hmov ds,bxmov a1,[0] “[…]”表示一个内存单元，其中的0表示偏移地址。 另：8086CPU不支持直接将数据送入段寄存器，即不能直接：mov ds,1000H。需要一个寄存器进行中继的操作。 3.7 栈在内存中划出一段空间当作栈使用，栈的地址存放在寄存器SS中，寄存器SP则指向栈顶的位置。因此，任意时刻，SS:SP指向栈顶元素。 push指令：1push ax 这段指令的意义为将寄存器ax的值压入栈中，有以下两步完成： pop指令1pop ax 这段指令的意义为将栈顶的值赋给ax，有以下两步完成： 值得注意的是，pop操作后，1000CH处的2266H仍存在，尽管它已不在栈中。当有新的元素Push入栈时，则会在上面覆写新的数据。 栈空的状态 3.8 栈越界8086CPU不保证我们对栈的操作不会越界 3.10 栈段 答案：SP=0。（寄存器SP只能存储16位的数据，因此需要模2^16。假设pop一个元素，SP-=2，SP=FFFEH） 总结：​ 一段内存，是代码段，还是数据存储空间，还是栈空间，取决于寄存器中CS、IP、SS、SP、DS的指向。 ​ CS:IP指向的地方位代码段，SS:SP指向的地方为栈空间，DS存放数据段地址。 附上一段代码，此处说明了一段内存既可以是代码段，可以是数据的存储空间，也可以是栈空间：","link":"/2022/01/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%881%EF%BC%89%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/"},{"title":"汇编语言（3） [BX]和loop指令","text":"摸鱼才是正义！ 5.0 前置定义[bx]是什么[bx]和[0]类似，表示内存中的偏移地址，不同的是[bx]中的偏移地址存放在bx寄存器中，如下面的指令： 1mov ax,[bx] 表示将一个内存单元的内容送入ax，这个内存单元的长度为2字节，段地址在寄存器ds中，偏移地址在bx中。 loop循环 书中定义的描述性符号：“()”书中使用“()”来表示一个寄存器或一个内存单元中的内容，”()“中的内容可以有3中类型：①寄存器名 ② 段寄存器名 ③ 内存单元的物理地址。比如： (ax)表示ax中的内容、(al)表示al中的内容、(20000H)表示内存20000H单元的内容 约定符号idata表示常量1mov ax,[idata] 可以表示 mov ax,[1]、mov ax,[2]等 5.1 [BX]5.2 LoopCPU执行loop指令时，要进行两步操作： (cx)=(cx)-1 判断cx中的值，不为零则转至标号处执行程序，为零则向下执行 以计算2^12的值为例进行分析 1234567891011assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21hcode endsend 代码中有一个标号s，实际上它标识了一个地址，该地址处有一条指令： add ax,ax 用cx和loop指令配合实现循环功能的程序框架如下： 1234mov cx,循环次数s: 循环执行的程序段 loop s 5.4 Debug和汇编编译器masm对指令的不同处理对于如下指令，debug和masm有不同的处理： 1mov ax,[0] debug中表示将ds:0的数据送入ax中 masm则将其当作指令 “mov ax,0”处理 那么如何在源程序中将ds:0的内存送入al中？ 将偏移地址送入bx中，用[bx]的方式访问内存单元（比较麻烦） 在”[]”前显式给出地址所在的段寄存器，如访问2000：0单元： 123mov ax,2000hmov ds,axmov al,ds:[0] 5.5 loop和[bx]的联合应用在实际中，需要用循环处理地址连续的内存单元中的数据的问题，此时可应用“mov al,[bx]”，通过改变bx中的数值，改变访问的内存单元 5.6 段前缀可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器，如 1234mov ax,ds:[bx] 或mov ax,cs:[bx] 或mov ax,ss:[bx]... 5.7 一段安全的空间在不能确定一段内存空间是否存放着重要的数据或代码时，不能随意向其中写入内容 DOS方式下，一般情况，0:200~0:2ff这段空间没有系统或其他程序的数据或代码 5.8 段前缀的使用附：实验4 [bx]和loop的使用 编程，向内存0:200~0:23f依次传送数据0~63(3FH) 12345678910111213141516ASSUME CS:CODECODE segment mov ax,0 mov ds,ax mov cx,64 mov bx,200hs: mov [bx],ax inc ax inc bx loop s mov ax,4c00h int 21hcode endsend 编程，向内存0:200~0:23f依次传送数据0~63(3FH)，程序中只能使用9条指令，9条指令中包括”mov ax,4c00h”和”int 21h” 123456789101112131415ASSUME CS:CODECODE segment mov ax,20 mov ds,ax mov cx,63 mov bx,0hs: mov [bx],bx inc bx loop s mov ax,4c00h int 21hcode endsend 下面程序的功能是将 “mov ax,4c00h”之前的指令复制到内存 12345678910111213141516ASSUME CS:CODEcode segment mov ax,CS mov ds,ax mov ax,0020h mov es,ax mov bx,0 mov cx,17hs: mov al,[bx] mov es:[bx],al inc bx loop s mov ax,4c00h int 21hcode endsend （17h是先设定一个值，到debug中看内存中程序的长度才得到的） 如有错误，还望指正","link":"/2022/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%883%EF%BC%89-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"}],"tags":[{"name":"RE","slug":"RE","link":"/tags/RE/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"Crypto","slug":"Crypto","link":"/tags/Crypto/"},{"name":"参考资料","slug":"参考资料","link":"/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"name":"预备知识","slug":"预备知识","link":"/tags/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"}],"categories":[]}