<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Curator-Kim的小站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Curator-Kim的小站"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Curator-Kim的小站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="A Survey of Symbolic Execution Techniques"><meta property="og:type" content="blog"><meta property="og:title" content="Curator-Kim"><meta property="og:url" content="https://curator-kim.github.io/"><meta property="og:site_name" content="Curator-Kim"><meta property="og:description" content="A Survey of Symbolic Execution Techniques"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://curator-kim.github.io/img/icon.jpg"><meta property="article:published_time" content="2023-08-03T12:52:28.140Z"><meta property="article:modified_time" content="2023-08-03T13:00:15.875Z"><meta property="article:author" content="Curator-Kim"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/icon.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/"},"headline":"Curator-Kim的小站","image":["http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230712004756091.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230721181522403.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113719498.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113726255.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113733535.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230724111514733.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230724180939130.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230725180826998.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230727010130477.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230731105753547.png","http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230802111743884.png"],"datePublished":"2023-08-03T12:52:28.140Z","dateModified":"2023-08-03T13:00:15.875Z","author":{"@type":"Person","name":"Curator-Kim"},"description":"A Survey of Symbolic Execution Techniques"}</script><link rel="canonical" href="http://curator-kim.github.io/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/logo.png?raw=true" alt="Curator-Kim的小站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/album">Album</a><a class="navbar-item" href="/friend">Friend</a><a class="navbar-item" href="/message">Message</a><a class="navbar-item" href="/self-talking">Self-talking</a><a class="navbar-item" href="/music">Music</a><a class="navbar-item" href="/media">Media</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-08-03  <a class="commentCountImg" href="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 h  <i class="fas fa-pencil-alt"> </i>21.0 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile"> </h1><div class="content"><h1 id="A-Survey-of-Symbolic-Execution-Techniques"><a href="#A-Survey-of-Symbolic-Execution-Techniques" class="headerlink" title="A Survey of Symbolic Execution Techniques"></a>A Survey of Symbolic Execution Techniques</h1><span id="more"></span>
<h2 id="Introduction，"><a href="#Introduction，" class="headerlink" title="Introduction，"></a>Introduction，</h2><p>符号执行——程序分析技术，测试软件是否会违反某种规则，例如除零、引用不存在的指针、后门…</p>
<p>关键思想：允许程序采用符号输入值，而非具体输入值。执行由符号执行引擎完成，该引擎维护每条已探索的控制流路径：(i)一阶布尔公式，用于描述沿该路径执行的分支所满足的条件；(ii)符号存储，用于将变量映射为符号表达式或值。分支执行更新公式，而赋值更新符号存储  |  模型检查器通常基于可满足性模态理论（SMT）求解器，最终用于验证每条探索路径是否存在违反属性的情况，以及路径本身是否可实现，即其公式是否可以通过对程序符号参数的具体值赋值来满足。(即条件方程是否有具体解？)</p>
<h3 id="1-1-A-Warm-Up-Example"><a href="#1-1-A-Warm-Up-Example" class="headerlink" title="1.1 A Warm-Up Example"></a>1.1 A Warm-Up Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(a != <span class="number">0</span>)&#123;</span><br><span class="line">		y=<span class="number">3</span>+x;</span><br><span class="line">		<span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">			x = <span class="number">2</span>*(a+b);</span><br><span class="line">	&#125;</span><br><span class="line">	assert(x - y != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单纯随机生成的输入难以让assert断言失败，但通过符号执行可以获取满足这一要求的输入类</p>
<p>更具体地说，每一个变量(如函数参数、系统调用的返回值)都被符号如$\alpha$所代替</p>
<p>在任何时刻，符号执行引擎保持状态$(stmt,\sigma,\pi)$</p>
<ul>
<li>stmt 是下一个要评估的语句(指令？)，目前可假设stmt是赋值、条件分支或跳转(call 和 loops等更复杂的在下节讨论)</li>
<li>$\sigma$是一个符号存储，将程序变量与具体值上的表达式或符号值$\alpha_i$相关联</li>
<li>$\pi$表示路径约束，即要到达stmt的分支$\alpha_i$所要满足的一组假设。在分析开始时，$\pi$=true</li>
</ul>
<p>根据stmt，符号引擎按以下改变状态</p>
<ul>
<li>x=e的复制会通过将x与符号表达$e_s$更新内存$\sigma$.使用$x→e_s$记这种关联，其中$e_s$通过当前上下文的表达式得到，可以是涉及符号或具体值的一元/二元运算符</li>
<li>条件语句if会影响路径约束$\pi$，此时会创建两个条件执行，分别为$\pi_{true}$和$\pi_{false}$，分别对应分支$\pi_{true}=\pi \and e_s$和$\pi_{false}=\pi \and \neg e_s$。符号执行在这两个状态下分别进行。（路径爆炸</li>
<li>跳转语句 goto s会通过将符号执行推进到语句s更新执行状态</li>
</ul>
<p>foobar函数的符号执行过程，可以等效地表示为一棵树，初始化为true，输入参数与符号值相联系。在第2行初始化x和y后，符号存储会分别将x与1,y与0联系。第三行包括一个条件语句，这会克隆执行，接下来在不同的分支会依据符号$\alpha_a$执行不同语句(C/D)在$\alpha_a\not = 0$,y被赋值x+3，并在E处获取y=4,因为在C中x=1。总之，算式会被符号值简单计算。在扩展所有执行状态直到assert语句后，可以检查输入参数a、b是否能让assert断言失败。通过分析状态D、G、G，我们发现只有H能让x-y=0。实际上，类似下式的输入都会令assert失败。具体例子可以通过SMT solver求解</p>
<script type="math/tex; mode=display">
2(\alpha_a+\alpha_b)-4=0\and \alpha_a \not=0\and\alpha_b=0</script><img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230712004756091.png" class title="image-20230712004756091">
<h3 id="1-2-Challenges-in-Symbolic-Execution"><a href="#1-2-Challenges-in-Symbolic-Execution" class="headerlink" title="1.2 Challenges in Symbolic Execution"></a>1.2 Challenges in Symbolic Execution</h3><ul>
<li>内存：怎么handle指针、数组还有比较复杂的对象，代码执行指针和数据结构不仅影响符号所存储的数据，还有符号表达式所指向的地址</li>
<li>环境：引擎怎么handle软件栈的交互？系统代码和库调用会带来副作用，例如文件创建或用户代码回调，这些都会影响后面的执行。然而评估可能的交互结果是不可行的</li>
<li>状态空间爆炸（路径爆炸）：loop语句可能会带来爆炸的状态空间，不可能在合理的时间内将其处理完</li>
<li>约束求解：SMT solver可以扩展到数百个复杂变量的组合约束，但处理非线性运算将会影响效率。</li>
</ul>
<h3 id="1-3-Related-Work"><a href="#1-3-Related-Work" class="headerlink" title="1.3 Related Work"></a>1.3 Related Work</h3><h2 id="2-SYMBOLIC-EXECUTION-ENGINES"><a href="#2-SYMBOLIC-EXECUTION-ENGINES" class="headerlink" title="2 SYMBOLIC EXECUTION ENGINES"></a>2 SYMBOLIC EXECUTION ENGINES</h2><p>介绍符号执行引擎的设计原则，介绍concolic execution（混合执行symbolic execution + concrete execution）</p>
<h3 id="2-1-Mixing-Symbolic-and-Concrete-Execution"><a href="#2-1-Mixing-Symbolic-and-Concrete-Execution" class="headerlink" title="2.1 Mixing Symbolic and Concrete Execution"></a>2.1 Mixing Symbolic and Concrete Execution</h3><p>经典符号执行引擎的一个主要限制是不能探索无法求解路径约束的执行路径。完整性的缺失源自执行器无法跟踪的外部代码，还有源自复杂运算例如非线性计算和先验函数。此外，实际程序通常不是自包含的：在执行过程中难以评估任何可能的副作用，要准确静态分析整个软件的堆栈很困难。解决这些问题的一个方法就是concolic执行：将符号执行与具体执行混合</p>
<p><strong>动态符号执行(Dynamic Symbolic Execution, DSE)：</strong>除了符号存储和路径约束，执行引擎会维护一个具体存储$\sigma_c$。在选择任意输入开始后，它会同时更新$\sigma_c $和$\sigma$。当具体执行执行某一分支时，符号执行会执行同一分支，并且从分支条件中提取的约束将添加到当前路径约束集。简而言之，符号执行是由特定的具体执行驱动的。因此，符号引擎不需要调用约束求解器来判断哪个分支状态是否被满足：这由具体执行直接测试。为了探索不同的路径，可以否定由一个或多个分支给出的路径条件，并调用SMT求解器来生成新的输入</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230721181522403.png" class title="image-20230721181522403">
<p>尽管DSE使用具体的输入来将符号执行推向特定的路径，但每当必须探索新路径时，它仍然需要选择一个分支来否定。要注意的是，每次具体执行都可能会增加必须访问的新分支，由于在所有已执行的具体执行中，未被访问的分支集合可能非常庞大，因此采用有效的搜索启发式（第 2.2 节）可以起到至关重要的作用。由于只探索了部分状态空间，初始输入对整个方法的有效性起着至关重要的作用，与黑盒模糊测试类似。</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113719498.png" class title="image-20230723113719498">
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113726255.png" class title="image-20230723113726255">
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230723113733535.png" class title="image-20230723113733535">
<p>如以上示例所示，假阴性(即遗漏路径)和路径分歧是动态符号执行的显著缺点。DSE以健全性换取性能和执行难度，由于程序执行会被遗漏，导致假阴性的存在，外部调用、异常、类型转换和符号指针导致路径偏移，需要谨慎处理。</p>
<p><strong>Selective Symbolic Execution：</strong>SSE采用了一种不同的方法来混合符号和具体执行，只全面探索软件栈的部分组件，而不关心其他组件。</p>
<p>假设函数A调用函数B，执行模式在调用处发生变化。会出现两种情况：</p>
<p>(1)从具体到符号再返回：B的参数被符号化，B被全部符号化。B也以具体方式执行，其具体结果返回给A</p>
<p>(2)从符号到具体再返回：B的参数被具体化，B被具体执行，然后在A中恢复符号执行。这可能会影响分析的合理性和完整性：</p>
<p>(i)为确保符号执行跳过任何因执行具体化而无法实现的路径（可能导致误报），SSE 收集了路径约束，以跟踪参数如何被具体化、B 产生了哪些副作用以及它产生了哪些返回值。</p>
<p>(ii)具体化可能导致 A 恢复后错过分支（可能导致假否定）。为了解决这个问题，收集到的约束被标记为软约束：只要返回 A 后的分支因软约束而无法执行，执行就会回溯，并尝试为 B 选择不同的参数。为了引导 B 的参数重新具体化，S2E 还会收集 B 具体执行过程中的分支条件，并选择具体值，以便在 B 中实现不同的具体执行路径。</p>
<h3 id="2-2-Path-Selection"><a href="#2-2-Path-Selection" class="headerlink" title="2.2 Path Selection"></a>2.2 Path Selection</h3><p>本节介绍路径选择策略：枚举所有路径花销太高，需要选择更有希望的路径</p>
<p><em>Depth-first search</em>(DFS)和<em>breadth-first search</em>（BFS）是最常用的策略，前者是在回溯到最深的未探索分支之前尽可能扩展路径，后者是并行扩展所有路径。当内存使用率较高时，DFS 通常会被采用，但包含循环和递归调用的路径会阻碍 DFS 的使用。因此，尽管内存压力较大，而且完成特定路径的探索需要较长的时间，一些工具还是会采用 BFS，它允许引擎快速探索不同的路径，及早发现有趣的行为。另一种流行的策略是random path selection，它已被改进为多种变体。例如，KLEE [20] 根据路径的长度和分支的弧度为路径分配概率： 它更青睐探索次数较少的路径，从而避免了循环和其他路径爆炸因素造成的饥饿。</p>
<p>另外一些旨在最大化代码覆盖率的启发式算法：KLEE中讨论的<strong>覆盖率优化搜索</strong>会为每个状态计算一个权重，然后用它来随机选择状态。权重是通过考虑最近的未覆盖指令的距离、该状态是否覆盖了新代码以及该状态的调用堆栈来获得的；<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/2509136.2509553">Li You</a>等提出的<strong>子路径引导搜索</strong>，试图通过选择控制流图中被探索次数较少的子路径来探索程序中被探索次数较少的部分。“这是通过保持已探索子路径的频率分布来实现的，其中子路径被定义为完整路径上长度为 n 的连续子序列。有趣的是，n 值对使用这种启发式的符号引擎所实现的代码覆盖率起着至关重要的作用，而且没有任何特定值被证明是普遍最优的。”；<strong>最短距离符号执行</strong>并不以覆盖率为目标，而是旨在识别程序中特定点执行的程序输入。然而，与基于覆盖率的策略一样，启发式也是以评估到目标点的最短距离为基础的。计算公式为程序间控制流图中最短路径的长度，引擎会优先处理距离最短的路径。</p>
<p>其他一些搜索启发式方法则试图优先选择可能通往某些目标所关注状态的路径。例如，AEG [8] 引入了两种这样的策略。<strong>错误路径优先策略</strong>选择那些过去状态包含小错误但无法利用的路径。我们的直觉是，如果一条路径包含一些小错误，那么它很可能没有经过适当的测试。因此，未来的状态很有可能包含有趣的、有望被利用的错误。同样，<strong>循环穷举策略</strong>也会探索访问循环的路径。这种方法的灵感来自于一个实际观察结果，即循环中常见的编程错误可能会导致缓冲区溢出或其他与内存相关的错误。为了找到可利用的错误，Mayhem [25] 优先考虑识别到内存访问符号地址或检测到符号指令指针的路径。</p>
<p>参考文献[118]提出了一种新颖的动态符号执行方法，用于自动查找满足规则属性的程序路径，即可以用有限状态机（FSM）表示的属性（如文件使用或内存安全）。动态符号执行由 FSM 引导，因此执行路径中最有可能满足该属性的分支会首先被探索。这种方法利用静态和动态分析来计算要选择探索的路径的优先级：在符号执行过程中，动态地计算当前执行路径已经达到的 FSM 状态，同时使用后向数据流分析静态地计算未来状态。如果这两个集合的交集是非空的，那么很可能有一条路径满足属性要求。</p>
<p>适度函数主要用于基于搜索的测试生成，衡量探索的路径与实现目标测试覆盖率的接近程度。参考文献 [112] 介绍了 fitnex，这是一种在concolic执行中翻转分支的策略，它优先考虑可能更接近特定分支的路径。更详细地说，给定一个目标分支，其相关条件的形式为  $|a-c|==0$，通过利用路径中变量 a 和 c 的具体值，计算出路径的接近度为 $|a-c|$。对于其他类型的分支条件，也可以计算类似的合适度值。符号引擎会选择某个分支拟合度值最低的路径。尚未到达分支的路径将获得最差的适配值。</p>
<h3 id="2-3-Symbolic-Backward-Execution"><a href="#2-3-Symbolic-Backward-Execution" class="headerlink" title="2.3 Symbolic Backward Execution"></a>2.3 Symbolic Backward Execution</h3><p><strong>符号逆向执行(Symbolic backward execution (SBE))</strong>是符号执行的一种变体，从程序的目标点开始探索到入口点，因此是反向进行分析。这种方法的主要目的通常是确定一个可以触发执行特定代码行（如断言或抛出语句）的测试输入实例。这对开发人员进行程序调试或回归测试非常有用。由于探索是从目标开始的，因此会沿着遍历过程中遇到的分支收集路径约束。SBE 引擎可以同时探索多条路径，而且与前向符号执行类似，会定期检查路径的可行性。当路径条件被证明不可行时，引擎会丢弃路径并返回。</p>
<p>SBE的一种变体 <strong>call-chain backward symbolic execution (CCBSE)</strong>，该技术首先要确定目标行所在函数的有效路径。找到路径后，引擎会移动到包含目标点的函数的调用者之一，并尝试重建从调用者入口点到目标点的有效路径。这个过程会递归重复，直到从程序的主函数重建出一条有效路径为止。与传统 SBE 的主要区别在于，虽然 CCBSE 从目标点向后跟踪调用链，但在每个函数内部的探索都与传统的符号执行一样。</p>
<p>在 SBE 和 CCBSE 中，逆向探索的一个关键要求是程序间控制流图的可用性，它提供了整个程序的控制流，并使确定探索所涉及的函数的调用点成为可能。遗憾的是，在实践中构建这样一个图可能相当具有挑战性。此外，一个函数可能有许多可能的调用点，这使得 SBE 的探索成本仍然很高。另一方面，在反向收集约束条件时，也会产生一些实际优势。我们将在第 6 节中进一步讨论这些优势。</p>
<h3 id="2-4-Design-Principles-of-Symbolic-Executors"><a href="#2-4-Design-Principles-of-Symbolic-Executors" class="headerlink" title="2.4 Design Principles of Symbolic Executors"></a>2.4 Design Principles of Symbolic Executors</h3><ul>
<li>Progress.执行器应能在不超出给定资源的情况下任意长时间地运行。由于可能存在大量不同的控制流路径，内存消耗尤为重要。</li>
<li>Work repetition. 不应重复执行工作，避免从一开始就多次重启程序，分析可能具有共同前缀的不同路径。</li>
<li>应尽可能重复使用以前运行的分析结果。特别是，应避免对先前已解决的路径约束条件进行代价高昂的 SMT 求解器调用。</li>
</ul>
<p>不同符号引擎在运行时间/内存、性能和完整性之前作出不同权衡。</p>
<p>在线执行器：在一次运行中同时执行多条路径，在每个依赖输入的分支上克隆执行状态。KLEE、AEG 和 S2E中都有这样的例子。这些引擎从不重新执行以前的指令，从而避免了工作重复。然而，许多活动状态需要保留在内存中，内存消耗可能会很大，从而可能阻碍进程。减少内存占用的有效技术包括 “写时拷贝 “技术，该技术试图在不同状态之间尽可能多地共享内存[20]。另一个问题是，并行执行多条路径需要确保执行状态之间的隔离，例如，通过模拟系统调用的效果来保持操作系统的不同状态。</p>
<p>离线执行器：在符号执行中，一次只对一条路径进行推理。与在线执行器相比，独立运行每条路径的内存消耗较低，而且可以立即重复使用之前运行的分析结果。另一方面，由于每次运行通常都会从头开始重新启动程序的执行，因此大部分工作都会重复。在离线执行器的典型实现中，运行是具体的，需要输入种子，首先具体执行程序，记录指令轨迹，记录轨迹会被符号化执行。</p>
<p>混合执行器：（如 Mayhem [25]）试图在速度和内存需求之间取得平衡：它们以在线模式启动，当内存使用量或并发活动状态的数量达到阈值时，会生成检查点，而不是分叉新的执行器。检查点维护符号执行状态和重放信息。当选中一个检查点进行恢复时，就会从恢复后的具体状态重新开始在线探索。</p>
<h2 id="3-MEMORY-MODEL"><a href="#3-MEMORY-MODEL" class="headerlink" title="3 MEMORY MODEL"></a>3 MEMORY MODEL</h2><p>符号执行的一个重要方面是如何建立内存模型，以支持带有指针和数组的程序。对内存地址建模的存储空间 σ 可以看作是将内存地址（索引）与具体值表达式或符号值相关联的映射。写$x\rarr e$表示变量x和表达式e时，我们指的是$\&amp;x\rarr e$，&amp;x是x的具体地址，$v[c]\rarr e$表示$\&amp;v+c\rarr e$</p>
<p>内存模型是符号引擎的一个重要设计选择，因为它能显著影响探索的覆盖率和约束求解的可扩展性。当操作中引用的地址是一个符号表达式时，就会出现符号内存地址问题。</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230724111514733.png" class title="image-20230724111514733">
<h3 id="3-1-Fully-Symbolic-Memory"><a href="#3-1-Fully-Symbolic-Memory" class="headerlink" title="3.1 Fully Symbolic Memory"></a>3.1 Fully Symbolic Memory</h3><p>At the highest level of generality，引擎将所有地址符号化。大量的工作都采用了这种方法，King在一篇开创性文章中首创以下两种基本方法</p>
<ul>
<li><p>State Forking.如果一个操作从一个符号地址读取数据或向一个符号地址写入数据，那么就会考虑该操作可能产生的所有状态，对该状态进行分叉。每个分叉状态的路径约束都会相应更新。</p>
<p>例如图5的例子，第四行的写操作会根据i的值影响a[0]和a[1]，在执行内存赋值后，状态分叉创建两个状态。同样根据第五行的内存读操作可能会访问[0]或a[1]。因此对于a[i]=5的两种可能结果的每一种，都有两种可能的断言结果，通过分叉相应的状态来探索相应结果</p>
</li>
<li><p>if-then-else formulas. 另一种方法是将符号指针的可能值编码到符号存储和路径约束的表达式中，而不分叉任何新的状态。主要思路是利用求解器的能力，对ite(c,t,f)的公式进行推理(if-then-else)，若c为true，则产生 t，否则产生f。这种方法对内存读写操作的作用不同。假设 α 是一个符号地址，它的具体值可能是 a1、a2，则：</p>
<ul>
<li>从$\alpha$中读取会得到表达式$ite(\alpha = a_1,\sigma(a_1),ite(\alpha=a_2,\sigma(a_2),…))$</li>
<li>在$\alpha$中写入表达式$e$会对$a_1,a_2$更新符号存储：$\sigma(a_i)\larr ite(\alpha=a_i,e,\sigma(a_i))$</li>
</ul>
<p>再看图5的例子，在第4行操作a[i]=5后，if-then-else方法没有产生分叉，而是编码两种可能的结果来更新内部存储$a[0] → ite (α_i = 0, 5, 0) 和 a[1] → ite (α_i = 1, 5, 0)$。同样在第五行，没有给a[j]的每一个可能的不同地址创建一个新的状态，而是将j的不确定性编码为单一表达式$ite (α_j = 0, σ (a[0]), σ (a[1])) = ite (α_j = 0,ite (α_i = 0, 5, 0),ite (α_i = 1, 5, 0)) $</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230724180939130.png" class title="image-20230724180939130">
</li>
</ul>
<p>fully symbolic memory可以最准确描述程序内存行为，并考虑所有可能的内存操作。在许多实际场景中，内存操作可能引用的地址集很小，如图5的例子，索引i和j的范围在一个有界区间内，因此可以使用合理的资源量精确分析。然而在一般情况下，符号地址可能引用内存中任何单元，造成状态数量激增。因此设计一系列技术提高可扩展性：</p>
<ul>
<li>以紧凑的方式表示内存。将符号地址表达式（而非具体地址表达式）映射为数据，以紧凑、隐式的形式表示使用符号地址引用内存时可能出现的其他状态。查询被卸载到高效的分页间隔树实现中，以确定内存读取操作可能会引用哪些存储数据。</li>
<li>用合理性换取性能。大致是用具体地址取代符号指针，将符号探索限制在执行状态的子集内。</li>
<li>堆建模。将探索限制在指针为空或指向先前堆分配对象的状态，而不是指向任何通用内存位置的状态。</li>
</ul>
<h3 id="3-2-Address-Concretization"><a href="#3-2-Address-Concretization" class="headerlink" title="3.2 Address Concretization"></a>3.2 Address Concretization</h3><p>指针值范围过大时导致组合复杂性爆炸时，地址具体化（包括将指针具体化为单个特定地址）可以有效减少状态数量，降低输入求解器的公式复杂度，但可能会遗漏一些路径，例如依赖于某些指针特定值的路径。</p>
<p>离线执行器自然性地出现具体化，它们通过将 T* 类型的引用具体化为 NULL 或新分配的 sizeof(T) 字节的对象地址来处理内存初始化。若T是结构体，那么同样的具体化方法将递归地应用于指向对象的所有字段。</p>
<h3 id="3-3-Partial-Memory-Modeling"><a href="#3-3-Partial-Memory-Modeling" class="headerlink" title="3.3 Partial Memory Modeling"></a>3.3 Partial Memory Modeling</h3><p>为了缓解完全符号化内存的可扩展性问题和内存具体化的合理性损失，Mayhem 引入部分内存模型,其主要思想是，如果写入地址可能取值的连续区间足够小，那么写入地址总是具体化的，而读取地址则是符号化的。这种模型基于一种权衡：它使用比具体化更具表现力的公式，因为它对每个状态的多个指针值进行编码，但并不试图像完全符号化内存那样对所有指针值进行编码。约束地址可能取值集合的基本方法包括尝试不同的具体值，并检查它们是否满足当前的路径约束，每次尝试都排除地址空间的大部分，直到找到一个严格的范围。这种算法有许多注意事项：例如，在每次符号取消引用时查询求解器的成本很高；内存范围可能不连续；符号指针内存区域内的值可能具有结构。因此，Mayhem 进行了一系列优化，例如值集分析 [42] 和各种形式的查询缓存（第 6 节），以高效地细化范围。如果在这一过程结束时，范围大小超过了给定的阈值（如 1024），那么地址就会被具体化。Angr [95] 也采用了部分内存模型的思想，并对其进行了扩展，可选择支持对小范围连续区间（最多 128 个地址）内的符号指针进行写操作。</p>
<h3 id="3-4-Lazy-Initialization"><a href="#3-4-Lazy-Initialization" class="headerlink" title="3.4 Lazy Initialization"></a>3.4 Lazy Initialization</h3><p>一种针对高级面向对象语言结构的符号执行技术。作者描述了一种软件验证框架，结合符号执行和模型检查来处理链接数据结构，如列表和树。</p>
<p>引入Lazy initialization来处理动态分配的对象。与1.1节的例子相比，增加了用于维护此类对象的堆配置。符号执行对复杂对象以未初始化字段开始，只有在执行过程中首次访问这些字段才对其初始化。当访问未初始化的引用字段时，算法会使用三种不同的堆配置分叉当前状态，其中字段初始化为(1)空；(2)对一个具有所有符号属性的新对象的引用(3)先前引入的所需类型的具体对象</p>
<p>参考文献[66]和[107]将lazy initialiation和用户提供的先决条件结合(即在方法执行前假定为真的条件)。前置条件用于描述那些程序输入状态，在这些状态下，方法有望按照程序员的意图运行。例如，我们希望二叉树数据结构是非循环的，每个节点（根节点除外）都有一个父节点。保守先决条件用于确保在初始化过程中消除不正确的堆配置，从而加快符号执行过程。</p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230725180826998.png" class title="image-20230725180826998">
<p>例子：图8展示了一个java的递归add方法，将节点追加到链表的末尾，以及在应用lazy initialization时符号执行的最小表示形式。</p>
<blockquote>
<p>树节点表示 add 的直线片段的执行。最初，片段 A 对引用 l 进行求值，该引用是符号化的，因此未初始化。符号引擎会考虑三种情况：(1) l 为空；(2) l 指向一个新对象；(3) l 指向一个先前分配的对象。由于这是第一次遇到 Node 类型的引用，因此排除了选项 (3)。然后对剩下的两个选项进行扩展，执行相关的片段。第一个路径在执行片段 B 后结束，而第二个路径由于懒初始化隐式创建了一个新对象 o1，然后执行 C，递归调用 add。当扩展递归调用时，执行片段 A，引擎再次考虑三个选项，并分叉为三个不同的路径。由于之前已分配了一个 Node 对象（即 o1），因此现在考虑了选项 (3)。然而，这条路径很快就被引擎终止，因为它违反了非循环性前提条件（在本例中以注释的形式表示）。其他分叉路径会进一步扩展，重复同样的过程。由于链表的最大长度未知，探索过程可能会无止境地进行下去。因此，通常会假设实体化（即字段实例化）链的深度有一个上限。</p>
</blockquote>
<p>该领域的最新进展主要集中在提高堆配置的生成效率上。如在参考文献[38]中，引用变量的具体化被推迟到实际访问对象时才进行。参考文献[87]则采用了边界细化方法，通过使用已具体化字段的信息来剪除无意义的堆配置，同时使用 SAT 解算器来检查给定配置的声明性条件（而不是原始算法中的命令性条件）是否成立。</p>
<h2 id="4-INTERACTION-WITH-THE-ENVIRONMENT"><a href="#4-INTERACTION-WITH-THE-ENVIRONMENT" class="headerlink" title="4 INTERACTION WITH THE ENVIRONMENT"></a>4 INTERACTION WITH THE ENVIRONMENT</h2><p>Missing symbolic data flows through these software elements might indeed affect the meaningfulness of the analysis.</p>
<p><strong>System Environment</strong>：早期的一些研究（如 DART [51]、CUTE [91] 和 EXE [21]）通过使用具体参数实际执行外部调用，将系统环境纳入了分析范围。与完全符号策略相比，这确实限制了它们可以探索的行为，而完全符号策略则可能是不可行的。在在线执行器中，这种选择还可能导致来自不同执行路径的外部调用相互干扰。由于没有跟踪每次外部调用副作用的机制，因此可能存在状态不一致的风险，例如，一个执行路径可能在读取文件的同时，另一个执行路径却在试图删除文件。</p>
<p>克服这一问题的方法是创建能捕捉这些互动的抽象模型。例如，在 KLEE [20] 中，每个执行状态都有一个基本的符号文件系统来支持符号文件，该系统由一个包含 n 个符号文件的目录组成，符号文件的数量和大小由用户指定。对符号文件的操作会产生 n+1 个状态分支：每个可能的文件都有一个，另外还有一个可选分支，用于捕捉操作中的意外错误。由于标准库中的函数数量通常很大，为它们编写模型既昂贵又容易出错[12]，因此模型通常在系统调用级而不是库级实现。这样也可以对库进行符号探索。</p>
<p>AEG [8] 模拟了攻击者可用作输入源的大部分系统环境，包括文件系统、网络套接字和环境变量。此外，还模拟了 70 多个库和系统调用，包括线程和进程相关的系统调用，以及用于捕捉潜在缓冲区溢出的常用格式化函数。符号文件的处理方式与 KLEE [20] 类似，而符号套接字的处理方式与 KLEE [20] 类似，数据包及其有效载荷的处理方式与符号文件及其内容的处理方式类似。CLOUD9 [18] 支持额外的 POSIX 库，允许用户控制测试环境中的高级条件。例如，它可以模拟由网络数据流碎片引起的重新排序、延迟和数据包丢弃。</p>
<p>S2E指出模型除了编写成本高昂外，很少能达到完全准确，而且如果建模系统发生变化，模型可能很快就会过时。因此，最好让分析程序在探索多条路径时与真实环境交互。但是，这样做必须避免环境干扰或状态不一致。为了实现这一目标，S2E 采用了虚拟化技术，以防止在与真实环境交互时，副作用在多条独立执行路径间传播。QEMU 被用来模拟整个软件栈：指令被透明地翻译成由本地主机运行的微操作，而 x86 到LLVM 的提升器被用来在 KLEE [20] 中执行指令序列的符号执行。这样，S2E 就能正确评估环境造成的任何副作用。请注意，每当评估符号分支条件时，执行引擎都会分叉仿真器的并行实例，以探索替代路径。选择性符号执行（第 2.1 节）用于限制整个软件堆栈的符号探索范围，从而部分减轻仿真整个堆栈（如用户代码、库、驱动程序）的开销，因为这可能会大大限制整体解决方案的可扩展性。</p>
<p>DART 的方法[51]有所不同，其目标是实现自动单元测试。DART 将 C 程序中引用的所有外部变量和函数以及顶层函数的参数都视为外部接口。外部函数是通过非确定地返回其指定返回类型的任何值来模拟的。为了对不依赖于环境的库函数进行符号探索，用户可以调整外部函数和非外部函数之间的界限，以调整符号分析的范围。</p>
<p><strong>Application Environment</strong></p>
<p>在Swing或Android框架中会出现这些问题，如何分析用户交互过程调用的控制流和数据流。对于运行在托管运行时的应用程序，符号值也会在分析范围之外流动。这些特性使引擎的实现变得复杂：例如，Java 中的本地方法和反射依赖于底层 JVM 的内部机制 [3]。闭源组件也是一大难题。</p>
<p>与系统环境建模类似，DART [51] 和 CUTE [91] 等早期使用具体参数执行对其他组件的调用，这可能会导致探索不完整，无法为可行的程序路径生成输入。另一方面，对其代码进行符号执行也不可能成功，原因有很多：例如，外部简单行为的实现通常很复杂，因为它必须考虑到可扩展性和可维护性，或者可能包含与探索无关的细节，如如何显示触发回调的按钮[63]。一种解决方案是用<strong>更简单、更抽象的模型</strong>来模仿外部组件。然而，手动编写组件模型本身可能就是一项艰巨的任务，而且由于源代码不可用，使用不支持模型的应用程序仍将遥不可及。</p>
<p>一些工作尝试找到在符号探索时组件中需要符号值的实体，并因此需要人工干预分析。另一些尝试自动生成模型，这可能是闭源组件唯一的选择。参考文献[24]和[105]采用程序切片的方法来提取操作与分析相关的给定字段集的代码，并从中建立抽象模型。参考文献[63]则更进一步，使用程序合成来生成 Java 框架的模型。这些模型提供了许多框架中大量使用的设计模式的等效实例： 这有助于符号执行器发现控制流—例如通过观察者模式回调用户代码—否则就会被忽略。使用程序合成的一个优势是，它可以生成比切片更简洁的模型，因为它通过捕捉程序的功能行为，抽象掉了程序编写的细节和纠葛。</p>
<h2 id="5-PATH-EXPLOSION"><a href="#5-PATH-EXPLOSION" class="headerlink" title="5 PATH EXPLOSION"></a>5 PATH EXPLOSION</h2><p>符号执行器可能在每一个分支fork一个新状态，导致路径数指数级上涨</p>
<p>路径爆炸的主要来源是循环和函数调用。</p>
<blockquote>
<p>考虑以下代码片段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = sym_input();//e.g., read from file</span><br><span class="line">while(x&gt;0) x = sym_input();</span><br></pre></td></tr></table></figure>
<p>sym_input是一个从外部读取输入的线程。任何final state的路径约束有以下形式</p>
<script type="math/tex; mode=display">
\pi = (\and_{i\in[1,k]}\alpha_i>0)\and(\alpha_{k+1}\leq 0)</script><p>where k is the number of iterations and αi is the symbol produced by sym_input() at the ith iteration</p>
</blockquote>
<p>简单方法：将循环探索限制在有限的迭代次数，但容易错过重要路径。</p>
<p>下面将介绍另外策略，例如通过总结策略来描述不同循环迭代或函数调用之间的相似性，从而防止重复探索代码部分，或者通过推断不变式来归纳描述计算的属性。</p>
<h3 id="5-1-Pruning-Unrealizable-Paths"><a href="#5-1-Pruning-Unrealizable-Paths" class="headerlink" title="5.1 Pruning Unrealizable Paths"></a>5.1 Pruning Unrealizable Paths</h3><p>缩小路径空间的一种方法是在每个分支上调用约束求解器，修剪无法实现的分支：<em>如果求解器能证明某个分支的路径约束所给出的逻辑公式是不可满足的，那么程序输入值的任何赋值都不可能驱动实际执行走向该路径，符号引擎就可以在不影响稳健性的情况下安全地丢弃该分支。</em></p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230727010130477.png" class title="image-20230727010130477">
<p>这种方法被称为eager evaluation of path constraints，因为在每个分支上都会即刻检查约束，这也是大多数符号引擎的默认设置。</p>
<p>参考文献[90]介绍了一种有助于减少检查路径数量的正交方法。虽然 SMT 求解器可用于每次探索一条路径的大型搜索空间，但它最终往往会推理出许多路径共享的控制流。这项工作利用了这一观察结果，从每条被证明为不可满足的路径中提取最小的不满足核心，在保留不满足性的同时删除尽可能多的语句。这样，引擎就可以利用不满足核心来放弃共享相同（不可满足）语句的路径。</p>
<h3 id="5-2-Function-and-Loop-Summarization"><a href="#5-2-Function-and-Loop-Summarization" class="headerlink" title="5.2 Function and Loop Summarization"></a>5.2 Function and Loop Summarization</h3><p>当一个代码片段—无论是函数还是循环体—被多次遍历时，符号执行器就能建立一个代码执行摘要，供后续重复使用。</p>
<p><strong>Function Summaries</strong>. 参考文献[50]针对concolic执行动态生成函数摘要，允许执行器有效重用之前发现的分析结果。该技术通过公式 $\phi_w$捕捉函数调用的效果，将在探索路径 $w $期间观察到的函数输入约束与输出约束结合在一起，描述了等价的具体执行。</p>
<p>函数摘要由不同类的$\phi_w$公式定义，可行的程序间路径由程序内路径的符号执行组合而成。参考文献[4]扩展了组合式符号执行，将摘要生成为带有未解释函数的一阶逻辑公式，允许形成不完整摘要（即只捕获函数内路径的一个子集），在程序间分析过程中，随着更多语句被覆盖，这些摘要可以按需扩展。</p>
<p>参考文献[14]提供了一种不同的摘要生成方法：如果两种状态仅在某些程序值上存在差异，而这些程序值以后不会被读取，那么由这两种状态产生的执行将产生相同的副作用。因此，代码片段的副作用可以被缓存，并可能在以后重复使用。</p>
<p><strong>Loop Summaries.</strong> 与函数调用类似，参考文献[54]描述了循环部分摘要。循环摘要使用了符号执行过程中通过推理循环条件和符号变量之间的依赖关系动态计算出的前置与后置条件。缓存循环摘要不仅能让符号引擎避免在同一程序状态下重复执行同一循环，还能将摘要推广到同一循环在不同条件下的不同执行。</p>
<p>早期的研究成果只能为循环生成摘要，这些循环通过增加一个固定量来更新迭代中的符号变量。此外，它们也无法处理嵌套循环或多路径循环，即在循环体中带有分支的循环。Proteus [113] 是一个用于总结多路径循环的通用框架。它根据路径条件的值变化模式（即感应变量是否更新）和循环内路径交错模式（即是否存在规律性）对循环进行分类。这种分类方法利用了控制流图的扩展形式，然后用它来构建一个自动机，对循环内路径交错进行建模。该自动机以深度优先的方式遍历，并为其中所有可行的轨迹构建摘要，其中一个轨迹代表循环中的一次执行。这种分类方法决定了一个循环是可以被精确或近似地捕获（这可能仍有实际意义），还是不能被捕获。对于具有不规则模式或非归纳更新的多路循环的精确总结，以及更重要的嵌套循环的总结，仍然是有待解决的研究课题。</p>
<p>参考文献[96]介绍了一种压缩技术，通过分析控制流图中的循环路径，可以得到声明性描述程序状态的模板，这些状态由部分代码生成，形成一棵紧凑的符号执行树。通过利用模板，符号执行引擎可以探索的程序状态数量大大减少。这种方法的缺点是模板在路径约束中引入了量词：反过来，这可能会大大增加约束求解器的负担。</p>
<h3 id="5-3-Path-Subsumption-and-Equivalence"><a href="#5-3-Path-Subsumption-and-Equivalence" class="headerlink" title="5.3 Path Subsumption and Equivalence"></a>5.3 Path Subsumption and Equivalence</h3><p>庞大的符号状态空间为探索路径相似性的技术提供了空间，例如，摒弃不能带来新发现或抽象出差异的路径。在本节中，我们将讨论一些这方面的工作。</p>
<p><strong>Interpolation</strong>(插值？)现代 SAT 求解器依赖于搜索和演绎的相互促进组合，当前者受阻时，后者将推动前者摆脱冲突。与此类似，符号执行也能从插值技术中获益，从没有显示出所需属性的程序路径中推导出属性，从而避免探索无法满足属性的类似路径。</p>
<p><em>Craig interpolants</em>可以决定一个公式的哪些信息与一个属性相关。</p>
<p>假设蕴涵 P → Q 在某种逻辑中成立，我们可以构造一个内插式 I，使得 P → I 和 I → Q 都有效，并且 I 中的每个非逻辑符号都同时出现在 P 和 Q 中。插值法在程序验证中常用如下：给定一个不可满足公式 P ∧ Q 的反驳证明，可以构造一个反向插值器 I，使得 P → I 有效，而 I ∧ Q 不可满足。</p>
<p>插值在很大程度上被用于模型检查、谓词抽象、谓词细化、定理证明等领域。例如，插值法提供了一种将有界模型检查扩展到无界情况的方法—有界模型检查的目的是证伪程序的安全属性，而程序的过渡关系是在给定边界内展开的。特别是，由于有界证明通常包含无界证明的成分，插值法可以帮助从有界情况的反驳证明中构建所有可到达最终状态的过度逼近，从而获得足以证明不存在违规行为的过度逼近。</p>
<p><strong>Subsumption with Interpolation.</strong> 在符号验证带有明确错误位置标记（如使用断言）的程序时，插值法可用于解决路径爆炸问题。在探索过程中，引擎会为每个程序位置注释一些条件，这些条件概括了之前通过该位置但未能到达错误位置的路径。每次遇到分支时，执行器都会检查路径条件是否被之前的探索所包含。在最佳情况下，这种方法可以成倍地减少访问路径的数量。</p>
<p>参考文献[75]为分支和语句提出了一种注释算法，即如果它们的标签是由当前状态暗示的，那么它们就不会导致错误位置。插值法用于构建弱标签，从而实现高效的蕴含计算。参考文献[117]提出了一种类似的去除冗余的方法，称为后置条件符号执行，在这种方法中，程序位置被标注上后置条件，即总结先前探索路径后缀的最弱前提条件。这里的直觉是，插值越弱，就越有可能实现路径归并。后置条件是从完全探索过的路径中增量构建并向后传播的。当遇到分支时，相应的后置条件会被否定并添加到路径约束中。</p>
<p>路径归并的合理性依赖于这样一个事实，即为某个位置计算的插值能够捕捉到经过该位置的所有路径。因此，路径选择策略在内插法构建中起着关键作用： 例如，DFS 非常方便，因为它可以快速全面探索路径，从而构建内插值并最终向后传播；而 BFS 则会阻碍归并，因为在检查分支冗余时，由于尚未全面探索类似路径，内插值可能不可用。参考文献[59]提出了一种名为 “贪婪确认 “的新策略，它将路径选择问题与内插值形成问题分离开来，允许用户在使用 DFS 以外的启发式方法时从路径归并中获益。贪婪确认可区分路径树已被全部或部分探索过的节点： 对于后者，它会对额外的路径进行有限的遍历，以实现插值形成。</p>
<p>事实证明，插值法有助于在给定的时间内探索复杂程序的较大部分。参考文献 [117] 称，路径冗余在现实世界中非常广泛。通常情况下，插值的开销（可在 SMT 求解器或专用引擎中执行）会在早期阶段降低探索速度，但插值的优势最终会开始显现，从而大大加快探索速度[59]。</p>
<p><strong>Unbounded Loops.</strong> 如果代码中存在无界循环，就很难在其中的程序位置执行合理的子归纳，因为有大量路径可以通过这些位置。参考文献[75]设计了一种迭代深化策略，将循环展开到固定深度，并尝试计算循环不变的内插值，这样就可以用它们来证明无界情况下错误节点的不可到达性。然而，这种方法可能无法终止那些需要互不相关的循环不变式的程序。因此，参考文献 [61] 提出了一种策略，即计算足够强的推测不变式，使循环的符号执行快速收敛，同时也足够宽松，尽可能允许路径归并。在后续工作中[60]，在符号执行过程中使用拓宽算子单独发现循环不变式，并构建路径子假设的最弱先决条件，使其与不变式相蕴涵。</p>
<p><strong>Subsumption with Abstraction</strong>. 参考文献[6]采用了一种不基于插值的方法，描述了一种针对符号状态的双重归并检查技术。符号状态是通过符号堆和一组标量变量约束来定义的。因此，该技术不仅针对标量类型，还针对未初始化或部分初始化的数据结构。本文介绍了一种通过图遍历来匹配堆配置的算法，同时还使用了一种现成的求解器来推理标量数据的归并。</p>
<p>为了应对可能无限制的状态数量，这项工作提出了抽象方法，使符号状态空间有限，从而使子归并有效。抽象方法可以概括堆的形状和标量数据的约束条件；给出了链表和数组的例子。归并检查发生在欠近似状态上，这意味着可行的行为可能会被遗漏。作者在证伪场景中结合模型检查使用了这一技术，并将其应用于仅基于符号执行的验证中。</p>
<p><strong>Path Partition.</strong> 控制流和数据流的依赖性分析揭示了一些偶然关系，在探索过程中可以利用这些关系过滤掉无法揭示其他程序行为的路径。参考文献[74]将concolic执行的输入划分为互不干扰的区块，以符号方式探索每个区块，而其他区块则固定为具体值。当两个输入共同影响一个语句或由控制或数据依赖关系连接的语句时，就会发生干扰。参考文献[84]侧重于输出，如果两条路径在程序输出方面具有相同的相关片段，则将它们置于同一分区。相关片段是动态数据和控制依赖关系的传递闭包，也是涉及不执行会影响输出的语句的潜在依赖关系的传递闭包。参考文献[109]还通过为单个语句建立相关片段来探索与输出无关的故障，捕捉它们是如何通过符号输入计算出来的。依赖性分析能有效检查切片的等价性，当所有语句实例的切片都被之前的路径覆盖时，路径就会被认为是多余的。</p>
<h3 id="5-4-Under-Constrained-Symbolic-Execution"><a href="#5-4-Under-Constrained-Symbolic-Execution" class="headerlink" title="5.4 Under-Constrained Symbolic Execution"></a>5.4 Under-Constrained Symbolic Execution</h3><p>避免路径爆炸的一种可行方法：将要分析的代码（例如函数）从其外层系统中剪切出来，并对其进行隔离检查。例如3.4节的lazy initialization，就是遵循这一原则自动重构复杂数据结构的。然而，由于与周围环境关系紧密，将代码从应用程序中分离存在困难：在孤立函数中检测到的错误可能是假的，这是因为函数在完整的上下文执行时，输入可能永远不会是某些值。先前工作如参考文献[35]，首先对代码进行孤立分析，然后使用具体执行来测试生成的崩溃输入，以过滤误报。</p>
<p><em>Under-constrained symbolic execution.</em> 欠约限符号执行是符号执行的一个转折，将函数的符号输入以及可能被影响的全句数据标记为欠约束状态，从而对函数进行孤立分析。直观地说，如果在分析过程中，我们没有考虑到从程序入口点到函数的前缀路径上本应收集到的对符号变量值的约束，那么这个符号变量就是欠约束变量。在实践中，符号引擎可以通过跟踪内存访问并识别其位置，自动将数据标记为欠约束，而无需人工干预：例如，当对堆栈上的未初始化数据进行内存读取时，就可以检测到函数的输入。欠约束变量与经典的全约束符号变量具有相同的语义，但在表达式中使用时会产生错误。特别是，只有在当前已知的变量约束条件的所有解都会导致错误发生时，才会报告错误，也就是说，错误对上下文不敏感，因此是真正的正面错误。否则，它的否定将被添加到路径约束中，并恢复正常执行。这种方法可视为试图从代码中插入的检查中重建先决条件：任何违反已添加否定约束的后续操作都将被报告为错误。为了保持这种分析的正确性，只要任何表达式同时涉及欠约束值和完全约束值，就必须在变量之间传播标记。例如，在 a &gt; b 的比较中，a 是欠约束值，而 b 不是，这就迫使引擎将标记从 a 传播到 b，就像在污点分析中处理污点值一样。符号引擎通常使用阴影内存来跟踪标记。</p>
<p>虽然这种技术可能会遗漏错误，并不完善，但它仍能在较大的程序中发现有趣的错误。此外，欠约束符号执行的应用不仅限于函数： 例如，如果某个代码区域（如循环）可能会给符号执行器带来麻烦，那么就可以通过将其影响的位置标记为欠约束来跳过该代码区域。一般来说，要了解跳过的代码会影响哪些数据并不容易，因此可能需要手动标注，以保证分析的正确性。</p>
<h3 id="5-5-Exploiting-Preconditions-and-Input-Features"><a href="#5-5-Exploiting-Preconditions-and-Input-Features" class="headerlink" title="5.5 Exploiting Preconditions and Input Features"></a>5.5 Exploiting Preconditions and Input Features</h3><p>减少路径爆炸的另一种方法是利用某些输入属性的知识。AEG [8] 提出了先决条件符号执行法，通过引导探索满足先决条件谓词的输入空间子集，减少探索状态的数量。其基本原理是将重点放在可能导致程序某些行为的输入上（例如，将探索范围缩小到最大大小的输入，以揭示潜在的缓冲区溢出）。前置条件符号执行以合理性换取性能：精心设计的前置条件既不能太具体（会错过有趣的路径），也不能太通用（会影响空间状态缩减带来的速度提升）。这种方法不是从一个空的路径约束集开始，而是将先决条件添加到初始 π 中，这样探索的其余部分就会跳过不满足这些先决条件的分支。虽然在初始化时为 π 添加更多的约束条件可能会增加求解器的负担，因为它需要在每个分支执行更多的检查，但这在很大程度上可能会被更小的状态空间所带来的性能提升所抵消。</p>
<p>符号执行中常见的前提条件类型包括：已知长度（即缓冲区的大小已知）、已知前缀（即缓冲区的前缀已知）和完全已知（即缓冲区的内容完全具体）。在处理对具有已知或预定义结构的输入进行操作的代码（如字符串解析器或数据包处理工具）时，这些前提条件是非常自然的。</p>
<blockquote>
<p>Example. Example. Consider the following simplified packet header processing code: pkt points to the input buffer, while header to the fixed expected content. If no precondition is considered, then this code can generate an exponential number of paths, since any mismatch forces a new call to get_input. However, if a known prefix precondition is set on the input, then only a single path is generated when exploring the loop. The engine can thus focus its exploration on parse_payload().</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start: get_input(&amp;pkt);</span><br><span class="line">for(k = 0; k &lt; 128; k++)</span><br><span class="line">	if (pkt[k] != header[k])</span><br><span class="line">		goto start;</span><br><span class="line">parse_payload(pkt)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>参考文献[88]提出了一种称为循环扩展符号执行（loop-extended symbolic execution）的技术，只要有描述输入程序的语法，这种技术就能有效地探索循环。将迭代次数与程序输入的特征联系起来，可以有效地指导对循环产生的程序状态的探索，从而减少路径爆炸问题。</p>
<h3 id="5-6-State-Merging"><a href="#5-6-State-Merging" class="headerlink" title="5.6 State Merging"></a>5.6 State Merging</h3><p>状态合并是一种功能强大的技术，它能将不同的路径合并成一个状态。合并后的状态由一个公式来描述，该公式代表了在保持独立的情况下描述各个状态的公式的析取。与抽象解释等其他静态程序分析技术不同，符号执行中的合并不会导致过度逼近。</p>
<blockquote>
<p>图a：未使用状态归并，图b：借助ite语句实现状态归并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void foo(int x,int y)&#123;</span><br><span class="line">	if(x&lt;5)</span><br><span class="line">		y=y*2;</span><br><span class="line">	else</span><br><span class="line">		y=y*3;</span><br><span class="line">	return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230731105753547.png" class title="image-20230731105753547">
</blockquote>
<p><strong>Tradeoffs: To Merge or Not to Merge?</strong>  原则上，两个要评估同一语句且在符号存储上相似的符号状态，将其合并可能是有利的</p>
<p>给定两个状态$(stmt,\sigma_1,\pi_1)$和$(stmt,\sigma_2,\pi_2)$，合并后的状态可以构造为$(stmt,\sigma,\pi_1\or\pi_2)$，其中$\sigma$是$\sigma_1$和$\sigma_2$之间的合并符号存储空间，使用ite表达式建立，以考虑存储空间的差异，而$\pi_1 \or \pi_2$是两个合并状态的路径约束的并集。</p>
<p>控制流结构，如 if-else 语句（如前面的例子）或简单循环，通常会产生非常相似的后继状态，是状态合并的最佳候选。</p>
<p>早期的研究[50, 57]表明，合并技术能有效减少探索路径的数量，但同时也会给约束求解器带来负担，因为不连接会妨碍求解。合并还可能在代码中引入新的符号表达式，例如，将条件赋值中的不同具体值合并为条件的符号表达式。参考文献 [70] 对状态合并技术的设计空间进行了精彩的讨论。一方面，在基于搜索的符号执行（第 2.2 节）中使用的路径完全分离技术不执行合并。在另一端，静态状态合并将控制流连接点上的状态合并起来，实质上是用一个公式表示整个程序。静态状态合并用于整个程序验证条件生成器[10, 114]，这种生成器通常以精度换取可扩展性，例如只展开循环一次。</p>
<p><strong>Merging Heuristics. </strong>中间合并方案采用启发式方法来识别状态合并，从而加快探索过程。事实上，产生较大的符号表达式和可能的额外求解器调用可能会超过状态较少带来的好处，从而导致整体性能较差 [57, 70]。查询次数估算 [70] 依靠简单的静态分析来确定每个变量在 CFG 中任何给定点之后的分支条件中的使用频率。估算结果可以代表特定变量可能参与的求解器查询次数。如果两个状态的不同变量在以后的查询中出现的频率很低，那么这两个状态就很适合合并。Veritesting [9] 实现了一种基于容易语句和困难语句区分的合并启发式，后者涉及间接跳转、系统调用和其他难以实现精确静态分析的操作。静态合并是在容易语句序列上进行的，其效果用 ite 表达式捕捉，而每当遇到难以分析的语句时，就进行逐路径符号探索。(启发式合并)</p>
<p><strong>Dynamic State Merging.</strong> 参考文献[70]引入了动态状态合并，这种合并不受搜索策略所强加的探索顺序的影响。假设符号引擎维护着一个状态工作列表和一个有界的前代状态历史。当引擎需要选择下一个要探索的状态时，它首先会检查工作列表中是否有两个状态 s1 和 s2，它们不匹配，无法合并，但 s1 和 s2 的前一个状态匹配。如果 s2 和 s1 的后继状态之间的预期相似度也很高，那么算法就会通过将 s1 的执行提前固定步数来尝试合并。这体现了一种理念，即如果两个状态相似，那么它们各自的后继状态也很可能在几步后变得相似。如果合并失败，算法就会让搜索启发式选择下一个要探索的状态。</p>
<h3 id="5-7-Leverageing-Program-Analysis-and-Optimization-Techniques"><a href="#5-7-Leverageing-Program-Analysis-and-Optimization-Techniques" class="headerlink" title="5.7 Leverageing Program Analysis and Optimization Techniques"></a>5.7 Leverageing Program Analysis and Optimization Techniques</h3><p>借助程序分析技术优化符号执行</p>
<p><strong>Program Slicing.</strong> 从程序行为的子集开始分析，从程序中能够表示该行为的最小序列提取。这些信息可以帮助符号引擎：例如参考文献[94]利用向后程序切片来限制对特定目标程序点的符号探索。</p>
<p><strong>Taint Analysis. </strong> 这项技术[89]试图检查程序中哪些变量的值可能来自潜在危险的外部来源，如用户输入。这种分析既可静态执行，也可动态执行，后者的结果更为准确。在符号执行方面，污点分析可以帮助引擎检测哪些路径依赖于污点值。例如，参考文献[25]将分析重点放在跳转指令被污染的路径上，并通过符号执行利用漏洞。</p>
<p><strong>Fuzzing. </strong>这种软件测试方法会随机改变用户提供的测试输入，导致崩溃或断言失败，并可能发现潜在的内存泄漏。模糊测试可与符号执行相结合，收集输入的约束条件，并否定这些约束条件以生成新的输入。另一方面，符号执行器也可以通过模糊处理进行增强，从而更快、更高效地达到更深的探索状态。</p>
<p><strong>Branch Prediction. </strong>这是一种在流水线执行中减轻错误预测惩罚的策略，方法是避免在代码的极小部分进行跳转： 例如，控制流分叉结构（如 C 语言的三元运算符）可以用谓语选择指令代替。参考文献[30]指出，在使用符号执行交叉检查程序的两个实现时，采用这种策略可使探索路径的数量呈指数级减少。</p>
<p><strong>Type Checking. </strong> 符号分析与类型检查可以有效结合，例如类型检查可以确认符号分析难以进行的函数的返回类型，这些信息可以帮助执行器裁剪某些路径。</p>
<p><strong>Program Differencing. </strong>?没看懂？依赖性分析可以识别受代码编辑影响的分支和数据流。定向增量符号执行 [116] 可以静态识别受更改影响的 CFG 节点，并利用这些信息只对那些行使未发现的受影响节点序列的路径进行探索。</p>
<p><strong>Compiler Optimzations. </strong>参考文献[19]认为，程序优化技术应与搜索启发式、状态合并和约束求解优化等广为接受的解决方案一起，成为符号执行实际实现的一流要素。事实上，程序转换既能影响路径探索过程中产生的约束的复杂性，也能影响探索本身。例如，使用查找表对函数结果进行预计算，会因内存访问而导致路径条件中的约束条件数量增加，而对乘法运算进行强度还原，则可能导致一连串的加法运算，从而增加约束条件求解器的成本。此外，编译高级开关语句的方式也会极大地影响路径探索的性能，而采用条件指令（如 LLVM 中的 select 或 x86 中的 setcc 和 cmov）则可以通过生成简单的 ite 表达式来避免昂贵的状态分叉。</p>
<p>编译器优化的效果通常可以通过运行时执行的指令数量或大小来预测，但在符号执行中，类似的优化效果并不明显[41]，这主要是因为约束求解器通常是作为黑盒使用的。据我们所知，只有少数工作尝试分析编译器优化对约束生成和路径探索的影响 [41，108]，留下了一些有趣的开放性问题。参考文献[80]中介绍的工作与此不同，它探讨了动态常量折叠和优化约束编码等变换，以加快基于数组理论的符号执行器中的内存操作（第 3.1 节）。</p>
<h2 id="6-CONSTRAINT-SOLVING"><a href="#6-CONSTRAINT-SOLVING" class="headerlink" title="6 CONSTRAINT SOLVING"></a>6 CONSTRAINT SOLVING</h2><p>约束求解仍然是符号执行引擎可扩展性的主要障碍之一，而且在面对涉及昂贵理论（如非线性算术）或不透明库调用的约束时，也阻碍了其可行性。</p>
<p>本部分主要讨论优化约束求解器的方法；包括(i) 减少要检查的约束条件的大小和复杂性；(ii) 通过采用缓存约束解、延迟求解器查询或具体化等方法减轻求解器的负担；(iii) 增强符号执行以处理对决策程序有问题的约束条件。</p>
<p><strong>Constraint Reduction.</strong> 将约束条件简化为更简单的形式，如编译器中常用的技术，常数折叠、强度降低和简化线性表达式（参见 KLEE [20]）。</p>
<p>EXE[21]引入了约束独立性优化，利用了一个约束集经常可以分成多个独立约束子集的事实。这种优化与查询结果缓存策略交互良好，当引擎向求解器询问特定约束的可满足性时，它还能提供额外的优势，因为它能从查询中删除不相关的约束。事实上，在实际程序中经常出现的独立分支会导致不必要的约束条件迅速累积。</p>
<p>程序在执行过程中会为某些变量添加特定的约束条件，如x:=5，可以对现有约束进行重写和优化，例如在x:=5后，将变量值x的其他约束简化为True，如x&gt;0，还可以在涉及 x 的其他后续约束中用相关的具体值代替符号 x。后一种优化方法也称为隐含值具体化，例如 KLEE [20] 就采用了这种方法。</p>
<p>S2E [29] 引入了比特字段理论表达式简化器，将比特运算掩盖掉的符号变量部分用具体值代替。例如，对于任何 8 位符号值 v，表达式 v | 10,000,0002 的值中最高位总是 1。简化器可以在树形表达式中传播信息，如果可以确定其值中的每一位，表达式就会被替换为相应的常量。</p>
<p><strong>Reuse of Constraint Solutions. </strong> 重用先前约束的计算结果来加快约束求解。目前，大多数约束求解的重用方法都是基于约束的语义或语法等价性。</p>
<p>EXE[21]缓存了约束求解和可满足性查询的结果，以尽可能减少调用求解器的需要。缓存由服务器进程处理，该进程可接收来自多个并行执行引擎实例的查询，每个实例都在探索不同的程序状态。</p>
<p>KLEE [20] 实现了一种名为反例缓存的增量优化策略。通过缓存，约束集被映射为具体的变量赋值，或者在约束集不可满足时映射为特殊的空值。当缓存中的不可满足集是给定约束集 S 的子集时，S 也被视为不可满足。反之，当缓存中包含 S 的超集的解时，该解也必然满足 S。最后，当缓存中包含 S 的一个或多个子集的解时，算法会尝试替换所有解，以检查是否能找到满足 S 的解。</p>
<p><em>Memorized Symbolic execution</em> [115] 的灵感来自于这样一个观察结果，即符号执行往往会导致重新运行大体相似的子问题，例如，发现一个错误，修复它，然后再次测试程序以检查修复是否有效。在路径探索过程中做出的选择会被紧凑地编码在前缀树中，从而为在连续运行中重复使用之前计算出的结果提供了可能。</p>
<p>The Green framework[106]不仅探讨了相同程序运行中的约束解决方案重用，还探讨了类似程序、不同程序和不同分析运行中的约束解决方案重用。通过切片转换，约束被提炼为其基本部分，并以规范形式表示，以实现良好的重用，即使在单次分析运行中也是如此。参考文献[64]介绍了该框架的扩展，它利用约束之间的逻辑蕴涵关系来支持约束重用和更快的执行时间</p>
<p><strong>Lazy Constraints.</strong> 参考文献 [85] 对约束求解器查询采用了一种timeout approch：当执行器遇到涉及代价较高的符号运算的分支语句时，会同时选择真分支和假分支，并在路径条件中添加一个Lazy Constraints。当探索到达满足某个目标的状态时（例如，发现错误），算法将检查路径的可行性，如果认为在实际执行中无法到达，则抑制该路径。</p>
<p>相比于即时检查可行性的eager approach，lazy strategy可能会导致更多的活动状态，进而导致更多的求解器查询。不过，作者报告说，在很多情况下，延迟查询比急切查询更有效： 事实上，在懒惰约束后添加的路径约束可以缩小求解器的求解空间。</p>
<p><strong>Concretization. </strong> 参考文献 [22] 讨论了经典符号执行在遇到约束求解器无法求解（至少无法高效求解）的公式时的局限性。Concolic executor 生成一些随机输入，同时进行具体和符号执行：具体执行中的一个可能值可用于求解器难以解决的公式中涉及的符号操作数，尽管代价可能是牺牲探索过程中的稳健性。</p>
<blockquote>
<p>Example. </p>
<img src="/2023/08/03/A%20Survey%20of%20Symbolic%20Execution%20Techniques/image-20230802111743884.png" class title="image-20230802111743884">
<p>在图 11 的代码片段中，引擎为第 2 行的真分支存储了一个形式为 αx = (αy ∗ αy ) % 50 的非线性约束。不支持非线性运算的求解器无法为程序生成任何输入。但concolic执行器可以利用具体值帮助求解器，例如，如果随机选择 x = 3 和 y = 5 作为初始输入参数，那么在具体执行时就不会出现这两个分支中的任何一个。然而，引擎可以重复使用 y 的具体值，由于 αy = 5，因此可以将之前的查询简化为 αx = 25。现在，引擎可以利用这个查询的直接解决方案来探索两个分支。请注意，如果 y 的值固定为 5，那么就无法生成一个新的输入，该输入只取第一条分支而不取第二条分支，从而导致假否定。在这种情况下，一个微不足道的解决方案是重新运行程序，为 y 选择一个不同的值（例如，如果 y = 2，那么 x = 4，这满足了第一条分支，但不满足第二条分支）。</p>
</blockquote>
<p>为了部分克服具体化带来的不完全性，参考文献 [78] 建议采用具体-符号混合解法，即在将一个或多个符号绑定到特定的具体值之前，先考虑路径上可收集到的所有路径约束。事实上，DART [51] 根据收集到的路径约束将符号具体化到目标分支。这样，同一路径的后续分支中包含的约束条件就不会被考虑在内，而且由于已经具体化的符号，该约束条件可能无法满足。如果出现这种情况，DART 会使用不同的随机具体值重新开始执行，希望能够满足后续分支的要求。参考文献[78]中提出的方法则要求沿着完整路径检测可解约束，并尽可能延迟具体化。</p>
<p><strong>Handling Problematic Constraints. </strong>强SMT求解器能够直接处理更多的路径约束，减少了对具体化的依赖，避免了由于随机选择值限制了可搜索解空间。然而，某些约束问题是不可判定的，如非线性整数运算，或经常用于模拟现实世界系统的三角函数的有理数理论。</p>
<p>参考文献[39]提出了一种concolic walk算法，可以解决涉及非线性运算和库调用的控制流依赖问题。(接下来就看不懂了)该算法将变量的赋值视为估值空间： 线性约束的解定义了一个可启发式行走的多面体，而其余约束的分配则使用一个适度函数来衡量估值点与约束的匹配程度。在多面体上选取点并对其进行非线性约束评估时，会对多面体进行自适应搜索。与具体-符号混合解法 [78] 相比，这两种技术都力求避免盲目承诺。不过，协整行走并不依赖求解器来获取评估复杂约束所需的所有具体输入，而是采用搜索启发式方法，引导在多边形上行走的人走向有希望的区域。</p>
<p>参考文献[40]介绍了符号后向执行（SBE）（第 2 节）和符号前向执行的新颖组合—符号前向执行（symcretic execution）。其主要思路是将探索分为两个阶段。在第一阶段，SBE 从目标点开始执行，并收集每条路径的轨迹。如果在反向探索过程中遇到任何有问题的约束，引擎就会通过在轨迹中添加特殊事件将其标记为潜在可满足的约束，然后继续反向遍历。每当沿着任何一条跟踪路径到达程序的入口点时，第二阶段就开始了。引擎会对收集到的轨迹进行具体评估，尝试满足在第一阶段被标记为有问题的任何约束。这是通过启发式搜索完成的，如上文所述的协程行走。与传统的concolic执行相比，symcretic 的优势在于它可以避免探索某些不可行的路径。例如，无论语句是如何到达的，后向阶段都可以确定该语句受不可满足分支的保护，而传统的concolic执行器只有在到达该语句时才会按路径检测其不可行性，这对路径 “深处 “的语句是不利的。</p>
<h2 id="7-FURTHER-DIRECTIONS"><a href="#7-FURTHER-DIRECTIONS" class="headerlink" title="7 FURTHER DIRECTIONS"></a>7 FURTHER DIRECTIONS</h2><p>相关领域可能用于提升符号执行的最新技术</p>
<h3 id="7-1-Separation-Logic"><a href="#7-1-Separation-Logic" class="headerlink" title="7.1 Separation Logic"></a>7.1 Separation Logic</h3><p>SL(separation logic) 对Hoare逻辑进行了扩展，方便对操作指针数据结构的程序进行推理，并允许以简洁的方式表达堆配置的复杂不变式。</p>
<p>看不到，略</p>
<h3 id="7-2-Invariants"><a href="#7-2-Invariants" class="headerlink" title="7.2 Invariants"></a>7.2 Invariants</h3><blockquote>
<p>Question:什么是不变式？什么是谓词？</p>
</blockquote>
<p>利用不变式可以捕捉循环的效果并对其进行推理，对符号执行器大有裨益，但不需要人工干预情况下计算循环不变式非常困难。</p>
<p>不过，许多研究人员最近探索了自动或只需少量人工帮助即可推断循环不变式的技术[47]</p>
<p><em>Termination analysis</em></p>
<p><em>Predicate abstraction</em></p>
<p><em>LoopFrog</em></p>
<h3 id="7-3-Function-Summaries"><a href="#7-3-Function-Summaries" class="headerlink" title="7.3 Function Summaries"></a>7.3 Function Summaries</h3><blockquote>
<p>Question: 函数摘要是什么样的？如何生成？</p>
</blockquote>
<p>函数摘要（第 5.2 节）主要用于静态和动态程序分析，尤其是程序验证。许多此类工作都为推动符号执行技术的发展提供了有趣的机会。例如，Calysto 静态检查器[10]会走程序的调用图，以构建每个函数效果的符号表示，即返回值、对全局变量的写入以及根据参数访问的内存位置。每个函数只处理一次，可能会在其调用位置内联小函数的效果。Calysto 和 Saturn [114] 等静态检查器在构建摘要时以可扩展性换取健全性，因为它们只对少量迭代的循环进行展开： 因此，在符号执行环境中使用它们，可能会失去健全性。参考文献[44]考虑到不同的输入条件，使用摘要缓存来记忆函数的效果，从而构建了更精细的摘要。<br>参考文献[93]提出了一种为模型检查提取函数摘要的技术，在模型检查中通常一次检查多个规范，因此摘要可以在验证运行中重复使用。特别是，它们是利用插值法（第 5.3 节）作为超近似值计算的，当过于微弱时，可在各次运行中加以完善。这种技术的优势在于，基于插值法的摘要能以比函数本身更简洁的方式捕捉通过函数的所有可能执行轨迹。后来，参考文献[92]将这一技术扩展到处理嵌套函数调用。</p>
<h3 id="7-4-Program-Analysis-and-Optimization"><a href="#7-4-Program-Analysis-and-Optimization" class="headerlink" title="7.4 Program Analysis and Optimization"></a>7.4 Program Analysis and Optimization</h3><p><em>Loop unfolding</em>，展示“结构良好”的循环，（例如，显示不变代码，或将常量或仿射函数作为数组引用的下标）</p>
<p><em>Program synthesis</em>能自动构建一个符合高级规范的程序[82]，这项技术引起了验证界的关注，因为 Reference [97] 已经展示了如何找到程序作为 SAT 问题的解决方案。在第 4 节中，我们讨论了参考文献 [63] 中使用该技术为复杂 Java 框架创建紧凑模型的方法： 该技术将框架中的类、方法和类型作为输入，同时还使用了练习其各部分的教程程序（通常由供应商提供）。我们认为，在路径爆炸问题的背景下，这种方法值得进一步研究。它有可能应用于软件模块（如标准库），以生成简洁的模型，从而对搜索空间进行更具扩展性的探索，因为合成可以捕捉外部行为，同时抽象掉实现过程中的纠缠。</p>
<h3 id="7-5-Symbolic-Computation"><a href="#7-5-Symbolic-Computation" class="headerlink" title="7.5 Symbolic Computation"></a>7.5 Symbolic Computation</h3><p>虽然 SMT 求解器在处理复杂表达式时结合理论和启发式的效率很高，但它们只在很小程度上利用了符号计算技术，而且对非线性实数和整数运算的支持仍处于起步阶段 [1]。据我们所知，只有 Z3 [36] 和 SMT-RAT [33] 可以同时对它们进行推理。<br>参考文献[1]指出，将符号计算技术作为 SMT 求解器的理论插件是一种很有前途的共生关系，因为它们为求解算术约束的连接提供了强大的程序。但由于这些程序的现有实现并不符合 SMT 兼容理论求解器所要求的增量、回溯和解释不一致性等特性，因此这一想法的实现受到了阻碍。SC2 [2]是一个值得关注的项目，其目标是创建一个新的社区，旨在弥合符号计算与可满足性检查之间的差距，结合两个领域的优势，解决目前各自无法解决的问题。</p>
<p>在处理非线性表达式时，还可以从符号-数值计算的最新进展中找到更多提高效率的机会[56]。特别是，这些技术旨在开发高效的多项式求解器，将数值算法与符号计算技术的保证结合起来，数值算法在近似局部解方面非常高效，但缺乏全局视角。这种混合技术可以扩展可高效求解问题的范围，因此对符号执行的非线性约束很有意义。</p>
<h2 id="8-CONCLUSIONS"><a href="#8-CONCLUSIONS" class="headerlink" title="8 CONCLUSIONS"></a>8 CONCLUSIONS</h2></div><div class="article-licensing box"><div class="licensing-title"><p><a href="http://curator-kim.github.io/2023/08/03/A Survey of Symbolic Execution Techniques/">http://curator-kim.github.io/2023/08/03/A Survey of Symbolic Execution Techniques/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><a href="http://Curator-Kim.github.io"><p>Curator-Kim</p></a></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2023-08-03</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-08-03</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># Related Post</span><br><span>  1.<a class="is-size-6" href="/2023/10/10/Large%20language%20model%20are%20Zero-Shot%20Fuzzers%20Fuzzing%20Deep-Learning%20Libraries%20via%20Large%20Language%20Models/" target="_blank"> </a><br></span><span>  2.<a class="is-size-6" href="/2023/10/02/A%20deep%20convolution%20generative%20adversarial%20networks%20based%20fuzzing%20framework%20for%20industry%20control%20protocols/" target="_blank"> </a><br></span><span>  3.<a class="is-size-6" href="/2023/09/26/NEUZZ%20Efficient%20Fuzzing%20with%20Neural%20Program%20Smoothing/" target="_blank"> </a><br></span><span>  4.<a class="is-size-6" href="/2023/09/13/Universal%20Fuzzing%20via%20Large%20Language%20Models/" target="_blank"> </a><br></span><span>  5.<a class="is-size-6" href="/2023/09/03/NAUTILUS%20Fishing%20for%20Deep%20Bugs%20with%20Grammars/" target="_blank"> </a><br></span><span>  6.<a class="is-size-6" href="/2023/08/26/%E9%99%87%E5%89%91%E6%9D%AF%202023%20Writeup/" target="_blank"> </a><br></span><span>  7.<a class="is-size-6" href="/2023/08/25/ICS%20Protocol%20Fuzzing%20Coverage%20Guided%20Packet%20Crack%20and%20Generation/" target="_blank"> </a><br></span><span>  8.<a class="is-size-6" href="/2023/08/21/Skyfire%20Data-Driven%20Seed%20Generation%20for%20Fuzzing/" target="_blank"> </a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/alipay.png?raw=true" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/wechat.png?raw=true" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/08/03/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E4%B8%80/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">加密与解密(一)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/07/04/CrackMe%E7%B3%BB%E5%88%97/"><span class="level-item"> </span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">Comments</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'd41d8cd98f00b204e9800998ecf8427e',
            repo: 'blog_comment',
            owner: 'Curator-Kim',
            clientID: '46a9f3481b46ea0129d8',
            clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24',
            admin: ["Curator-Kim"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/22a41709ffc26f62191d72a87ffbb342d46bfce3/img/icon.jpg?raw=true" alt="Curator-Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Curator-Kim</p><p class="is-size-6 is-block">寻几处好景破星光</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>火星</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/curator-kim"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="/804242129@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"From《"+data.from+"》</p><p>Provider-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-10T11:53:02.684Z">2023-10-10</time></p><p class="title"><a href="/2023/10/10/Large%20language%20model%20are%20Zero-Shot%20Fuzzers%20Fuzzing%20Deep-Learning%20Libraries%20via%20Large%20Language%20Models/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-02T01:51:32.930Z">2023-10-02</time></p><p class="title"><a href="/2023/10/02/A%20deep%20convolution%20generative%20adversarial%20networks%20based%20fuzzing%20framework%20for%20industry%20control%20protocols/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-26T01:06:57.809Z">2023-09-26</time></p><p class="title"><a href="/2023/09/26/NEUZZ%20Efficient%20Fuzzing%20with%20Neural%20Program%20Smoothing/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-13T14:39:39.205Z">2023-09-13</time></p><p class="title"><a href="/2023/09/13/Universal%20Fuzzing%20via%20Large%20Language%20Models/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-03T11:11:20.649Z">2023-09-03</time></p><p class="title"><a href="/2023/09/03/NAUTILUS%20Fishing%20for%20Deep%20Bugs%20with%20Grammars/"> </a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2023/10/"><span class="level-start"><span class="level-item">October 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/09/"><span class="level-start"><span class="level-item">September 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/07/"><span class="level-start"><span class="level-item">July 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><span class="tag">汇编语言</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Crypto/"><span class="tag">Crypto</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ctf/"><span class="tag">ctf</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pwn/"><span class="tag">pwn</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CopperSmith/"><span class="tag">CopperSmith</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DES/"><span class="tag">DES</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HWS/"><span class="tag">HWS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NTRU/"><span class="tag">NTRU</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RE/"><span class="tag">RE</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reverse/"><span class="tag">Reverse</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/angr/"><span class="tag">angr</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"><span class="tag">加密与解密</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"><span class="tag">参考资料</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"><span class="tag">论文阅读</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"><span class="tag">预备知识</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://github.com/Curator-Kim/Curator-Kim.github.io/blob/master/img/logo.png?raw=true" alt="Curator-Kim的小站" height="28"></a><p class="size-small"><span>&copy; 2023 Curator-Kim</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">粤ICP备88888888号-8（测试）</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️Site from <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> has existed <strong>" + dnum + "</strong> d <strong>" + hnum + "</strong> h <strong>" + mnum + "</strong> m <strong>" + snum + "</strong> s！❤️";
        }var now = new Date();setInterval("createTime('2022/1/21 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️Thx <strong><span id="busuanzi_value_site_uv">99+</span></strong> users <strong><span id="busuanzi_value_site_pv">99+</span></strong> visited！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="137510737" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','Curator-Kim','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','Curator-Kim','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>